{"/Centi_S3_doc/zh/MicroPython/What_is_MicroPython.html":{"title":"","content":"## 什么是 MicroPython？ ![](../assets/images/Mircopython.png) [MicroPython](https://micropython.org/)是Python 3编程语言的精益高效实现，包括 Python 标准库的一小部分，并且经过优化，可在微控制器和有限的硬件资源中运行。 由 [Damien P. George](https://dpgeorge.net/) 于 2013年 众筹开源。 它与使用C程序开发微控制器最明显的差异性，就是验证代码时无需漫长的编译。 使用串口通信软件，通过REPL(read eval print loop)输入命令来控制微控制器，和Python的REPL一样。 也可使用一些工具将 python 脚本文件上传到微控制器内运行。 它对Python 3 的实现，包括了支持多线程的 _thread 库，编写并发代码的 asyncio 库。 它尽可能与普通Python兼容，允许您轻松地将代码从桌面端移植到微控制器。 同时它还具备一些特定用于微控制器的库，以便充分利用微控制器芯片内的硬件功能，例如定时器，硬件中断，WiFi等，这取决于具体的硬件。 在具备上述特性的同时，它的硬件开销很少，最低只需 256k 的代码空间和 16k 的 RAM 即可运行。 如果你了解Python，很大程度上你就已经了解MicroPython了。 在另一方面，你深入地学习MicroPython，也能提升你对Python的理解。"},"/Centi_S3_doc/zh/MicroPython/Display_text.html":{"title":"","content":"## 显示文本字符 ### text 方法 `text(font, s, x, y {, fg, bg, alpha})` 使用指定的位图字体 `font` ，将文本字符 `s` 写入显示器的指定坐标，坐标 `x,y` 为文本的左上角。 可选参数 `fg` 和 `bg` 可以设置文本的前景色和背景色； 若不设置这两个参数，则前景色默认为白色，背景色默认为黑色。 `alpha` 默认为 255。 ### 位图字体 BPI Centi S3 出厂固件中有包含两个位图字体文件。 `vga1_8x16.mpy` `vga1_bold_16x32.mpy` 它们来自于 https://github.com/russhughes/st7789s3_esp_lcd/tree/main/fonts/bitmap 。 我从中选取了这两个最常用的，使用[mpy cross工具](https://pypi.org/project/mpy cross/)将它们转化为`.mpy`格式，以此缩小文件体积。 ### 下载字体文件 如果你误删了字体文件，或擦除过flash，则需再次下载字体文件，你可以从前文链接中下载，也可从下方链接中下载已转化为`.mpy`格式的字体与例程文件。 [从此链接下载字体与例程文件](https://github.com/BPI STEAM/BPI Centi S3 Doc/tree/main/micropython_example/04_display_text) ### 显示文本 ![](../assets/images/Display_text_1.jpg) ```py \"\"\" BPI Centi S3 170x320 ST7789 display \"\"\" import st7789 import tft_config import vga1_8x16 import vga1_bold_16x32 \"\"\" These default colors can be used: BLACK BLUE CYAN GREEN MAGENTA RED YELLOW WHITE TRANSPARENT Custom RGB colors: color565(255,255,255) \"\"\" fg st7789.BLACK bg st7789.WHITE text_x 10 text_y 10 def main(): try: tft tft_config.config(rotation 1) tft.init() tft.fill(st7789.WHITE) tft.text(vga1_8x16, \"Hello World!\", text_x, text_y, fg, bg, 255) tft.text(vga1_bold_16x32, \"MicroPython!\", text_x, text_y+16, fg, bg, 255) tft.text(vga1_8x16, \"vga1_8x16\", text_x, text_y+16+32, fg, bg, 255) tft.text(vga1_bold_16x32, \"vga1_bold_16x32\", text_x, text_y+16+32+16, fg, bg, 255) tft.show() except BaseException as err: err_type err.__class__.__name__ print('Err type:', err_type) from sys import print_exception print_exception(err) finally: tft.deinit() print(\"tft deinit\") main() ``` ### 使用透明背景与Alpha 通道制作阴影字体 ![](../assets/images/Display_text_2.jpg) 合理利用 st7789.TRANSPARENT 作为文本的背景色，可以使文本的背景不发生变化。 再通过设置 text 方法 中的 alpha 参数，可以改变文本整体的透明度，范围为0~255。 ```py \"\"\" BPI Centi S3 170x320 ST7789 display \"\"\" import st7789 import tft_config import vga1_8x16 import vga1_bold_16x32 \"\"\" These default colors can be used: BLACK BLUE CYAN GREEN MAGENTA RED YELLOW WHITE TRANSPARENT Custom RGB colors: color565(255,255,255) \"\"\" fg st7789.BLACK bg st7789.TRANSPARENT text_x 10 text_y 50 def main(): try: tft tft_config.config(rotation 1) tft.init() tft.fill(st7789.WHITE) tft.text(vga1_8x16, \"Hello World!\", text_x 1, text_y 1, fg, bg, 205) tft.text(vga1_bold_16x32, \"MicroPython!\", text_x 2, text_y+16 2, fg, bg, 205) tft.text(vga1_8x16, \"Hello World!\", text_x, text_y, fg, bg, 255) tft.text(vga1_bold_16x32, \"MicroPython!\", text_x, text_y+16, fg, bg, 255) tft.show() except BaseException as err: err_type err.__class__.__name__ print('Err type:', err_type) from sys import print_exception print_exception(err) finally: tft.deinit() print(\"tft deinit\") main() ```"},"/Centi_S3_doc/zh/MicroPython/REPL_use_case.html":{"title":"","content":"## REPL使用技巧 ### REPL快捷键 1. 复制 `ctrl + shift + c`。 2. 粘贴 `ctrl + shift + v`。 使用鼠标左键在REPL中拖选需要复制的命令，键盘按下复制快捷键，再按下粘贴快捷键即可复制粘贴命令。 3. 软复位 `ctrl + d`。 4. 中断 `ctrl + c`, 中断当前正在执行的程序，但不会重启复位。 ### 查看内置模块 1. 在REPL中输入 `help(\"modules\")` 将列出当前CircuitPython开发板内所有模块。 2. 导入模块后可再使用`help()`函数查看该模块内部可用的函数名或变量名。 ```py import machine help(machine) ```"},"/Centi_S3_doc/zh/MicroPython/Display_multiple_vector_fonts.html":{"title":"","content":"## 显示多种矢量字体 ### draw 方法 `draw(vector_font, s, x, y {, fg, scale, alpha})` 绘制 s 文本到显示器，使用指定的Hershey矢量字体，坐标为文本的左下角。文本的前景色可以由可选参数fg设置，默认前景色为白色。文本的大小可以通过指定scale比例值进行缩放。scale必须大于0，可以是浮点数或整数值。scale默认为1.0。alpha透明度默认为255。 ### draw_len 方法 `draw_len(vector_font, s {, scale})` 返回使用指定字体绘制的 s 字符串在像素中的宽度。 ### 下载矢量字体库 在[GitHub:russhughes/st7789s3_esp_lcd/fonts/vector](https://github.com/russhughes/st7789s3_esp_lcd/tree/main/fonts/vector)仓库中有py文件格式的矢量字体库，在README中有所有字体的图样。 在[例程的lib](https://github.com/BPI STEAM/BPI Centi S3 Doc/tree/main/micropython_example/07_display_multiple_vector_fonts/lib)中则还能下载到已转化为mpy文件格式的矢量字体库，占用更少的flash空间。 ### 显示多种矢量字体并连续刷新 通过 draw_len 方法可以获取将要显示的字符串宽度，但已提供的部分矢量字体的高度会超过设定值，如果需要保持文本框完全覆盖它，则需要修改相应代码，增加文本框的高度。 > [从此GitHub链接下载完整例程](https://github.com/BPI STEAM/BPI Centi S3 Doc/tree/main/micropython_example/07_display_multiple_vector_fonts) ![](../assets/images/pic_4.jpg) ![](../assets/images/Display_multiple_vector_fonts_2.jpg) ```py \"\"\" BPI Centi S3 170x320 ST7789 display \"\"\" import st7789 import tft_config import gotheng import italicc import romanc import time import gc from math import ceil \"\"\" These default colors can be used: BLACK BLUE CYAN GREEN MAGENTA RED YELLOW WHITE TRANSPARENT Custom RGB colors: color565(255,255,255) \"\"\" class DrawRect: def __init__(self): self.tft None self.text_y None self.text_x None self.rect_x None self.rect_y None self.rect_height None self.rect_width None def rect(self, tft, vector_font, scale, text, text_coord, fg st7789.WHITE, bg st7789.BLACK, alpha_text 255, alpha_rect 255): self.tft tft self.rect_width self.tft.draw_len(vector_font, text, scale) self.rect_height ceil(vector_font.HEIGHT * scale) self.text_x text_coord[0] self.text_y text_coord[1] self.rect_x ceil(self.text_x vector_font.WIDTH * scale / 8) self.rect_y round(self.text_y vector_font.HEIGHT * scale / 2 + 1) self.tft.fill_rect(self.rect_x, self.rect_y, self.rect_width, self.rect_height, bg, alpha_rect) self.tft.draw(vector_font, text, self.text_x, self.text_y, fg, scale, alpha_text) def erase(self, bg): buffer, _, _ self.tft.jpg_decode(bg, self.rect_x, self.rect_y, self.rect_width, self.rect_height) self.tft.blit_buffer(buffer, self.rect_x, self.rect_y, self.rect_width, self.rect_height) def main(): try: tft tft_config.config(rotation 1) tft.init() jpg 'pic_4.jpg' tft.jpg(jpg, 0, 0) text_x 10 text_y 20 text_list [ \" !\\\"#$%&'()*+, ./\", \"0123456789:;< >?\", \"@ABCDEFGHIJKLMNO\", \"PQRSTUVWXYZ[\\]^_\", \"`abcdefghijklmno\", \"pqrstuvwxyz{}~\", ] draw_rect_1 DrawRect() draw_rect_2 DrawRect() draw_rect_3 DrawRect() while True: for i in text_list: draw_rect_1.rect(tft, gotheng, 0.8, i, (text_x, text_y), fg st7789.WHITE, bg st7789.BLACK, alpha_text 255, alpha_rect 20) draw_rect_2.rect(tft, italicc, 0.8, i, (text_x, text_y+32), fg st7789.WHITE, bg st7789.BLACK, alpha_text 255, alpha_rect 40) draw_rect_3.rect(tft, romanc, 0.8, i, (text_x, text_y + 64), fg st7789.WHITE, bg st7789.BLACK, alpha_text 255, alpha_rect 60) tft.show() time.sleep(0.5) draw_rect_1.erase(bg jpg) draw_rect_2.erase(bg jpg) draw_rect_3.erase(bg jpg) gc.collect() except BaseException as err: err_type err.__class__.__name__ print('Err type:', err_type) from sys import print_exception print_exception(err) finally: tft.deinit() print(\"tft deinit\") main() ``` ### 放大或缩小字体 修改 draw 方法的 scale 比例值即可控制字体大小。 ![](../assets/images/Display_multiple_vector_fonts_1.jpg) ```py \"\"\" BPI Centi S3 170x320 ST7789 display \"\"\" import st7789 import tft_config import gotheng import italicc import romanc import time import gc from math import ceil \"\"\" These default colors can be used: BLACK BLUE CYAN GREEN MAGENTA RED YELLOW WHITE TRANSPARENT Custom RGB colors: color565(255,255,255) \"\"\" class DrawRect: def __init__(self): self.tft None self.text_y None self.text_x None self.rect_x None self.rect_y None self.rect_height None self.rect_width None def rect(self, tft, vector_font, scale, text, text_coord, fg st7789.WHITE, bg st7789.BLACK, alpha_text 255, alpha_rect 255): self.tft tft self.rect_width self.tft.draw_len(vector_font, text, scale) self.rect_height ceil(vector_font.HEIGHT * scale) self.text_x text_coord[0] self.text_y text_coord[1] self.rect_x ceil(self.text_x vector_font.WIDTH * scale / 8) self.rect_y round(self.text_y vector_font.HEIGHT * scale / 2 + 1) self.tft.fill_rect(self.rect_x, self.rect_y, self.rect_width, self.rect_height, bg, alpha_rect) self.tft.draw(vector_font, text, self.text_x, self.text_y, fg, scale, alpha_text) def erase(self, bg): buffer, _, _ self.tft.jpg_decode(bg, self.rect_x, self.rect_y, self.rect_width, self.rect_height) self.tft.blit_buffer(buffer, self.rect_x, self.rect_y, self.rect_width, self.rect_height) def main(): try: tft tft_config.config(rotation 1) tft.init() jpg 'pic_4.jpg' tft.jpg(jpg, 0, 0) text_x 10 text_y 20 text_list [ \"!\\\"#$%&'()*\", \"0123456789\", \"ABCDEFGHI\", \"PQRSTUVWX\", \"abcdefghij\", \"pqrstuvwxy\", ] draw_rect_1 DrawRect() draw_rect_2 DrawRect() draw_rect_3 DrawRect() while True: for i in text_list: draw_rect_1.rect(tft, romanc, 0.5, i, (text_x, text_y), fg st7789.WHITE, bg st7789.BLACK, alpha_text 255, alpha_rect 20) draw_rect_2.rect(tft, romanc, 1, i, (text_x, text_y+24), fg st7789.WHITE, bg st7789.BLACK, alpha_text 255, alpha_rect 40) draw_rect_3.rect(tft, romanc, 1.5, i, (text_x, text_y + 64), fg st7789.WHITE, bg st7789.BLACK, alpha_text 255, alpha_rect 60) tft.show() time.sleep(0.5) draw_rect_1.erase(bg jpg) draw_rect_2.erase(bg jpg) draw_rect_3.erase(bg jpg) gc.collect() except BaseException as err: err_type err.__class__.__name__ print('Err type:', err_type) from sys import print_exception print_exception(err) finally: tft.deinit() print(\"tft deinit\") main() ```"},"/Centi_S3_doc/zh/MicroPython/lcd_init.html":{"title":"","content":"## 屏幕初始化 BPI Centi S3 正面有一块1.9英寸TFT LCD彩屏，分辨率是170*320，驱动芯片为ST7789V3, 采用8bit 并行接口与ESP32S3芯片连接。 出厂固件中已集成ST7789 C模块 驱动，来自于: [russhughes/st7789s3_esp_lcd](https://github.com/russhughes/st7789s3_esp_lcd) , The MIT License 感谢 russhughes 的开源，在他的GitHub README中可以查阅编译方法和所有API接口。 ### 初始化，点亮屏幕 <iframe src \"//player.bilibili.com/player.html?aid 269437418&bvid BV1hc4115786&cid 1078595731&page 1&autoplay 0\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> 在本地文件夹中创建一个 main.py ，将下方代码拷贝进去，保存文件。 > 使用 `ctrl + S` 快捷键即可保存当前窗口中的文件。 ```py \"\"\" BPI Centi S3 170x320 ST7789 display \"\"\" import st7789 from machine import freq def config(rotation 0, options 0): return st7789.ST7789( 170, 320, 15, 14, 13, 12, 11, 10, 9, 8, wr 6, rd 7, reset 3, dc 5, cs 4, backlight 2, power 2, rotation rotation, options options) freq(240_000_000) # Set esp32s3 cpu frequency to 240MHz tft config(rotation 1, options 0) tft.init() # Initialize tft.fill(st7789.RED) tft.show(True) tft.deinit() # Deinitialize the display or it will cause a crash on the next run ``` 使用mpbridge同步文件到开发板。 同步完成后，BPI Centi S3 屏幕将全屏显示红色。 ### 单独的配置文件 我们可以将初始化配置ST7789的代码单独置于一个python脚本文件中，然后在其他地方任意导入使用，包括在REPL中，这可以增强代码复用性。 新建一个单独的配置文件 tft_config.py ，将下方代码拷贝进去，保存文件。 ```py \"\"\" BPI Centi S3 170x320 ST7789 display \"\"\" import st7789 from machine import freq def config(rotation 0, options 0): return st7789.ST7789( 170, 320, 15, 14, 13, 12, 11, 10, 9, 8, wr 6, rd 7, reset 3, dc 5, cs 4, backlight 2, power 2, rotation rotation, options options) freq(240_000_000) # Set esp32s3 cpu frequency to 240MHz ``` 将 main.py 修改为如下代码： ```py \"\"\" BPI Centi S3 170x320 ST7789 display \"\"\" import st7789 import tft_config tft tft_config.config(rotation 1, options 0) tft.init() tft.fill(st7789.RED) tft.show(True) tft.deinit() # Deinitialize the display or it will cause a crash on the next run ``` 使用mpbridge同步文件到开发板。 后续我们就可以像这样简单的导入然后初始化屏幕了。"},"/Centi_S3_doc/zh/MicroPython/Make_semi-transparent_rectangular_text_box.html":{"title":"","content":"## 制作半透明矩形文本框 ### fill_rect 方法 `fill_rect(x, y, width, height {, color, alpha})` 设`x`, `y`坐标，绘制一个宽度为`width`，高度为`height`的填充矩形，颜色为`color`，可选设置`alpha`使其与背景混合。 `color`默认为BLACK黑色，`alpha`默认为255。 > [从此GitHub链接下载完整例程](https://github.com/BPI STEAM/BPI Centi S3 Doc/tree/main/micropython_example/05_semi transparent_rectangular_text_box) ### 在图片上显示半透明矩形 ![](../assets/images/pic_5.jpg) 我们可以在这个图片上显示一个半透明的黑色矩形框。 ![](../assets/images/semi transparent_rectangular_text_box_1.jpg) ```py \"\"\" BPI Centi S3 170x320 ST7789 display \"\"\" import st7789 import tft_config import gc def main(): try: tft tft_config.config(rotation 1) tft.init() gc.collect() tft.jpg('pic_5.jpg', 0, 0) tft.fill_rect(20, int(170/2 32), 320 20 20, 32, st7789.BLACK, 60) tft.show() gc.collect() except BaseException as err: err_type err.__class__.__name__ print('Err type:', err_type) from sys import print_exception print_exception(err) finally: tft.deinit() print(\"tft deinit\") main() ``` ### 在半透明矩形框内显示文本 ![](../assets/images/semi transparent_rectangular_text_box_2.jpg) ```py \"\"\" BPI Centi S3 170x320 ST7789 display \"\"\" import st7789 import tft_config import gc import time import vga1_bold_16x32 fg st7789.WHITE bg st7789.TRANSPARENT text_x 20 text_y int(170/2 32) rect_width 320 20 20 rect_height 32 def main(): try: tft tft_config.config(rotation 1) tft.init() gc.collect() tft.jpg('pic_5.jpg', 0, 0) tft.fill_rect(text_x, text_y, rect_width, rect_height, st7789.BLACK, 60) tft.text(vga1_bold_16x32, \"Hello World!\", text_x, text_y, fg, bg, 255) tft.show() gc.collect() except BaseException as err: err_type err.__class__.__name__ print('Err type:', err_type) from sys import print_exception print_exception(err) finally: tft.deinit() print(\"tft deinit\") main() ``` ### 根据字符长度创建半透明文本框 ![](../assets/images/semi transparent_rectangular_text_box_3.jpg) ```py \"\"\" BPI Centi S3 170x320 ST7789 display \"\"\" import st7789 import tft_config import gc import time import vga1_bold_16x32 fg st7789.WHITE bg st7789.TRANSPARENT text_x 20 text_y int(170/2 32) def text_rect(tft, font, font_size, text: str, text_coord, fg st7789.WHITE, bg st7789.BLACK, alpha_text 255, alpha_rect 255): rect_width font_size[0] * len(text) rect_height font_size[1] tft.fill_rect(text_coord[0], text_coord[1], rect_width, rect_height, bg, alpha_rect) tft.text(font, text, text_coord[0], text_coord[1], fg, st7789.TRANSPARENT, alpha_text) def main(): try: tft tft_config.config(rotation 1) tft.init() gc.collect() tft.jpg('pic_5.jpg', 0, 0) text_rect(tft, vga1_bold_16x32, (16, 32), \"Hello World!\", (text_x, text_y), fg st7789.WHITE, bg st7789.BLACK, alpha_text 80, alpha_rect 60) text_rect(tft, vga1_bold_16x32, (16, 32), \"It's MicroPython!\", (text_x, text_y+32), fg st7789.WHITE, bg st7789.BLACK, alpha_text 255, alpha_rect 60) tft.show() gc.collect() except BaseException as err: err_type err.__class__.__name__ print('Err type:', err_type) from sys import print_exception print_exception(err) finally: tft.deinit() print(\"tft deinit\") main() ```"},"/Centi_S3_doc/zh/MicroPython/Refres_textbox_on_jpg.html":{"title":"","content":"## 在JPG上刷新文本框 ### jpg_decode 方法 `jpg_decode(jpg_filename {, x, y, width, height})` 解码一个jpg文件并返回一个元组，包括（buffer, width, height）。buffer缓冲区是一个与color565 blit_buffer兼容的字节数组。缓冲区将需要 width宽度 * height高度 * 2字节的内存。 如果提供了可选的 x, y, width, height 参数，buffer缓冲区将只包含图像的指定区域。 ### blit_buffer 方法 `blit_buffer(buffer, x, y, width, height {, alpha})` 将bytes()或bytearray()的内容复制到屏幕内存中，x, y, width, height指定区域。注意：数组中每个颜色需要2字节。alpha默认为255。 ### 在JPG上局部刷新半透明文本框 ![](../assets/images/pic_6.jpg) 在[根据字符长度创建半透明文本框](./Make_semi transparent_rectangular_text_box.md#根据字符长度创建半透明文本框)的基础上，将text_rect方法改写为一个class类，并增加一个erase方法，在其中使用jpg_decode 方法储存半透明文本框背景，再使用blit_buffer 方法覆盖掉半透明文本框，实现局部刷新。 ![](../assets/images/Refres_textbox_on_jpg.jpg) > [从此GitHub链接下载完整例程](https://github.com/BPI STEAM/BPI Centi S3 Doc/tree/main/micropython_example/06_textbox_partial_refresh) ```py \"\"\" BPI Centi S3 170x320 ST7789 display \"\"\" import st7789 import vga1_bold_16x32 import tft_config import gc import time class TextRect: def __init__(self): self.tft None self.text_y None self.text_x None self.rect_height None self.rect_width None def rect(self, tft, font, text, text_coord, fg st7789.WHITE, bg st7789.BLACK, alpha_text 255, alpha_rect 255): self.tft tft self.rect_width font.WIDTH * len(text) self.rect_height font.HEIGHT self.text_x text_coord[0] self.text_y text_coord[1] self.tft.fill_rect(self.text_x, self.text_y, self.rect_width, self.rect_height, bg, alpha_rect) self.tft.text(font, text, self.text_x, self.text_y, fg, st7789.TRANSPARENT, alpha_text) def erase(self, bg): buffer, _, _ self.tft.jpg_decode(bg, self.text_x, self.text_y, self.rect_width, self.rect_height) self.tft.blit_buffer(buffer, self.text_x, self.text_y, self.rect_width, self.rect_height) def main(): try: text_x 10 text_y int(170 / 2 32) tft tft_config.config(rotation 1) jpg 'pic_6.jpg' text_list [ \"This Is Just To Say\", \"I have eaten\", \"the plums\", \"that were in\", \"the icebox\", \"and which\", \"you were probably\", \"saving\", \"for breakfast\", \"Forgive me\", \"they were delicious\", \"so sweet\", \"and so cold\"] tft.init() gc.collect() tft.jpg(jpg, 0, 0) text_rect_1 TextRect() while True: for i in text_list: text_rect_1.rect(tft, vga1_bold_16x32, i, (text_x, text_y), fg st7789.YELLOW, bg st7789.BLACK, alpha_text 30, alpha_rect 80) tft.show() time.sleep(0.5) text_rect_1.erase(bg jpg) gc.collect() except BaseException as err: err_type err.__class__.__name__ print('Err type:', err_type) from sys import print_exception print_exception(err) finally: tft.deinit() print(\"tft deinit\") main() ```"},"/Centi_S3_doc/zh/MicroPython/VScode_mpbridge.html":{"title":"","content":"## VScode + mpbridge工具使用方法 > 需要先[安装 Visual Studio Code](./environment.html#安装 visual studio code)，[安装mpbridge工具](./environment.html#安装mpbridge工具)。 ### Python扩展 在扩展项中搜索`python`，安装Python扩展支持。 ![](../assets/images/vscode_mpbridge_1.png) ### 打开文件夹 在文件资源管理器项中点击`Open Folder`，打开一个文件夹，或新建一个空白文件夹。 这里尤其建议新手先从一个空白文件夹开始上手。 ![](../assets/images/vscode_mpbridge_2.png) ### 打开终端 点击`Terminal`项，点击`New Terminal`项，将会打开一个新的终端窗口，通常出现在下方框体中。 ![](../assets/images/vscode_mpbridge_3.png) ### mpbridge列出串行端口编号 首先应确保你的MicroPython开发板已与你的计算机建立串行数据连接。 在终端中输入以下命令并点击回车键，将列出计算机上所有串行端口编号。 ```sh mpbridge list ``` ![](../assets/images/vscode_mpbridge_4.png) 如果你的计算机中仅有连接一个串行设备，且它就是你的MicroPython开发板，那么这个串行端口编号就是开发板的。 如果你的计算机连接多个串行设备，你可以通过接入设备查看一次编号列表，拔出设备查看一次编号列表，来找到唯一变动的一项，这一项就是你的MicroPython开发板的串行端口编号。 ### mpbridge 连接开发板 在终端中输入以下命令，将末尾的串行端口编号修改为上一步所确定的编号，然后点击回车键，如果你当前打开的是一个空白文件夹的话，mpbridge工具将首先将MicroPython开发板上的文件拷贝到此文件夹内。 ```sh mpbridge dev auto reset hard COM6 ``` ![](../assets/images/vscode_mpbridge_5.png) 当文件拷贝完成后，终端中将显示: ``` ? Press [Enter] to Clean Sync & Enter REPL Press [Ctrl + C] to exit ``` 想要进入REPL则再次单击回车键，想要退出工具则使用 `Ctrl + C`快捷键。 在进去REPL前，开发板会被硬复位一次，以便于立即查看程序结果。 如果你不希望硬复位，则使用这个命令： ```sh mpbridge dev COM6 ``` 如果你想使用软复位，则： ```sh mpbridge auto reset soft COM6 ``` ![](../assets/images/vscode_mpbridge_6.png) 当你进入REPL后，在任何时候，你仅需使用`Ctrl + X`快捷键即可退出REPL。 ![](../assets/images/vscode_mpbridge_7.png) ### 修改或新增文件 如果你在退出REPL之前，在本地文件夹中修改了某个文件内的代码，或是增加了某个文件，mpbridge工具将自动检查变更的文件并同步到开发板上。 ```sh mpbridge dev auto reset hard COM6 ``` 在终端中开始运行这个命令时，也会这么做。 ![](../assets/images/vscode_mpbridge_11.png) ### 删除文件 ```sh mpbridge dev auto reset hard COM6 ``` 当这个命令完成了文件的同步后，终端中将显示: ``` ? Press [Enter] to Clean Sync & Enter REPL Press [Ctrl + C] to exit ``` 如果你需要删除某个或多个文件，则先在本地文件夹内删除它，然后再点击回车键，mpbridge工具将自动执行`Clean Sync`，将开发板中的同名文件也删除掉，最后进入REPL。 ![](../assets/images/vscode_mpbridge_8.png) ![](../assets/images/vscode_mpbridge_9.png) ![](../assets/images/vscode_mpbridge_10.png) 如果你仅仅想要临时删除开发板上的文件，而需要在计算机本地保留文件，请记得提前备份文件到其他文件夹中。 ### mpbridge 做了什么？ ```sh mpbridge dev auto reset hard COM6 ``` 开始运行这个命令时，以及退出REPL后，mpbridge都将自动进行这些文件操作： 1. 将存在于本地但不存在于设备中的文件推送到设备中。 2. 对同时存在于本地和设备中的文件进行哈希检查，将不同的文件从本地推送到设备中。 3. 将不存在于本地但存在于设备中的文件拉取到本地。 每当终端显示此提示时： ``` ? Press [Enter] to Clean Sync & Enter REPL Press [Ctrl + C] to exit ``` 再次按下回车键，mpbridge都将自动进行这些文件操作： 1. 将存在于本地但不存在于设备中的文件推送到设备中。 2. 对同时存在于本地和设备中的文件进行哈希检查，将不同的文件从本地推送到设备中。 3. 将不存在于本地但存在于设备中的文件，从设备中删除。 4. 硬复位设备，进入REPL。 若是此时按下`Ctrl + C`快捷键，则会退出mpbridge工具。"},"/Centi_S3_doc/zh/MicroPython/Burn_firmware.html":{"title":"","content":"## 烧录固件 > BPI Centi S3 出厂已烧录了具备st7789并口驱动的MicroPython固件，通常可跳过此步。 如果你在开发产生意外的恶性BUG使开发板无法正常启动，或其他原因导致固件被擦除或损坏，你可以从下面的 github 链接中找到已编译好的固件自行烧录。 [BPI Centi S3 micropython固件，github存档](https://github.com/BPI STEAM/BPI Centi S3 Doc/tree/main/micropython_st7789s3_firmware) ## 固件信息 1. micropython1.19.1_esp32s3_qspram_st7789s3.bin * micropython 1.19.1 release tag * esp32s3, Quad SPIRAM, 8M flash * russhughes/st7789s3_esp_lcd 2. micropython1.20.0dev_esp32s3_qspram_st7789s3.bin * micropython 1.20.0 master dev, 直到2023/06/06(mip, espnow) * esp32s3, Quad SPIRAM, 8M flash * russhughes/st7789s3_esp_lcd ### 设置固件下载模式 有两种操作方法： 1.通过USB连接到电脑，按住BOOT键，再按一下RESET键并松开，最后松开BOOT键。 2.在断开供电的条件下按住BOOT键，再通过USB连接到电脑，最后松开BOOT键。 由此可知，芯片是通过BOOT键所控制的GPIO0来选择复位或重新上电时的启动模式。 在设备管理器中确认COM接口，固件下载模式与普通模式下的com接口序号通常是不一样的。 ### 安装esptool工具 在终端中输入以下命令安装 esptool。 ``` pip install esptool ``` ### esptool命令 > 所有对flash的操作都是不可逆的，注意备份有价值的数据。 * 擦除flash ``` python m esptool chip esp32s3 port COM1 baud 460800 erase_flash ``` * 写入flash ``` python m esptool chip esp32s3 port COM1 baud 460800 before usb_reset after no_reset write_flash 0x0 esp32s3_micropython_qspram_st7789s3_idf4.4.3.bin ```"},"/Centi_S3_doc/zh/MicroPython/Interacting_with_menu_bar_using_the_rotary_encoder.html":{"title":"","content":"## 使用旋转编码器与菜单栏交互，做一个电子相册 BPI Centi S3上自带一个增量型旋转编码器，利用它可以很方便的与屏幕上显示的内容进行交互控制。 ![](../assets/images/BPI Centi S3_drawio.png) ### 增量型旋转编码器 1. 增量型旋转编码器外观粗看与一些常见的旋转电位器相似，其关键的不同之处大致分为三点。 1.1 微控制器使用ADC外设来读取旋转电位器输出的模拟信号（电压值），确定转轴当前角位；微控制器通过GPIO接收增量型旋转编码器输出的数字信号，可通过软件程序判断信号所对应的转轴动作。 1.2 微控制器可在一定精度下，确定旋转电位器转轴当前角位，但因为模拟信号的持续性与抗干扰能力差的原因，无法准确判断它是否有动作；增量型旋转编码器仅在转轴运动到一个触点时，向微控制器发出一段动作数字信号，如果一个增量型旋转编码器一周有20个触点，它旋转一周就触发20次动作信号，微控制器可以精确的判断它是否动作，向哪个方向转动，信号触发了多少次。 1.3 旋转电位器通常不可向任意转向进行无限旋转，会停止在最大或最小限位点；增量型旋转编码器可向任意转向进行无限旋转。 2. 增量型旋转编码器采用正交编码器生成其A和B的输出信号。从A和B输出发射的脉冲是正交编码的，这意味着当增量编码器以恒定速度运动时，A和B波形是方波，A和B之间存在90度的相位差。最终A和B信号将从两个管脚传输给微控制器。 ![](../assets/images/rotary_incremental_encoder_pic_2.gif) 3. 理论上，在任何特定时间，对于旋转编码器，A和B信号之间，顺时针旋转的相位差为+90°，逆时针旋转的相位差为−90°，具体则取决于设备内部的正交编码器设计。 4. A或B输出上的脉冲频率与转轴的速度（位置变化率）成正比。较高的频率表示较快的速度，而较低的频率表示较慢的速度。当转轴静止时，静态、不变的信号输出在A和B上，所以有很多测速方案使用增量型旋转编码器。 > 参考 [维基百科: 增量编码器](https://en.wikipedia.org/wiki/Incremental_encoder#Quadrature_decoder) 。"},"/Centi_S3_doc/zh/MicroPython/environment.html":{"title":"","content":"## 安装与配置环境 ### 系统环境需求 支持在 Windows 10、Windows 11，MacOS，Ubuntu 或其他 Linux 桌面操作系统中开发。 本文所有的应用示例基于 Windows 10 操作系统，其他操作系统也可参考使用。 ### 安装Python环境 打开[Python官网](https://www.python.org/) 。 对于Windows 系统来说，最便捷的安装包下载方法就是在官网首页点击如下图所示的图标进行下载。 ![](../assets/images/Micropython_operating_env_1.png) 其他操作系统或是其他发行版本则可以在 Downloads 选项栏中进行选择。 建议使用python 3.7以上的版本。 开始安装时一定要记得勾选Add Python 3.x to PATH，这样可以免除再手动添加进PATH。 ![](../assets/images/Micropython_operating_env_2.png) 按照安装提示逐步操作即可顺利完成安装 。 ### 安装mpremote工具 MicroPython 开源社区现已推出一款开发辅助工具：mpremote ，我们可以通过它与开发板建立串口通信，使用REPL，管理开发板上的文件系统，它还具有 mount 和 mip 功能，将在后续章节详述（准备中）。 安装完Python环境后，即可在终端使用pip安装mpremote了。 在Windows系统中打开PowerShell，其他操作系统则打开对应的终端，输入以下命令安装 mpremote。 ``` pip install mpremote ``` ### 安装mpbridge工具 mpbridge 是基于 mpremote 开发的CLI工具，主要提供自动化同步文件的功能，提高开发效率。 在终端中输入以下命令安装 mpbridge。 ``` pip install mpbridge ``` ### 安装 Visual Studio Code MicroPython的使用并不依赖于特定的开发工具，只要能与开发板建立串口通信，即可获得 MicroPython的交互式解释器（REPL）。 很纯粹的说，我们基本只需要一个文本编辑器来编辑代码，然后通过mpremote工具或mpbridge工具上传我们的 .py 脚本文件或其他文件到开发板中即可。 对于具体的编辑器，综合基本的代码补全、语法高亮、集成终端以及轻量化、多平台适配的需求，我推荐使用 Visual Studio Code (VScode) ，它也可能已经是你最熟悉的工具之一了。 [Visual Studio Code 官网地址](https://code.visualstudio.com/) 可能需要参考的VScode文档： * [VScode 中文简易教程](https://www.runoob.com/w3cnote/vscode tutorial.html?ivk_sa 1025883i) * [Visual Studio Code 官方文档](https://code.visualstudio.com/docs) * [基本安装，设置](https://code.visualstudio.com/docs/setup/setup overview) * [设置显示语言](https://code.visualstudio.com/docs/getstarted/locales) * [使用集成终端](https://code.visualstudio.com/docs/terminal/basics) > 官方文档为英文，中文用户可以使用网页在线翻译功能辅助阅览，[Edge浏览器的在线翻译使用方法](https://support.microsoft.com/zh cn/topic/%E5%9C%A8microsoft edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8microsoft %E7%BF%BB%E8%AF%91%E5%B7%A5%E5%85%B7 4ad1c6cb 01a4 4227 be9d a81e127fcb0b)。 All in Web 人士，极简主义人士，试试[Web端的VScode](https://vscode.dev/)，本地操作系统开个终端使用mpremote或mpbridge同步文件，MicroPython REPL。 ### 其他推荐的编辑器 * [Thonny](https://github.com/thonny/thonny/releases) ，树莓派基金会赞助过的开源图形化python编辑器，Raspberry Pi OS（Raspbian）出厂集成，树莓派用户入门首选。 * [PyCharm 社区版](https://www.jetbrains.com/pycharm/download/#section windows) ，免费的社区版，够用，还带有micropython特殊库的代码补全，虽然不完整且很久没更新了。 * [Jupyter](https://jupyter.org/) 同样是Web端的编辑器，专业性更强，更python，还支持网页终端。"},"/Centi_S3_doc/zh/MicroPython/Display_jpg_images.html":{"title":"","content":"## 显示jpg图片 <iframe src \"//player.bilibili.com/player.html?aid 825151478&bvid BV1Fg4y1M79B&cid 1102157032&page 1&autoplay 0\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> sst7789驱动库内有一个显示jpg格式图片的方法，这对于初次上手学习的我们非常友好。 ### jpg 方法 `jpg(jpg_filename, x, y)` 在给定的 x 和 y 坐标处绘制一个 JPG 文件，坐标为图片的左上角。 此方法需要额外的 3100 字节内存用于其工作缓冲区。 ### 准备合适大小的jpg文件 任选自己喜欢的图片，裁切为长320像素，宽170像素，或小于此尺寸的图片。 图片编辑工具在各种智能终端设备中和各种操作系统中都有大量可选的，可任意使用自己喜欢的工具来编辑。 这里随意推荐一个能免费使用的 Web 在线图片编辑工具，[Pixlr X](https://pixlr.com/cn/x/) 。 将裁切好的图片放入我们本地的MicroPython工作文件夹中，重命名为 `pic_1.jpg` ，上传图片到MicroPython设备中的方法参考 [在终端中使用mpbridge](#在终端中使用mpbridge) 。 这里已准备一张已裁切好尺寸的图片。 ![](../assets/images/pic_1.jpg) ### jpg 方法用例 在 main.py 脚本中使用 jpg 方法。 ```py \"\"\" BPI Centi S3 170x320 ST7789 display \"\"\" import st7789 import tft_config import gc def main(): try: tft tft_config.config(rotation 1) tft.init() tft.jpg(\"pic_1.jpg\", 0, 0) tft.show() gc.collect() except BaseException as err: err_type err.__class__.__name__ print('Err type:', err_type) from sys import print_exception print_exception(err) finally: tft.deinit() print(\"tft deinit\") main() ``` 上传 main.py 后，将设备复位，即可在屏幕上看到图片。 我们再多准备几个合适大小的jpg文件，即可设计一个循环，像播放幻灯片一样在BPI Centi S3的屏幕上轮播图片了。 ![](../assets/images/pic_2.jpg) ![](../assets/images/pic_3.jpg) ![](../assets/images/pic_4.jpg) ![](../assets/images/pic_5.jpg) ```py \"\"\" BPI Centi S3 170x320 ST7789 display \"\"\" import st7789 import tft_config import gc import time pic_list [\"pic_1.jpg\", \"pic_2.jpg\", \"pic_3.jpg\", \"pic_4.jpg\", \"pic_5.jpg\"] def main(): try: tft tft_config.config(rotation 1) tft.init() while True: for pic in pic_list: tft.jpg(pic, 0, 0) tft.show() gc.collect() time.sleep(1) except BaseException as err: err_type err.__class__.__name__ print('Err type:', err_type) from sys import print_exception print_exception(err) finally: tft.deinit() print(\"tft deinit\") main() ```"},"/Centi_S3_doc/zh/Arduino/Environment.html":{"title":"","content":"## 安装与配置环境 这篇文章将会指引您安装Centi S3的Arduino支持。 ![](../assets/images/logo_arduino.png) > 参考[arduino esp32 DOC Getting Started » Installing](https://docs.espressif.com/projects/arduino esp32/en/latest/installing.html) ### 使用Arduino IDE安装支持 这是直接从 Arduino IDE 安装 Arduino ESP32 的方法。 > 从 Arduino IDE 版本 1.6.4 开始，Arduino 允许使用 Boards Manager（开发板管理器）安装第三方平台包。有适用于 Windows、macOS 和 Linux 的软件包。 Arduino IDE 下载地址：https://www.arduino.cc/en/software > Arduino IDE 2.0与Arduino IDE 1.8.x的UI有些许差异，本文基于1.8.13版本编写，但不影响使用2.0版本的用户参考。 要使用 Boards Managaer（开发板管理器）安装esp32平台包，请执行以下步骤： 安装当前上游 Arduino IDE 1.8 或更高版本。 启动 Arduino 并打开 File（文件）> Preferences（首选项）窗口，找到Additional Board Manager URLs（附加开发板管理器网址）。 ![](../assets/images/install_guide_preferences.png) 稳定版链接： ``` https://espressif.github.io/arduino esp32/package_esp32_index.json ``` 开发版链接： ``` https://espressif.github.io/arduino esp32/package_esp32_dev_index.json ``` 在Additional Board Manager URLs后面输入上述发布链接之一。您可以添加多个 URL，一行一个。 ![](../assets/images/install_guide_boards_manager_url.png) 从菜单打开 Tools（工具） > Board（开发板）> Board Manager（开发板管理器） 搜索并安装esp32平台。 ![](../assets/images/install_guide_boards_manager_esp32.png) 重启arduino IDE之后可以看到在开发板选项中多了ESP32 Arduino选项。 选择 `ESP32S3 Dev Module` 这个型号，再参照下图所示的内容进行配置一遍即可，配置不当可能是无法使用的，请一定要参照下图所示的内容进行配置！ Setting Value : : USB CDC On Boot Enabled CPU Frequency 240MHz (WiFi) Core Debug Level None USB DFU On Boot Enabled (Requires USB OTG Mode) Erase All Flash Before Sketch Upload Disabled Events Run On Core 1 Flash Mode QIO 80MHz Flash Size 8MB (64Mb) JTAG Adapter Integrated USB JTAG Arduino Runs On Core 1 USB Firmware MSC On Boot Disabled Partition Scheme 8M with spiffs (3MB APP/1.5MB SPIFFS) PSRAM QSPI PSRAM Upload Mode UARTO / Hardware CDC Upload Speed 921600 USB Mode Hardware CDC and JTAG 或直接选择 `BPI Leaf S3` 这个型号，默认设置即可直接使用。 ### 从GitHub下载或克隆arduino esp32仓库，手动安装 > 仅限Windows系统。 打开GitHub页面：https://github.com/espressif/arduino esp32 点击`Code`按钮,点击`Download ZIP`即可用最简单的方式将仓库下载到本地，建议初学者使用此方法。 ![](../assets/images/arduino esp32_download_zip.png) 也可通过GitHub Desktop或Git克隆master分支到本地。 [安装和配置GitHub Desktop](https://docs.github.com/cn/desktop/installing and configuring github desktop) [git 中文手册](https://git scm.com/book/zh/v2) 解压zip文件到Arduino IDE安装路径的`/hardware/espressif/`路径中，将解压出的文件夹重命名为`esp32`。 ![](../assets/images/arduino esp32_unzip.png) 打开 `/hardware/espressif/esp32/tools`路径， 并双击运行` get.exe` 。 ![](../assets/images/win gui 4.png) `get.exe` 完成后，您应该会在目录中看到以下文件。 ![](../assets/images/win gui 5.png) 重启arduino IDE之后可以看到在开发板选项中多了ESP32 Arduino选项。 ![](../assets/images/arduino esp32_leaf_s3.png)"},"/Centi_S3_doc/zh/Arduino/Arduino_GFX_show_characters.html":{"title":"","content":"## Arduino GFX, 显示字符 此为 Arduino GFX 库最基础的例程，在屏幕上显示`Hello World!`字符，并进行随机颜色，坐标，大小的显示。 [GitHub 源码](https://github.com/BPI STEAM/BPI Centi S3 Doc/blob/main/arduino_example/01_show_characters_helloworld/HelloWorld.ino) .. details:: 源码，点击展开 :open: true ```c #include <Arduino_GFX_Library.h> Arduino_DataBus *bus new Arduino_ESP32LCD8(5 /* DC */, 4 /* CS */, 6 /* WR */, 7 /* RD */, 8 /* D0 */, 9 /* D1 */, 10 /* D2 */, 11 /* D3 */, 12 /* D4 */, 13 /* D5 */, 14 /* D6 */, 15 /* D7 */); Arduino_GFX *gfx new Arduino_ST7789(bus, 3 /* RST */, 1 /* rotation */, true /* IPS */, 170 /* width */, 320 /* height */, 35 /* col offset 1 */, 0 /* row offset 1 */, 35 /* col offset 2 */, 0 /* row offset 2 */); #define GFX_BL 2 // default backlight pin, you may replace DF_GFX_BL to actual backlight pin void setup(void) { gfx >begin(); gfx >fillScreen(BLACK); #ifdef GFX_BL pinMode(GFX_BL, OUTPUT); digitalWrite(GFX_BL, HIGH); #endif gfx >setCursor(10, 10); gfx >setTextColor(RED); gfx >setTextSize(2 /* x scale */, 2 /* y scale */, 2 /* pixel_margin */); gfx >println(\"Hello World!\"); delay(5000); // 5 seconds } void loop() { gfx >setCursor(random(gfx >width()), random(gfx >height())); gfx >setTextColor(random(0xffff), random(0xffff)); gfx >setTextSize(random(6) /* x scale */, random(6) /* y scale */, random(2) /* pixel_margin */); gfx >println(\"Hello World!\"); delay(1000); // 1 second } ```"},"/Centi_S3_doc/zh/Arduino/Arduino_GFX_Install.html":{"title":"","content":"## 安装Arduino GFX库 在arduino IDE 中选择 Tools > Manager Libraries, 在搜索框中输入 `GFX Library for Arduino`，找到完全同名的项目，点击安装。 ![](../assets/images/arduino_GFX_Install.png)"},"/Centi_S3_doc/zh/Arduino/Arduino_upload.html":{"title":"","content":"## 连接，上传 在上传之前，应确保已在 Tools > Port 中选择开发板对应的端口。 如果是第一次上传Arduino程序，需先将开发板置于固件下载模式。 点击 Upload 即可将代码编译并上传到开发板中。 ### 设置固件下载模式 有两种操作方法： 1.通过USB连接到电脑，按住BOOT键，再按一下RESET键并松开，最后松开BOOT键。 2.在断开供电的条件下按住BOOT键，再通过USB连接到电脑，最后松开BOOT键。 由此可知，芯片是通过BOOT键所控制的GPIO0来选择复位或重新上电时的启动模式。 在设备管理器中确认COM接口，固件下载模式与普通模式下的com接口序号通常是不一样的。 在 Tools > Port 中选择新出现的端口。"},"/Centi_S3_doc/zh/index.html":{"title":"","content":"## 介绍 ![](assets/images/BPI Centi S3.jpg) BPI Centi S3 是一个板载1.9英寸彩屏的小尺寸ESP32 S3开发板，适合用于彩色显示，交互控制，无线通信，传感器数据采集等物联网综合应用项目的开发。 使用Espressif ESP32 S3芯片，支持 2.4 GHz Wi Fi 和低功耗蓝牙 (Bluetooth® LE) 双模无线通信。 在紧凑的空间下依旧提供一个增量型旋转编码器，一个蜂鸣器，一个WS2812彩灯，及其他所有可用引脚引出，满足多样化的需求。 支持USB和外接3.7V锂电池两种供电方式，可实现双电源下自动切换电源功能，并支持USB充电方式，配置了电池电压检测电路，方便进行电量管理。 ### 关键特性 * ESP32 S3，Xtensa® 32 bit LX7 * 2M PSRAM , 8M FLASH * 2.4G WIFI ，Bluetooth 5 ，Bluetooth mesh * GPIO , PWM , I2C , SPI , RMT , I2S , UART ，USB , JTAG * 1 * ST7789 屏幕，1.9英寸，170*320分辨率，8bit 8080并口 * 1 * 旋转编码器 * 1 * 蜂鸣器 * 1 * 全彩色LED * 1 * SH 1mm 4 Pin I2C连接座 * 2 * SH 1mm 6 Pin * 1 * USB Type C * 1 * MX 1.25mm 2 Pin 电池连接座，支持充电 * 2 * M3螺丝孔 ## 硬件 ### 硬件接口示意图 ![](assets/images/BPI Centi S3_drawio.png) ### 硬件规格 : :: : SoC 主控芯片 ESP32 S3，Xtensa® 32 位 LX7 双核处理器 主频 240MHz MAX 片上 ROM 384 KB 片上 SRAM 320 KB 板载 FLASH ROM 8MB 片上外设PSRAM 2MB WIFI IEEE 802.11 b/g/n ，2.4Ghz频带，150Mbps 蓝牙 Bluetooth 5 ，Bluetooth mesh 外部晶振 40Mhz RTC 和低功耗管理 电源管理单元 (PMU)+ 超低功耗协处理器 (ULP) GPIO 已引出9个可用GPIO到SH 插座 支持外设 I2C, SPI, PWM, UART, RMT, I2S, SD SH 1mm 插座 1 * 4Pin，2 * 6Pin USB 1 * 全速USB 2.0 OTG，Type C母口 USB Serial/JTAG 控制器 1，USB 全速标准，CDC ACM ，JTAG 屏幕尺寸 1.9 英寸 屏幕分辨率 170 * 320 RGB 屏幕控制芯片 ST7789V3 屏幕接口 8bit 8080 并口 编码器 1 * 增量型旋转编码器，支持按压功能 蜂鸣器 1 彩色LED 1 * WS2812 2020 按钮 RST 按钮，BOOT按钮 整机工作温度 20℃ ~ +60℃ 工作电压 3.3V USB输入电压 3.3V~5.5V 最大放电电流 2A@3.3V DC/DC 电池连接座 MX 1.25mm 2 Pin USB充电 支持 最大充电电流 500mA ### 硬件尺寸 ![](assets/images/BPI Centi S3 V0.2_Dimensions.jpg) ### 屏幕接线定义 : :: : ESP_LCD_BLK GPIO2 ESP_LCD_RES GPIO3 ESP_LCD_CS GPIO4 ESP_LCD_D/C GPIO5 ESP_LCD_WR GPIO6 ESP_LCD_RD GPIO7 ESP_LCD_D0 GPIO8 ESP_LCD_D1 GPIO9 ESP_LCD_D2 GPIO10 ESP_LCD_D3 GPIO11 ESP_LCD_D4 GPIO12 ESP_LCD_D5 GPIO13 ESP_LCD_D6 GPIO14 ESP_LCD_D7 GPIO15 ESP_TP_RESET GPIO16 II2C_SCL GPIO17 II2C_SDA GPIO18 ESP_TP_INT GPIO21 ### 外设接线定义 : :: : RST按键 RST(CHIP_PU) BOOT按键 GPIO0 BAT_ADC 电池电压检测 GPIO1 蜂鸣器 GPIO36 EC_KEY 旋转编码器 GPIO35 EC_A 旋转编码器 GPIO37 EC_B 旋转编码器 GPIO47 WS2812B 2020 GPIO48 "},"/Centi_S3_doc/zh/getting-started.html":{"title":"","content":"## 快速上手指南 我们整理了这份入门指南，帮助你快速上手这块BPI Centi S3开发板。 ### 第一件事 使用一根具有供电与数据功能的USB C线连接BPI Centi S3开发板与你的计算机。 初次上手，通电后它的屏幕会立即显示欢迎画面，蜂鸣器会鸣叫两声。 BPI Centi S3 出厂时已经烧录了MicroPython 1.19.1 固件，并集成了ST7789 C模块 驱动，推荐初学者使用MicroPython开发学习。 ### 使用 MicroPython 快速上手 1. 查看[安装与配置环境](./MicroPython/environment.html), 安装Python 3，mpremote工具，mpbridge工具，VScode IDE. 2. 查看[VScode + mpbridge工具使用方法](./MicroPython/VScode_mpbridge.html)，了解如何连接开发板，复制，修改，删除开发板上的文件。 3. 查看[REPL使用技巧](./MicroPython/REPL_use_case.html)，快速了解MicroPython REPL常用快捷键和查看模块的方法。 经过以上三步即可上手开发。 对于 Python 和 MicroPython 的学习，我们建议在[Python 教程](https://docs.python.org/zh cn/3.10/tutorial/index.html)中上手学习Python，在[MicroPython 文档](https://docs.micropython.org/en/latest/index.html)中应用 Python 所学，你可以快速参考 MicroPython 的特殊库，ESP32 端口特殊库来进行开发，在[MicroPython与CPython的区别](https://docs.micropython.org/en/latest/genrst/index.html#)页面了解二者的部分差异。 在本网页左侧边栏可以看到一些可能对你有帮助的MicroPython例程。 ST7789 C模块 驱动，来自于： [russhughes/st7789s3_esp_lcd](https://github.com/russhughes/st7789s3_esp_lcd) , The MIT License 在此GitHub 仓库中可以查阅st7789模块的所有方法，以及编译的方法，感谢 russhughes 的开源贡献。 如果你在开发产生意外的恶性BUG使开发板无法正常启动，或其他原因导致固件被擦除或损坏，查看[烧录固件](./MicroPython/Burn_firmware.html)。"},"/Centi_S3_doc/zh/no_translate.html":{"title":"no_translate_title","content":" title: no_translate_title class: md_page <div id \"visit_from\"></div> <div id \"no_translate_hint\">no_translate_hint</div> <div> <span id \"visit_hint\">visit_hint</span> <a id \"translate_src\"></a> </div> <div> <script> function getQueryVariable(variable) { var query window.location.search.substring(1); var vars query.split(\"&\"); for (var i 0;i<vars.length;i++) { var pair vars[i].split(\" \"); if(pair[0] variable){return pair[1];} } return(false); } var ref getQueryVariable(\"ref\"); var from getQueryVariable(\"from\"); var link document.getElementById(\"translate_src\"); var fromDis document.getElementById(\"visit_from\"); link.href ref; link.text ref; fromDis.innerHTML from; </script> </div>"}}