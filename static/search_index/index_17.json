{"/Leaf_S3_doc/zh_tw/MicroPython/Firmware.html":{"title":"Micropython 固件下載與燒錄","content":"# Micropython 固件下載與燒錄 在[MicroPython官網](https://micropython.org/)可以找到支持ESP32S3芯片的固件 https://micropython.org/download/ESP32_GENERIC_S3/ 點擊連接進入頁面後即可在下方看到幾個固件的下載地址，選擇一個.bin 後綴的文件下載到本地即可。 ![](../assets/images/Micropython_operating_env_6.png) 注意固件名中標註的日期，離當前時間越近的功能越新。 可以用兩種工具來燒錄固件，樂鑫科技官方的FLASH下載工具或esptool ，二選其一即可。 ## 設置固件下載模式 有兩種操作方法： 1.通過USB連接到電腦，按住BOOT鍵，再按一下RESET鍵並鬆開，最後鬆開BOOT鍵。 2.在斷開供電的條件下按住BOOT鍵，再通過USB連接到電腦，最後鬆開BOOT鍵。 由此可知，芯片是通過BOOT鍵所控制的GPIO0來選擇復位或重新上電時的啟動模式。 在設備管理器中確認COM接口，固件下載模式與普通模式下的com接口序號通常是不一樣的。 ![](../assets/images/Micropython_operating_env_5.png) ## Windows FLASH下載工具 下載並解壓：[FLASH下載工具下載地址](https://www.espressif.com/zh hans/support/download/other tools) 打開軟件並選擇芯片型號為ESP32S3,將下載模式設置為usb： ![](../assets/images/Micropython_operating_env_7.png) 此時需要設置開發板為固件下載模式。 在芯片處於固件下載模式的條件下，在FLASH下載工具窗口中修改COM接口為對應的接口，此處為COM22。 添加MicroPython固件，對於ESP32 S3芯片要設置flash起始地址為 `0x0000` 。 ![](../assets/images/Micropython_operating_env_8.png) 先點擊ERASE按鈕清除flash上的數據，再點擊START燒寫固件到flash中。 燒錄完成後按一次RESET鍵，使開發板進入普通使用模式。 ## esptool 以Windows PowerShell的具體操作步驟為例。 使用以下命令安裝esptool： ```shell pip install esptool ``` 如果未來有需要，則可以使用以下命令升級esptool： ```shell pip install U esptool ``` 通過命令或其他方法在PowerShell中進入固件所在的目錄。 可以在Windows文件夾窗口中以按住shift鍵再單擊右鍵的方式在此文件夾中打開PowerShell窗口。 此時需要設置開發板為固件下載模式，詳見上文。 通過以下命令清除flash，需要修改COM接口為對應的接口，此處為COM1。 ```shell python m esptool chip esp32s3 port COM22 erase_flash ``` 通過以下命令燒錄固件，需要修改固件文件名為當前對應需要燒錄的文件名。 ```shell python m esptool chip esp32s3 port com22 baud 460800 before default_reset after hard_reset write_flash z 0x0 firmware_name.bin ``` 如果是通過USB燒錄，完成後按一次RESET鍵復位，使開發板進入普通使用模式。 如果是通過UART燒錄，則會在完成後自動復位。"},"/Leaf_S3_doc/zh_tw/MicroPython/Basic.html":{"title":"基礎功能使用","content":"# 基礎功能使用 >[GitHub BPI Leaf S3 例程](https://github.com/BPI STEAM/BPI Leaf S3 Doc/tree/main/Example/MicroPython zh/02.Use_Peripherals) ## 點亮板載LED燈珠 在完成[MicroPython 運行環境設置](Environment.html)後，可以立即嘗試編程。 新建一個 main.py 腳本文件，在其中輸入以下代碼： ```py from machine import Pin from neopixel import NeoPixel import time pin_48 Pin(48) np NeoPixel(pin_48, 1,bpp 3, timing 1) while True: np[0] (25,25,25) np.write() time.sleep_ms(250) np[0] (0,0,0) np.write() time.sleep_ms(250) ``` 保存文件到MicroPython設備中，點擊“Run”運行按鈕，即可讓板載彩色LED燈珠閃爍。 修改 `np[0] (25,25,25)`等號右側元組內的數據，可以改變顏色，分別對應R，G，B三色亮度等級，設定範圍是0 255，建議使用範圍0 25，亮度過高時請勿長時間直視！ [neopixel — control of WS2812 / NeoPixel LEDs — MicroPython 文檔](https://docs.micropython.org/en/latest/library/neopixel.html) ## 使彩燈循環顯示九種顏色 ```py from machine import Pin from neopixel import NeoPixel import time pin_48 Pin(48, Pin.OUT) np NeoPixel(pin_48, 1,bpp 3, timing 1) RED (255, 0, 0) ORANGE (255, 100, 0) YELLOW (255, 255, 0) GREEN (0, 255, 0) CYAN (0, 255, 255) BLUE (0, 0, 255) PURPLE (180, 0, 255) WHITE (255, 255, 255) OFF (0, 0, 0) color_list [RED,ORANGE,YELLOW,GREEN,CYAN,BLUE,PURPLE,WHITE,OFF] brightness 0.1 while True: for i in color_list: color (round(i[0]*brightness),round(i[1]*brightness),round(i[2]*brightness)) np[0] color np.write() time.sleep(1) ``` ## 全彩LED燈珠循環顯示彩虹色 基於上一節，我們可以更進一步，編寫循環自動改變燈珠顏色。 ```py from machine import Pin from neopixel import NeoPixel import time def rainbow(num 1,level 25,delay 100): def write_all(num,delay,red,green,blue): for j in range (num): np[j] (red,green,blue) np.write() time.sleep_ms(delay) red,green,blue level,0,0 rainbow_step_list2 [(0,1,0),( 1,0,0),(0,0,1),(0, 1,0),(1,0,0),(0,0, 1)] for step in rainbow_step_list2: for i in range (level): red+ step[0] green+ step[1] blue+ step[2] write_all(num,delay,red,green,blue) np NeoPixel(Pin(48, Pin.OUT), 1,bpp 3, timing 1) while True: rainbow(num 1,level 25,delay 10) ``` 此例程可適用於任意長度的ws2812燈帶。 修改 `NeoPixel(Pin(48, Pin.OUT), 1,bpp 3, timing 1)` 中第一個參數至任意想要串接燈帶的GPIO管腳。 修改 `rainbow(num 1,level 25,delay 100)` 中的num參數為燈帶上對應燈珠的數量。 當然我們也可以根據自己的想法使用for循環或while循環製作自己想要的顏色變化規律。 ## 設計按鍵中斷程序,控制彩燈 BPI Leaf S3 有兩顆按鍵，BOOT 與 RST，RST控制芯片硬件復位，而BOOT則與GPIO0相連，其電路如下圖所示。 ![](../assets/images/bpi leaf s3_boot_sch.png) 可見當開發板正常通電工作時，GPIO0在BOOT按鍵未按下時，串聯一顆電阻接到3.3v，此時為高電位；當BOOT按鍵按下時，GPIO0將直接接地，此時則為低電位。 ESP32 S3芯片通過檢測此GPIO管腳的電位即可判斷按鈕是否被按下。 [MicroPython GPIO中斷程序 machine.Pin.irq 文檔](https://docs.micropython.org/en/latest/library/machine.Pin.html#machine.Pin.irq) 在程序中，通過檢測 GPIO中斷的觸發方式，即可設計一套記錄按鍵被按壓的次數的中斷程序，用判斷當前已經按壓的次數來控制彩燈的顏色。 <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/PQ2x4PayFPc?controls 0\" title \"YouTube video player\" frameborder \"0\" allow \"accelerometer; autoplay; clipboard write; encrypted media; gyroscope; picture in picture; web share\" allowfullscreen></iframe> ```python from machine import Pin from neopixel import NeoPixel from array import array import time import micropython micropython.alloc_emergency_exception_buf(100) p_48 Pin(48, Pin.OUT) np NeoPixel(p_48, 1,bpp 3, timing 1) p0 Pin(0,Pin.IN,Pin.PULL_UP) trig_locks array('B',[0]) trig_timeticks_list array('L',[0,0]) count array('L',[0]) def p0_irq(pin): if pin.value() 0 and trig_locks[0] 0: trig_timeticks_list[0] time.ticks_ms() trig_locks[0] 1 elif pin.value() 1 and trig_locks[0] 1: trig_timeticks_list[1] time.ticks_diff(time.ticks_ms(),trig_timeticks_list[0]) trig_locks[0] 0 if trig_timeticks_list[1] > 20: count[0] count[0] + 1 if count[0] > 8: count[0] 0 p0.irq(handler p0_irq,trigger Pin.IRQ_FALLING Pin.IRQ_RISING ) RED (255, 0, 0) ORANGE (255, 100, 0) YELLOW (255, 255, 0) GREEN (0, 255, 0) CYAN (0, 255, 255) BLUE (0, 0, 255) PURPLE (180, 0, 255) WHITE (255, 255, 255) OFF (0, 0, 0) color_list [RED,ORANGE,YELLOW,GREEN,CYAN,BLUE,PURPLE,WHITE,OFF] brightness 0.1 while True: print (count) i color_list[count[0]] color (round(i[0]*brightness),round(i[1]*brightness),round(i[2]*brightness)) np[0] color np.write() time.sleep(0.1) ``` ## PWM 單色LED呼吸燈 ### 外部硬件需求 一個可以在3.3v電壓下工作的LED燈。 ### 連接方法 例程中使用的是GPIO13管腳，將LED燈正極與GPIO13管腳連接，負極與GND連接。 ### Code ```py from machine import Pin, PWM import time PWM_LED PWM(Pin(13)) PWM_LED.freq(1000) PWM_LED.duty(0) while True: for i in range(0,1024,1): PWM_LED.duty(i) time.sleep_ms(2) for i in range(1022,0, 1): PWM_LED.duty(i) time.sleep_ms(1) ``` ## TB6612FNG模塊 PWM驅動電機 ### 外部硬件需求 一個TB6612FNG模塊，一個3.3~5V直流電機。 ### 連接方法 TB6612FNG BPI Leaf S3 : :: : PWMA 11 AIN2 13 AIN1 12 STBY 10 VM 5V VCC 3.3V GND GND AO1 電機N極 AO2 電機S極 > AO1/AO2 與電機的連接可任意調換接線順序，以此改變旋轉方向。 ### 運行效果 電機將啟動朝一個方向旋轉並在7秒逐漸加速到當前電流可達到的最大轉速，然後在5秒內逐漸減速至停轉，隨後反向旋轉並重複這個過程。 <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/3WXCZ1BsPNY?controls 0\" title \"YouTube video player\" frameborder \"0\" allow \"accelerometer; autoplay; clipboard write; encrypted media; gyroscope; picture in picture; web share\" allowfullscreen></iframe> ### Code ```py from machine import Pin,PWM import time PWM_A PWM(Pin(11)) #Set PWM output pin PWM_A.freq(20000) #Set PWM frequency PWM_A.duty(0) #Set PWM duty cycle AIN1 Pin(12,Pin.OUT) AIN2 Pin(13,Pin.OUT) STBY Pin(10,Pin.OUT) STBY.on() #When STBY pin is at high level, TB6612FNG starts. def MOTOR_Forward(): AIN1.on() AIN2.off() def MOTOR_Reverse(): AIN1.off() AIN2.on() while True: MOTOR_Forward() #for cycle is used to control the PWM duty cycle change. #The PWM duty cycle control precision is 10bit, ie 0~1023. #Some motors require a certain PWM duty cycle to start. for i in range(350,1024,1): PWM_A.duty(i) time.sleep_ms(10) for i in range(1022,0, 1): PWM_A.duty(i) time.sleep_ms(5) MOTOR_Reverse() for i in range(350,1024,1): PWM_A.duty(i) time.sleep_ms(10) for i in range(1022,0, 1): PWM_A.duty(i) time.sleep_ms(5) ``` ## 使用ADC檢測電位器電壓 ### 外部硬件需求 一個電位器。 ![](https://i.imgur.com/mnuHlMR.jpg) ### ESP32 S3的ADC ESP32 S3芯片內部集成了兩個**ADC模數轉換器** ，測量範圍 0mV 3100mV，分辨率為12bit，即將0mV 3100mV分為2^12 4096級，每一級為一個數字量。 兩個ADC模數轉換器各有10個測量通道，ADC1為GPIO1 ~ 10,ADC2為GPIO11 ~ 20 。 ### 連接方法 GND接GND，VCC接3V3，S輸出端接GPIO11管腳，使用的是ADC2的通道1進行測量。 GPIO1~20管腳都可做ADC輸入管腳。 ### Code ```py from machine import Pin,ADC import time adc11 ADC(Pin(11),atten ADC.ATTN_11DB) #adc11 ADC(Pin(11)） #adc11.atten(ADC.ATTN_11DB) while True: read adc11.read() read_u16 adc11.read_u16() read_uv adc11.read_uv() print(\"read {0},read_u16 {1},read_uv {2}\".format(read,read_u16,read_uv)) time.sleep_ms(100) ``` 衰減值 可測量的輸入電壓範圍 ADC.ATTN_0DB 0 mV ~ 950 mV ADC.ATTN_2_5DB 0 mV ~ 1250 mV ADC.ATTN_6DB 0 mV ~ 1750 mV ADC.ATTN_11DB 0 mV ~ 3100 mV 1. `ADC(*，atten)`初始化一個GPIO管腳的ADC通道，可以選擇使用`atten`設定衰減值，它控制芯片可測量的輸入電壓範圍，如果不設置，將為默認值`atten ADC.ATTN_0DB`或上一次所設定的值。 2. 可以在初始化一個ADC通道後通過`ADC.atten()`修改衰減值。 3. `ADC.read()`讀取ADC並返回讀取結果，ESP32 S3芯片的ADC所返回的是12位精度的數據。 4. `ADC.read_u16()`讀取ADC並將返回16位的數據。 5. `ADC.read_uv()`根據ADC的特性以`uV`微伏為單位返回校準的輸入電壓。返回值只有`mV`毫伏分辨率（即，將始終是1000微伏的倍數）。 WiFi功能也使用了ADC2，因此在WiFi處於活動狀態時嘗試從ADC2的測量通道GPIO11 ~ 20讀取模擬值將引發異常。 建議使用`ADC.read_uv()`來讀取電壓值，它是根據ADC模數轉換器的特性經過校准後返回的十進制常數，較比另外兩個讀取方法更加準確，同時也建議使用時直接經過整除運算：`ADC.read_uv()//1000` 獲取`mV`毫伏分辨率的數據。 直接打印輸出`ADC.read()`或`ADC.read_u16()`得到的是十進制數值，可用`hex()`函數將數據類型轉化為十六進制，例如`hex(ADC.read())`，或用`bin()`函數將數據類型轉化為二進制。 ## 用電位器無極調控彩燈亮度 在 [使彩燈循環顯示九種顏色](#使彩燈循環顯示九種顏色) 小節的基礎上，可使用電位器來控制彩燈的亮度。 <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/d3tm8aYNCx8?controls 0\" title \"YouTube video player\" frameborder \"0\" allow \"accelerometer; autoplay; clipboard write; encrypted media; gyroscope; picture in picture; web share\" allowfullscreen></iframe> ### Code ```py from machine import Pin,ADC from neopixel import NeoPixel from array import array import time import micropython adc1 ADC(Pin(1),atten ADC.ATTN_11DB) micropython.alloc_emergency_exception_buf(100) p_48 Pin(48, Pin.OUT) np NeoPixel(p_48, 1,bpp 3, timing 1) p0 Pin(0,Pin.IN,Pin.PULL_UP) trig_locks array('B',[0]) trig_timeticks_list array('L',[0,0]) count array('L',[0]) def p0_irq(pin): if pin.value() 0 and trig_locks[0] 0: trig_timeticks_list[0] time.ticks_ms() trig_locks[0] 1 elif pin.value() 1 and trig_locks[0] 1: trig_timeticks_list[1] time.ticks_diff(time.ticks_ms(),trig_timeticks_list[0]) trig_locks[0] 0 if trig_timeticks_list[1] > 20: count[0] count[0] + 1 if count[0] > 8: count[0] 0 p0.irq(handler p0_irq,trigger Pin.IRQ_FALLING Pin.IRQ_RISING ) RED (255, 0, 0) ORANGE (255, 100, 0) YELLOW (255, 255, 0) GREEN (0, 255, 0) CYAN (0, 255, 255) BLUE (0, 0, 255) PURPLE (180, 0, 255) WHITE (255, 255, 255) OFF (0, 0, 0) color_list [RED,ORANGE,YELLOW,GREEN,CYAN,BLUE,PURPLE,WHITE,OFF] while True: adc1_read adc1.read() # 12bit adc1_read_mv adc1.read_uv()/1000 adc1_read_u16 adc1.read_u16() # 16bit brightness adc1_read/4095 i color_list[count[0]] color (round(i[0]*brightness),round(i[1]*brightness),round(i[2]*brightness)) np[0] color np.write() print(adc1_read,adc1_read_u16,adc1_read_mv,\"mv\",count[0],color) time.sleep(0.1) ``` ## 使用ADC測量電位器，用以調整電機轉速 ### 外部硬件需求 * 電位器 x 1 * TB6612FNG電機驅動模塊 x 1 * 5v直流電機 x 1 * 一些連接線材 ### 連接方法 PotentiometerBPI Leaf S3 GNDGND VCC3V3 S14 TB6612FNGBPI Leaf S3 PWMA11 AIN213 AIN112 STBY10 VM5V VCC3.3V GNDGND TB6612FNGMotor AO1Motor N pole AO2Motor S pole ### 運行效果 開發板將間隔100ms在REPL輸出ADC讀取到的電壓值，單位為mv，以及對應控制的PWM佔空比。 用手調整電位器，改變其輸出電壓，電壓越大，開發板輸出的PWM佔空比越高，電機轉速越快。 <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/2_UeeeOBJwo?controls 0\" title \"YouTube video player\" frameborder \"0\" allow \"accelerometer; autoplay; clipboard write; encrypted media; gyroscope; picture in picture; web share\" allowfullscreen></iframe> ### Code ```py from machine import Pin,ADC,PWM import time adc14 ADC(Pin(14),atten ADC.ATTN_11DB) PWM_A PWM(Pin(11)) #Set PWM output pin PWM_A.freq(20000) #Set PWM frequency PWM_A.duty(0) #Set PWM duty cycle AIN1 Pin(12,Pin.OUT) AIN2 Pin(13,Pin.OUT) STBY Pin(10,Pin.OUT) AIN1.on() #MOTOR forward AIN2.off() STBY.on() #When STBY pin is at high level, TB6612FNG starts. while True: read_mv adc14.read_uv()//1000 if read_mv < 3000: duty_set int(1023/3000 * read_mv) else: duty_set 1023 PWM_A.duty(duty_set) Duty_cycle int(duty_set/1023*100) print(\"ADC_read {0}mv,Duty_cycle {1}%\".format(read_mv,Duty_cycle)) time.sleep_ms(100) ``` ## UART 串口數據讀寫 ### 外部硬件需求 USB轉UART模塊（CH340，CP2102等）。 ### 軟件需求 一個串口調試軟件例如[PuTTY](https://putty.org/)，以及USB轉UART模塊所需驅動。 ### 接線參考 將BPI Leaf S3開發板通過USB連接電腦，USB轉UART模塊的RX接GPIO17（BPI Leaf S3的TX），TX接GPIO18（BPI Leaf S3的RX），GND接GND（共地），USB轉UART模塊的USB接口連接電腦，可以是連接BPI Leaf S3的同一台電腦，也可以是不同的兩台電腦。 ### 運行效果 在BPI Leaf S3所在電腦的MicroPython REPL中將間隔一秒輸出一次從USB轉UART模塊中接收到的數據。 而在USB轉UART模塊所在的電腦的串口調試軟件窗口中則可以看到，每間隔一秒輸出一行由BPI Leaf S3發送的字符 `Hello World!` 。 ### Code ``` from machine import UART import time uart1 UART(1, tx 17, rx 18) # Select the UART interface and specify the pins used by TX and RX uart1.init(115200, bits 8, parity None, stop 1) # Initialization, set the baud rate, set the number of characters, set the parity, set the stop bit def test(): for i in range(50): uart1.write('Hello World!') # write data time.sleep(0.5) print(uart1.read()) # read data time.sleep(0.5) test() ``` ## I²C，SSD1306 OLED 顯示 SSD1306 OLED屏幕模塊是一個很常見的可以使用I2C通信協議的屏幕模塊，最大輸出128*64 bit的圖像，無灰階，單顆像素僅有亮滅兩個狀態，控制邏輯相對簡單，很適合入門學習單片機驅動屏幕顯示的項目。 ### 外部硬件需求 一塊具備I²C接口的SSD1306 OLED屏幕模塊，最好為128*64像素的。 ### 驅動庫下載 [micropython/ssd1306.py 驅動](https://github.com/micropython/micropython lib/blob/master/micropython/drivers/display/ssd1306/ssd1306.py) 將 ssd1306.py 下載到本地後，再上傳到MicroPython設備中。 ### 接線參考 SSD1306 OLEDBoard GNDGND VCC3V3 SCL16 SDA15 ### 掃描I²C地址 ```py from machine import I2C,Pin sda_pin Pin(15,Pin.PULL_UP) scl_pin Pin(16,Pin.PULL_UP) i2c I2C(1,sda sda_pin, scl scl_pin, freq 400_000) i2c_list i2c.scan() i2c_total len(i2c_list) print(\"Total num:\",i2c_total) j 0 for i in i2c_list: j j+1 print(\"NO.{0},address:{1}\".format(j,hex(i))) ``` 通常SSD1306的地址為0x3c。 ### 顯示字符 [MicroPython framebuf 文檔](https://docs.micropython.org/en/latest/library/framebuf.html#module framebuf) ```py from machine import I2C, Pin from ssd1306 import SSD1306_I2C sda_pin Pin(15, Pin.PULL_UP) scl_pin Pin(16, Pin.PULL_UP) i2c I2C(1, sda sda_pin, scl scl_pin, freq 800_000) print(i2c.scan()) oled SSD1306_I2C(128, 64, i2c, addr 0x3c) def display(): # The framebuf library only supports ASCII printing characters encoded as 32~126 oled.text(\" !\\\"#$%&'()*+, ./\", 0, 0) oled.text(\"0123456789:;< >?\", 0, 8) oled.text(\"@ABCDEFGHIJKLMNO\", 0, 16) oled.text(\"PQRSTUVWXYZ[\\]^_\", 0, 24) oled.text(\"`abcdefghijklmno\", 0, 32) oled.text(\"pqrstuvwxyz{}~\", 0, 40) oled.show() def testAscii(): # The return value of chr() is the ASCII character corresponding to the current integer Ascii '' for i in range(32, 127): Ascii Ascii + chr(i) for i in range(128, 256): Ascii Ascii + chr(i) return Ascii def display_Ascii(): # The framebuf library only supports ASCII printing characters encoded as 32~126 oled.text(testAscii()[0:16], 0, 0) oled.text(testAscii()[16:32], 0, 8) oled.text(testAscii()[32:48], 0, 16) oled.text(testAscii()[48:64], 0, 24) oled.text(testAscii()[64:80], 0, 32) oled.text(testAscii()[80:95], 0, 40) oled.show() if __name__ \"__main__\": display() # print(testAscii()) # display_Ascii() # ASCII printing characters (character encoding: 32 127) # 32~126 (95 in total) are characters: 32 is a space, among which 48~57 are ten Arabic numerals from 0 to 9, # 65～90 are 26 uppercase English letters, # 97~122 are 26 lowercase English letters, # The rest are some punctuation marks, operation symbols, etc. # The 127th character represents the delete command on the keyboard. # ASCII extension code (character encoding: 128 255) # The last 128 are called extended ASCII codes. # Many x86 based systems support the use of extended (or \"high\") ASCII. # The extended ASCII code allows the 8th bit of each character # to be used to determine additional 128 special symbol characters, foreign language letters and graphic symbols. ``` ## OLED顯示電位器電壓與實時進度條 繼續使用[用電位器無極調控彩燈亮度](#用電位器無極調控彩燈亮度) 章節中中用ADC檢測電位器電壓的方法，可以設計一個讓OLED屏幕顯示電位器電壓與實時進度條的程序。 <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/I4F8jw2MK1k?controls 0\" title \"YouTube video player\" frameborder \"0\" allow \"accelerometer; autoplay; clipboard write; encrypted media; gyroscope; picture in picture; web share\" allowfullscreen></iframe> ### 接線參考 PotentiometerBoard GNDGND VCC3V3 SGPIO1 SSD1306 OLEDBoard GNDGND VCC3V3 SCL16 SDA15 ### Code ```py from machine import Pin,ADC,I2C from ssd1306 import SSD1306_I2C import time adc1 ADC(Pin(1),atten ADC.ATTN_11DB) sda_pin Pin(15,Pin.PULL_UP) scl_pin Pin(16,Pin.PULL_UP) i2c I2C(1,sda sda_pin, scl scl_pin, freq 800_000) print(i2c.scan()) oled SSD1306_I2C(128, 64, i2c, addr 0x3c) #Init, white background oled.fill(1) oled.rect(0,32,128,10,0) while True: #Read ADC adc1_read adc1.read() # 12bit adc1_read_mv adc1.read_uv()//1000 adc1_read_u16 adc1.read_u16() # 16bit #Set progress bar bar_width round (adc1_read / 4095 * 128) oled.fill_rect(bar_width,33,128 bar_width,8,0) oled.fill_rect(0,33,bar_width,8,1) #Set ADC text, centered text_adc1 str(adc1_read_mv) + \" mV\" start_x_text_adc1 64 len(text_adc1)*4 oled.fill_rect(36,24,56,8,1) oled.text(text_adc1,start_x_text_adc1,24,0) #Show oled.show() print(adc1_read,adc1_read_u16,adc1_read_mv,\"mv\",bar_width,\"width\") time.sleep(0.05) ```"},"/Leaf_S3_doc/zh_tw/MicroPython/Environment.html":{"title":"Micropython 運行環境搭建","content":"# Micropython 運行環境搭建 Micropython運行環境依賴於Python，所以在使用前我們需要先安裝Python，這裡我們使用的IDE是Thonny。 ## 安裝Python環境 打開[Python官網](https://www.python.org/) 。 對於Windows 系統來說，最便捷的安裝包下載方法就是在官網首頁點擊如下圖所示的圖標進行下載。 ![](../assets/images/Micropython_operating_env_1.png) 其他操作系統或是其他發行版本則可以在 Downloads 選項欄中進行選擇。 建議使用python 3.7以上的版本。 開始安裝時一定要記得勾選Add Python 3.x to PATH，這樣可以免除再手動添加進PATH。 ![](../assets/images/Micropython_operating_env_2.png) 按照安裝提示逐步操作即可順利完成安裝 。 ## 安裝Thonny IDE 以Windows PowerShell的具體操作步驟為例。 其他系統或安裝方法可參考[Thonny官網](https://thonny.org/)上的說明。 右鍵Windows開始菜單即可看到Windows PowerShell ，單擊打開。 ![](../assets/images/Micropython_operating_env_3.png) 我們在此處通過pip來安裝Thonny IDE。 pip是 Python 包管理工具，首先要確認pip是否是最新版，直接使用以下命令升級pip： ```shell pip install U pip ``` 使用以下命令安裝Thonny： ```shell pip install thonnyapp ``` 如果未來有需要，則可以使用以下命令升級Thonny： ```shell pip install U thonnyapp ``` 用Windows搜索即可快速找到Thonny，也可以在開始菜單欄裡找到它。 ![](../assets/images/Micropython_operating_env_4.png) ## 連接開發板至電腦 將開發板通過USB數據線連接至電腦。 正確連接時開發板的電源指示燈會亮起。 我們需要知道開發板是否被電腦識別，並找出連接到了哪一個 COM 口（用於串口通信，下載程序等）。 首先在桌面找到“此電腦”,右鍵，選擇“管理”，打開“設備管理器”，點開“端口（COM 和 LPT）”。 此時會在列表中新加入一個 COM 口（示例圖中是 COM21）。 ![](../assets/images/Micropython_operating_env_5.png) ## 燒錄MicroPython固件 Leaf S3開發板默認出廠固件是MicroPython，如果您需要燒錄固件，可以[參考這裡](Firmware.html) ## 配置Thonny IDE 打開Thonny，單擊 運行，單擊 選擇解釋器： ![](../assets/images/Micropython_operating_env_9.png) 將解釋器設置為 MicroPython(ESP32)： ![](../assets/images/Micropython_operating_env_10.png) 選擇開發板的COM口： ![](../assets/images/Micropython_operating_env_11.png) 確認設置後，就在Shell中打開了MicroPython REPL。 ![](../assets/images/Micropython_operating_env_12.png) REPL啟動並輸出信息即意味著MicroPython固件燒錄成功，可以開始正常使用了。 單擊 視圖，勾選 文件，即可看到本地文件目錄和開發板上的文件目錄： ![](../assets/images/Micropython_operating_env_13.png) ![](../assets/images/Micropython_operating_env_14.png) 其他視圖窗口也可按需設置使用。 在設置中可以選擇個人喜歡的主題風格。 ![](../assets/images/Micropython_operating_env_15.png)"},"/Leaf_S3_doc/zh_tw/Unboxing/Gettingstart.html":{"title":"Hello World","content":"# Hello World 我們可以從輸出一段“Hello World”文字開始，以此作為了解和學習MicroPython的第一步。 > 本文所述操作基於Thonny IDE，需要先完成對Thonny IDE的配置，與開發板建立連接。 [Thonny IDE運行環境搭建可以參考這裡](../Programming/Environment.html)。 ## 使用REPL **REPL**即**Read Eval Print Loop**的縮寫名詞，譯為 **讀取 求值 輸出 循環**。 我們可以通過實際操作來明白它的意思。 將已經安裝了MicroPython固件的開發板連接電腦，運行Thonny IDE並正確配置後，在Shell窗口中將出現這樣的文本內容： ``` MicroPython v1.17 on 2022 01 09; ESP32S3 module with ESP32S3 Type \"help()\" for more information. >>> ``` 注意最後一行的`>>>`提示符，我們可以直接在這後面輸入算式或是代碼，按下鍵盤`enter`回車鍵就會立即在下一行得到輸出結果。 ```python >>> 1+2 3 >>> print(\"Hello World\") Hello World >>> ``` 現在可以很直觀的理解了，它會讀取我們輸入的信息，執行運算求值，輸出結果，然後等待我們後續的輸入，一直循環這個過程，這也是**REPL**又被譯為**交互式解釋器**的原因，我們可以直接通過輸入代碼來和硬件交互，沒有像傳統的C語言那樣需要在中間執行編譯的過程，我們輸入的信息沒有經過編譯就傳輸給芯片自行解釋並運行了，這本是Python語言的一大重要特性，MicroPython完美繼承了它。 如果僅僅是使用MicroPython REPL，很多具有串口信息收發功能的軟件都可以操作，感興趣的話可以試試各種串口工具，這可以令人更深刻的理解 “沒有中間執行編譯的過程” 的意思。 >關於REPL的應用，更詳盡全面的內容可以參考[MicroPython文檔：REPL](https://docs.micropython.org/en/latest/reference/repl.html) ## 代碼編輯器 Thonny IDE當然不僅僅可以進行REPL的操作，作為python代碼編輯器，本職功能還是有的。 新建一個文件並在其編輯區內輸入代碼。 ```python print(1+2) print(\"Hello World\") ``` 完成代碼編輯後，點擊**保存**，可以選擇將文件保存到MicroPython設備中，這將直接將整個文件的數據傳輸到flash中。可將文件命名為`main.py`，設備會在每次上電或複位後執行有這個文件名的程序，而其他名稱的文件僅在被`main.py`調用時或是我們在Thonny中點擊**運行**時被執行。 ![](../assets/images/Quick_Start.png) 現在點擊**運行**，同樣是無需編譯的，在Shell中會立即得到結果。 ``` 3 Hello World ``` 另外也可以嘗試REPL的鍵盤控制快捷鍵**ctrl+D**軟件復位，可以看到復位後程序立即執行並打印出信息。"},"/Leaf_S3_doc/zh_tw/Unboxing/Introduction.html":{"title":"【 開發板介紹 】","content":"# 【 開發板介紹 】 BPI Leaf S3板載ESP32 S3芯片，支持 2.4 GHz Wi Fi 和低功耗藍牙 (Bluetooth® LE) 雙模無線通信。板子支持USB和外接3.7V鋰電池兩種供電方式，可實現雙電源下自動切換電源功能，並支持USB充電方式。體積小巧，接口方便，上手簡單，可直接應用於物聯網低功耗項目。 BPI Leaf S3開發板在軟件方面支持ESP IDF、Arduino、MicroPython等多種方式進行編程開發 。 BPI Leaf S3開發板上標記了與芯片對應的所有IO管腳，且IO管腳順序與Espressif ESP32 S3 DevKitC 1開發板一致，開發者可根據實際需求，可將DevKitC 1支持的外圍設備添加到BPI Leaf S3上，也可將開發板插在麵包板上使用。 ## 關鍵特性 ESP32 S3，Xtensa® 32 bit LX7 片上外設 PSRAM , FLASH Ultra low power 10uA 2.4G WIFI ，Bluetooth 5 ，Bluetooth mesh GPIO , ADC , TOUCH , PWM , I2C , SPI , RMT , I2S , UART , LCD，CAMERA ，USB , JTAG 1 * 4pin I2C連接座 1 * USB Type C 1 * 2pin 電池連接座，支持充電 1 * 全彩色LED ## 硬件 ### 接口示意圖 ![](../assets/images/Leaf S3_board.png) ### 硬件規格 <table> <tr> <td>BPI Leaf S3 規格表</td> </tr> <tr> <td>SoC主控芯片</td> <td>ESP32 S3，Xtensa® 32 位 LX7 雙核處理器</td> </tr> <tr> <td>主頻</td> <td>240MHz MAX</td> </tr> <tr> <td>工作溫度</td> <td> 40℃~+85℃</td> </tr> <tr> <td>片上 ROM</td> <td>384 KB</td> </tr> <tr> <td>片上 SRAM</td> <td>320 KB</td> </tr> <tr> <td>片外 FLASH ROM</td> <td>8MB</td> </tr> <tr> <td>片上外設 PSRAM</td> <td>2MB</td> </tr> <tr> <td>WIFI</td> <td>IEEE 802.11 b/g/n ，2.4Ghz頻帶，150Mbps</td> </tr> <tr> <td>藍牙</td> <td>Bluetooth 5 ，Bluetooth mesh</td> </tr> <tr> <td>GPIO</td> <td>BPI Leaf S3已引出36個可用GPIO</td> </tr> <tr> <td>ADC</td> <td>2 × 12 位 SAR ADC，支持 20 個模擬通道輸入</td> </tr> <tr> <td>TOUCH 電容式觸摸傳感器</td> <td>14</td> </tr> <tr> <td>SPI</td> <td>4</td> </tr> <tr> <td>I2C</td> <td>2，支持主機或從機模式</td> </tr> <tr> <td>I2S</td> <td>2，串行立體聲數據的輸入輸出</td> </tr> <tr> <td>LCD</td> <td>1，支持 8 位 ~16 位並行 RGB、I8080、MOTO6800 接口</td> </tr> <tr> <td>CAMERA</td> <td>1，支持 8 位 ~16 位 DVP 圖像傳感器接口</td> </tr> <tr> <td>UART</td> <td>3 ，支持異步通信（RS232 和RS485）和 IrDA</td> </tr> <tr> <td>PWM</td> <td>8 路獨立通道，14位精度</td> </tr> <tr> <td>MCPWM</td> <td>2</td> </tr> <tr> <td>USB</td> <td>1 × 全速USB 2.0 OTG，Type C母口</td> </tr> <tr> <td>USB Serial/JTAG 控制器</td> <td>1，USB 全速標準，CDC ACM ，JTAG</td> </tr> <tr> <td>溫度傳感器</td> <td>1，測量範圍為–20 °C 到 110 °C，用於監測芯片內部溫度</td> </tr> <tr> <td>SD/MMC</td> <td>1 × SDIO主機接口，具有2個卡槽，支持SD卡3.0和3.01，SDIO 3.0，CE ATA 1.1，MMC 4.41，eMMC 4.5和4.51</td> </tr> <tr> <td>TWAI® 控制器</td> <td>1 ，兼容 ISO11898 1（CAN 規範 2.0）</td> </tr> <tr> <td>通用 DMA 控制器</td> <td>5 個接收通道和 5 個發送通道</td> </tr> <tr> <td>RMT</td> <td>4 通道發射，4通道接收，共享 384 x 32 bit 的 RAM</td> </tr> <tr> <td>脈衝計數器</td> <td>4個脈衝計數控制器（單元），每個單元有2個獨立的通道</td> </tr> <tr> <td>定時器</td> <td>4 × 54 位通用定時器，16 位時鐘預分頻器，1 × 52 位系統定時器，3 × 看門狗定時器</td> </tr> <tr> <td>外部晶振</td> <td>40Mhz</td> </tr> <tr> <td>RTC 和低功耗管理</td> <td>電源管理單元 (PMU)+ 超低功耗協處理器 (ULP)</td> </tr> <tr> <td>低功耗電流</td> <td>10uA</td> </tr> <tr> <td>工作電壓</td> <td>3.3V</td> </tr> <tr> <td>輸入電壓</td> <td>3.3V~5.5V</td> </tr> <tr> <td>最大放電電流</td> <td>2A@3.3V DC/DC</td> </tr> <tr> <td>USB充電</td> <td>支持</td> </tr> <tr> <td>最大充電電流</td> <td>500mA</td> </tr> <tr> <td>可控全彩色LED</td> <td>1</td> </tr> </table> ### 硬件尺寸 ![](../assets/images/Leaf S3_board_dimension.png) <table> <tr> <td>BPI Leaf S3 尺寸表</td> </tr> <tr> <td>管腳間距</td> <td>2.54mm</td> </tr> <tr> <td>安裝孔間距</td> <td>23mm/ 62.25mm</td> </tr> <tr> <td>安裝孔尺寸</td> <td>內徑2mm/外徑3mm</td> </tr> <tr> <td>主板尺寸</td> <td>26 × 65.25(mm)/1.02 x 2.57(inches)</td> </tr> <tr> <td>板厚</td> <td>1.2mm</td> </tr> <tr> <td></td> </tr> </table> 管腳間距兼容萬能板（洞洞板、點陣板），麵包板，便於調試應用。 ## 資料與資源 [GitHub: BPI Leaf S3 開發板原理圖PDF](https://github.com/BPI STEAM/BPI Leaf S3 Doc/blob/main/sch/BPI Leaf S3 Chip V0.1A.pdf) [ESP32 S3 技術規格書](https://www.espressif.com/sites/default/files/documentation/esp32 s3_datasheet_cn.pdf) [ESP32 S3 技術參考手冊](https://www.espressif.com/sites/default/files/documentation/esp32 s3_technical_reference_manual_cn.pdf)"},"/Leaf_S3_doc/zh_tw/Arduino/Basic.html":{"title":"板載資源的使用","content":"# 板載資源的使用 本章主要是通過一些示例項目，闡述 Leaf S3 主控板的外設基本使用方法，通過下面的項目，您可以進行修改完成您的自己的項目。 其中 Leaf S3 外設主要包括：UART、I2C、SPI、ADC、PWM、DAC等。 ## 開始之前的準備 BPI Leaf S3 開發板上的typec使用的是ESP32 S3的原生USB接口，而不是傳統的USB轉TLL芯片。 為了讓您的開發板能正確下載程序，您需要將BPI Leaf S3設置為下載模式，有以下兩種方法： 通過USB連接到電腦，按下BOOT鍵，再按一下Reset鍵並鬆開，最後鬆開BOOT鍵。 在斷開所有供電的狀態下，按住BOOT鍵，然後將開發板插上電腦，最後鬆開BOOT鍵。 這時候可以在設備管理器中看到一個多的COM口 ![](../assets/images/Device_manager.jpg) 在IDE中選擇這個端口 ![](../assets/images/Device_manager_1.jpg) ## 項目一 串口實驗 在最開始的章節中，我們上傳了一個 Blink 閃爍程序來測試板子上的 LED 狀態燈。現在，我們使用 UART 串口，每秒打印一次計時數據。 ### 串口實驗:所需元件 Leaf S3 主板 X 1 ![](../assets/images/Leaf S3.png) ### 串口實驗:硬件連接 此項目不需要其他傳感器，所以只需要把Leaf S3用USB連到電腦就能用。 ### 串口實驗:代碼 打開 Arduino IDE。儘管可以直接複製代碼，我們還是建議您自己手動輸入代碼熟悉下。 代碼如下: <details> <summary>展開查看</summary> <pre><code> void setup() { Serial.begin(115200); //設置串口通信波特率 } void loop() { static unsigned long i 0; //定義變量i Serial.println(i++); //i加一後輸出i delay(1000); //延時1秒 } </code></pre> </details> 輸入完成後，點擊“編譯”檢查代碼有無錯誤。確保沒有錯誤後就可以開始上傳了，點擊“上傳”之後 IDE 會把代碼發送給 Leaf S3 主板。上傳完成之後，你需要按一下復位鍵，這樣代碼就能正常運行了 ### 串口實驗:實驗現象 完成之前步驟的上傳後，打開 Arduino IDE 自帶的串口監視器，可以看到如下的打印信息： ![](../assets/images/Lesson1 1.png) ## 項目二 PWM(呼吸燈) 呼吸燈，即讓 Leaf S3 通過 PWM 驅動 LED 燈，實現 LED 的亮度漸變，看起來就像是在呼吸一樣。關於 PWM 的解釋，請閱覽知識擴展部分。 ### PWM實驗：所需元件 Leaf S3 主板 X 1 ![](../assets/images/Leaf S3.png) LED X 1 (建議串聯一個電阻限流) ![](../assets/images/led.png) ### PWM實驗：硬件連接 將LED連接到Leaf S3的GPIO13就可以了，長的那個腳接GPIO13，短的接到GND ### PWM實驗：代碼 打開 Arduino IDE。儘管可以直接複製代碼，我們還是建議您自己手動輸入代碼熟悉下。 代碼如下: <details> <summary>展開查看</summary> <pre><code> #define LED_CHANNEL_0 0 //設置通道0 #define LED_TIMER_13_BIT 13 //設置13位定時器 #define LED_BASE_FREQ 5000 //設置定時器頻率位5000Hz #define LED_PIN 13 //設置LED燈 int brightness 0; // LED亮度 int fadeAmount 1; // LED數量 //設置led燈的亮度 void ledcAnalogWrite(uint32_t value, uint32_t valueMax 255) { //計算佔空比 uint32_t duty (LED_BASE_FREQ / valueMax) * min(value, valueMax); //設置佔空比 ledcWrite(LED_CHANNEL_0, duty); } void setup() { ledcSetup(LED_CHANNEL_0, LED_BASE_FREQ, LED_TIMER_13_BIT); ledcAttachPin(LED_PIN, LED_CHANNEL_0); } void loop() { ledcAnalogWrite(brightness); brightness + fadeAmount; if (brightness < 0 brightness > 255) { fadeAmount fadeAmount; } delay(30); } </code></pre> </details> 輸入完成後，點擊“編譯”按鈕檢查代碼是否有錯誤。確定沒有錯誤後可以開始上傳了，點擊“上傳”按鈕 。 IDE 會把代碼發送給 Leaf S3 主板。上傳完成後您就可以看見Type C旁邊的LED 燈開始“呼吸”了！ 現在讓我們來回顧一下代碼和硬件，看看它是如何工作。 ### PWM實驗：相關知識 什麼是 PWM 控制信號？ PWM（pulse width modulation）脈衝寬度調製，MCU（微控制器）通過對開關器件的通斷進行控制，使輸出端得到一系列幅值相等的脈衝，用這些脈衝來代替正弦波或所需的波形。如下圖所示： ![](../assets/images/Lesson2 1.jpg) 其中，tON 是高電平持續時間，tPWM 是 PWM 波的周期，tPWM tON 是低電平持續時間，佔空比是指高電平持續時間佔整個週期的比例，即 D ton/tPWM 。 ### PWM實驗：代碼分析 Leaf S3 的 PWM 比普通的 Arduino UNO 高級的多，設置上不能簡單的使用analogWrite 函數來驅動 PWM，而是需要設置 timer 函數，以及相關的頻率參數等才能工作。 ``` #define LEDC_CHANNEL_0 0 ``` 定義了定時器使用的通道，Leaf S3 總共有 16 個通道，這裡用的是通道 0。 ``` #define LEDC_TIMER_13_BIT 13 ``` 定義了定時器為 13 位定時器，即定時器最大計數為 2 的 13 次方。 ``` #define LEDC_BASE_FREQ 5000 ``` 這是設置定時器的頻率，單位是 Hz。接下來的 brightness 和 fadeAmount 參數分別表示 PWM 的佔空比和每次變化的數值。 ``` void ledcAnalogWrite(uint32_t value, uint32_t valueMax 255) ``` 這個函數是計算 PWM 佔空比和設置 PWM 佔空比，類似 Arduino 的 analogWrite 函數，可以看到，傳遞參數的最大值是 255，這是為了和 analogWrite 兼容。 ``` ledcSetup(LEDC_CHANNEL_0, LEDC_BASE_FREQ, LEDC_TIMER_13_BIT); \t ledcAttachPin(LED_PIN, LEDC_CHANNEL_0); ``` 這兩個函數是 Leaf S3 定時器設置函數，函數原型及原理這裡不講述，如果您感興趣可以看看底層源碼（源碼地址：C:\\Users\\“your PC”\\AppData\\Local\\Arduino15\\packages\\esp32\\ hardware\\ adafruit_metro_esp32s2 \\0.0.3\\libraries\\ESP32\\），這裡只需要知道怎麼用這些函數來設置相關的 timer 就可以了。 關於什麼是 PWM 信號，在前面已經闡述過了，這裡不再說明。 >注意：Leaf S3 的任何引腳都可以配置成 PWM 輸出，您可以嘗試著修改代碼，完成您的項目。 ## 項目三 ADC ADC（模數轉換器即 A/D 轉換器），是指將模擬信號轉變成數字信號。 Leaf S3 的ADC 是13位的，最大輸出值為 8191，而 Arduino UNO 是 10 位的，最大輸出值是 1023，因此，在精度上比Arduino UNO 要高，而且轉換速率快，且在使用上兼容 Arduino analogRead 函數，直接讀取即可。 ### ADC實驗：所需元件 模擬角度傳感器 X 1 ![](../assets/images/Lesson3 1.png) 麵包板 X 1 ![](../assets/images/Lesson3 2.png) Leaf S3 主板 X 1 ![](../assets/images/Leaf S3.png) ### ADC實驗：硬件連接 把 電位計插接到 Leaf S3 主板上，然後將模擬角度傳感器插接到 IO2（實驗中用的是IO2）。元件連接好後，使用 USB 線連接 Leaf S3 和電腦。 ### ADC實驗：代碼 打開 Arduino IDE。儘管可以直接複製代碼，我們還是建議您自己手動輸入代碼熟悉下。代碼如下: <details> <summary>展開查看</summary> <pre><code> void setup() { // put your setup code here, to run once: Serial.begin(115200); } void loop() { // put your main code here, to run repeatedly: Serial.println(analogRead(2)); delay(100); } </code></pre> </details> 輸入完成後，點擊“編譯”檢查代碼有無錯誤。確保沒有錯誤後就可以開始上傳了，點擊“上傳”之後IDE 會把代碼發送給 Leaf S3 主板。上傳完成後，打開 Arduino IDE 的串口監視器，旋轉模擬角度傳感器，可以看到串口監視器中的數值變化，如下圖所示： ![](../assets/images/Lesson3 3.png) ### ADC實驗：代碼分析 由於Leaf S3 的 ADC 在使用上完全兼容 Arduino，因此這裡不再對analogRead 函數進行過多的講解。 注意：如果您對 Arduino 的基本函數不是特別熟悉，您可以[點擊鏈接](https://www.arduino.cc/en/Tutorial/BuiltInExamples)進行學習。 ## 項目四 I2C Leaf S3 的 I2C 可以配置到任意 I/O 口，您可以通過傳遞相關參數進行配置。為了方便使用，我們已經將 I2C 進行了默認配置，在使用上完全兼容 Arduino，默認配置引腳可以在第一章簡介中查看到。本項目是基於 I2C 默認配置，驅動 OLED 顯示屏。 所需元件 I2C OLED 12864 顯示屏 X 1 ![](../assets/images/Lesson4 1.png) 麵包板 X 1 ![](../assets/images/Lesson3 2.png) Leaf S3 主板 X 1 ![](../assets/images/Leaf S3.png) ### I2C實驗：硬件連接 把Leaf S3 主板插到麵包板上，然後將 OLED顯示屏插接到 I2C 接口。 （SDA是33，SCL是34）元件連接好後，使用 USB 線連接 Leaf S3 和電腦。 ### I2C實驗：代碼 打開 Arduino IDE。儘管可以直接複製代碼，我們還是建議您自己手動輸入代碼熟悉下。代碼如下: <details> <summary>展開查看</summary> <pre><code> #include <Wire.h> int UG2864Address 0x3C;//OLED UG2864器件7位地址 prog_char F8X16[][16] PROGMEM { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,// 0 0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00,//!1 0x00,0x10,0x0C,0x06,0x10,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//\"2 0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00,//#3 0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00,//$4 0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00,//%5 0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10,//&6 0x10,0x16,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//'7 0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00,//(8 0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00,//)9 0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00,//*10 0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00,//+11 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00,0x00,0x00,//,12 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,// 13 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00,//.14 0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00,///15 0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00,//016 0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//117 0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00,//218 0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00,//319 0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00,//420 0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00,//521 0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00,//622 0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00,//723 0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00,//824 0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00,//925 0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,//:26 0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x60,0x00,0x00,0x00,0x00,//;27 0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00,//<28 0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,// 29 0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00,//>30 0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00,//?31 0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00,//@32 0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20,//A33 0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00,//B34 0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00,//C35 0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00,//D36 0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00,//E37 0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00,//F38 0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00,//G39 0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20,//H40 0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//I41 0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00,//J42 0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00,//K43 0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00,//L44 0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00,//M45 0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00,//N46 0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00,//O47 0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00,//P48 0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00,//Q49 0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20,//R50 0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00,//S51 0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//T52 0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//U53 0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00,//V54 0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00,//W55 0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20,//X56 0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//Y57 0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00,//Z58 0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00,//[59 0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00,//\\60 0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00,//]61 0x00,0x00,0x04,0x02,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//^62 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,//_63 0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//`64 0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20,//a65 0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00,//b66 0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00,//c67 0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20,//d68 0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00,//e69 0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//f70 0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00,//g71 0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//h72 0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//i73 0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,//j74 0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00,//k75 0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//l76 0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F,//m77 0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//n78 0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//o79 0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00,//p80 0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80,//q81 0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00,//r82 0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00,//s83 0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00,//t84 0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20,//u85 0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00,//v86 0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00,//w87 0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00,//x88 0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00,//y89 0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00,//z90 0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40,//{91 0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,//92 0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00,//}93 0x00,0x06,0x01,0x01,0x02,0x02,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//~94 }; 字符 ch_buf[17] {0}; int RES 6;//小工具PIN6 int DC 7;//小工具PIN3 void Writec(unsigned char COM) { Wire.beginTransmission(UG2864Address); 電線.寫（0x00）； 電線. 寫 (COM); Wire.endTransmission(); } 無效寫入（無符號字符數據） { Wire.beginTransmission(UG2864Address); 電線.寫（0x40）； Wire.write（數據）； Wire.endTransmission(); } 無效 SSD1306() { writec(0XAE);//顯示關閉 Writec(0X00);//設置低列地址 Writec(0X10);//設置高位列地址 writec(0X40);//設置顯示起始行 writec(0XB0);//設置頁地址 writec(0X81);//設置合約控制 Writec(0XCF);//內部DC/DC電路產生的VCC writec(0XA0);//設置段重映射列地址127映射到SEG0 writec(0XA6);//正常/反轉正常顯示 writec(0XA8);//復用比例 Writec(0X3F);//1/64 Writec(0XC0);//Com掃描方向重映射模式。 從 COM[N 1] 掃描到 COM0 writec(0XD3);//設置顯示偏移量 寫入（0X00）； Writec(0XD5);//設置振盪器除法 寫入（0X80）； writec(0XD9);//設置預充電週期 寫入（0X11）； Writec(0XDa);//設置COM pins Writec(0X12); Writec(0X8d);/*set charge pump enable*/ Writec(0X14); Writec(0Xdb);//Set VcomH Writec(0X20); Writec(0XAF);//display ON } void fill(unsigned char dat) { unsigned char i,j; Writec(0x00);//set lower column address Writec(0x10);//set higher column address Writec(0xB0);//set page address for(j 0;j<8;j++) { Writec(0xB0+j);//set page address Writec(0x00);//set lower column address Writec(0x10);//set higher column address for(i 0;i<128;i++) { Writed(dat); } } } void show_string(unsigned char x,unsigned char y,char *s) { unsigned char i,j,lower,higher; char *t; t s; lower y%16; higher y/16; if((x>3) (y>120)) return; Writec(0xB0+x*2);//set page address Writec(lower);//set lower column address Writec(0x10+higher);//set higher column address for(j 0;*s! '\\0';j++) { for(i 0;i<8;i++){ ch_buf[i] pgm_read_word(&F8X16[*s 32][i]); } for(i 0;i<8;i++) Writed(ch_buf[i]); s++; } Writec(0xB0+x*2+1);//set page address Writec(lower);//set lower column address Writec(0x10+higher);//set higher column address s t; for(j 0;*s! '\\0';j++) { for(i 0;i<8;i++){ ch_buf[i] pgm_read_word(&F8X16[*s 32][i+8]); } for(i 0;i<8;i++) Writed(ch_buf[i]); s++; } } void oled_init(void) { pinMode(RES,OUTPUT);//RES pinMode(DC,OUTPUT);//D/C# digitalWrite(DC,LOW); Wire.begin(); digitalWrite(RES,HIGH); delay(100); digitalWrite(RES,LOW); delay(100); digitalWrite(RES,HIGH); delay(100); SSD1306(); fill(0x00); } void setup() { oled_init(); } void loop() { fill(0x00); show_string(0,12,\"BananaPi\"); show_string(2,12,\"banana pi.org\"); while(1); } </code></pre> </details> 输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后 IDE \t会把代码发送给 Leaf S3 主板。上传完成后，OLED 显示屏会显示“BananaPi banana pi.org”字样。 ### I2C实验：代码分析 本项目的代码相对于前面的项目较多，主要是基于 I2C 通信对 OLED 显示屏底层寄存器的直接驱动。 ``` void Writec(unsigned char COM) ``` 设置寄存器函数，通过 I2C 对 OLED 显示屏设置，I2C 使用方法完全兼容 Arduino。 ``` void Writed(unsigned char DATA) ``` 写数据函数，I2C 使用方法完全兼容 Arduino。 >注意：Leaf S3 的 I2C 与 Arduino 完全兼容，主要是调用 Wire 库文件使用。 ## 项目五 SPI 在很多传感器中，都使用 SPI 通信，因为 SPI 通信速率相对于 I2C 更快，没有地址冲突的弊端。SPI，是 一种高速的、全双工、同步的通信总线，而 Leaf S3 的 SPI 可以配置到所有 I/O，您可以阅览底层 代码进行使用（初学者不建议使用）。为了更好的使用体验，Leaf S3 默认情况下配置了IO35、IO36、IO37 为 SPI 口，在使用上则完全兼容 Arduino。 本项目使用 Leaf S3，通过 SPI 读取 BME280 温湿度传感器的数据，示例中使用的是BME280 库文件，关于 SPI 驱动您可以阅览 BEM280 库文件，[点击链接](https://github.com/DFRobot/DFRobot_BME280)下载 BME280 库文件。 ### SPI实验：所需元件 BME280 温湿度传感器 X 1 ![](../assets/images/Lesson5 1.png) >注意：BME280 传感器本身支持 I2C 和 SPI 通信，这里我们采用 SPI 通信。 面包板 X 1 ![](../assets/images/Lesson3 2.png) Leaf S3 主板 X 1 ![](../assets/images/Leaf S3.png) ### SPI实验：代码 打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。 （这个程序需要DFRobot_BME280库，需要在[GitHub](https://github.com/DFRobot/DFRobot_BME280)下载，解压到Arduino\\ Library 文件夹下 ）代码如下： <details> <summary>展开查看</summary> <pre><code> /*! * read_data_spi.ino * * Download this demo to test read data from bme280, connect sensor through spi interface * Connect cs pin to io 2 * Data will print on your serial monitor * * Copyright [DFRobot](http://www.dfrobot.com), 2016 * Copyright GNU Lesser General Public License * * version V1.0 * date 12/03/2019 */ #include \"DFRobot_BME280.h\" #include \"Wire.h\" typedef DFRobot_BME280_SPI BME; // ******** use abbreviations instead of full names ******** # define PIN_CS 2 BME bme(&SPI, PIN_CS); // select TwoWire peripheral and set cs pin id #define SEA_LEVEL_PRESSURE 1015.0f // show last sensor operate status void printLastOperateStatus(BME::eStatus_t eStatus) { switch(eStatus) { case BME::eStatusOK: Serial.println(\"everything ok\"); break; case BME::eStatusErr: Serial.println(\"unknow error\"); break; case BME::eStatusErrDeviceNotDetected: Serial.println(\"device not detected\"); break; case BME::eStatusErrParameter: Serial.println(\"parameter error\"); break; default: Serial.println(\"unknow status\"); break; } } void setup() { Serial.begin(115200); bme.reset(); Serial.println(\"bme read data test\"); while(bme.begin() ! BME::eStatusOK) { Serial.println(\"bme begin faild\"); printLastOperateStatus(bme.lastOperateStatus); delay(2000); } Serial.println(\"bme begin success\"); delay(100); } void loop() { float temp bme.getTemperature(); uint32_t press bme.getPressure(); float alti bme.calAltitude(SEA_LEVEL_PRESSURE, press); float humi bme.getHumidity(); Serial.println(); Serial.println(\" start print \"); Serial.print(\"temperature (unit Celsius): \"); Serial.println(temp); Serial.print(\"pressure (unit pa): \"); Serial.println(press); Serial.print(\"altitude (unit meter): \"); Serial.println(alti); Serial.print(\"humidity (unit percent): \"); Serial.println(humi); Serial.println(\" end print \"); delay(1000); } </code></pre> </details> 輸入完成後，點擊“編譯”檢查代碼有無錯誤。確保沒有錯誤後就可以開始上傳了，點擊“上傳”之後 IDE 會把代碼發送給 Leaf S3 主板。打開 Arduino 串口監視器，可以看到打印信息如下： ![](../assets/images/Lesson5 2.png) ### SPI實驗：代碼分析 本項目採用的是 BME280 庫文件，在 Item 5.ino 文件中並沒有對 SPI 底層進行操作，不過，Leaf ESP32 S3 的 SPI 使用完全兼容 Arduino。 ## 項目六 WS2812 Leaf S3 集成了一個型號為WS2812的RGB彩燈。本項目是點亮 Leaf S3 的RGB彩燈的實驗， ### WS2812實驗：所需元件 Leaf S3 主板 X 1 ![](../assets/images/Leaf S3.png) >注意：該項目不需要連接其他傳感器。 ### WS2812實驗：代碼 打開 Arduino IDE。儘管可以直接複製代碼，我們還是建議您自己手動輸入代碼熟悉下。 （這個程序需要Adafruit_NeoPixel庫，需要在[GitHub](https://github.com/adafruit/Adafruit_NeoPixel)下載，解壓到Arduino\\ Library 文件夾下）代碼如下: <details> <summary>展開查看</summary> <pre><code> // NeoPixel Ring simple sketch (c) 2013 Shae Erisson // Released under the GPLv3 license to match the rest of the // Adafruit NeoPixel library #include <Adafruit_NeoPixel.h> #ifdef __AVR__ #include <avr/power.h> // Required for 16 MHz Adafruit Trinket #endif // Which pin on the Arduino is connected to the NeoPixels? #define PIN 18 // On Trinket or Gemma, suggest changing this to 1 // How many NeoPixels are attached to the Arduino? #define NUMPIXELS 1 // Popular NeoPixel ring size // When setting up the NeoPixel library, we tell it how many pixels, // and which pin to use to send signals. Note that for older NeoPixel // strips you might need to change the third parameter see the // strandtest example for more information on possible values. Adafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800); #define DELAYVAL 500 // Time (in milliseconds) to pause between pixels void setup() { // These lines are specifically to support the Adafruit Trinket 5V 16 MHz. // Any other board, you can remove this part (but no harm leaving it): #if defined(__AVR_ATtiny85__) && (F_CPU 16000000) clock_prescale_set(clock_div_1); #endif // END of Trinket specific code. pixels.begin(); // INITIALIZE NeoPixel strip object (REQUIRED) } void loop() { pixels.clear(); // Set all pixel colors to 'off' // The first NeoPixel in a strand is #0, second is 1, all the way up // to the count of pixels minus one. for(int i 0; i < NUMPIXELS; i++) { // For each pixel... // pixels.Color() takes RGB values, from 0,0,0 up to 255,255,255 // Here we're using a moderately bright green color: pixels.setPixelColor(i, pixels.Color(0, 150, 0)); pixels.show(); // Send the updated pixel colors to the hardware. delay(DELAYVAL); // Pause before next pass through loop } } </code></pre> </details> 輸入完成後，點擊“編譯”檢查代碼有無錯誤。確保沒有錯誤後就可以開始上傳了，點擊“上傳”之後 IDE 會把代碼發送給 Leaf S3 主板。復位後WS2812燈會開始亮綠燈， >注意：如果需要其他顏色，可以修改代碼中的RGB值。 ### WS2812實驗：代碼分析 本項目使用 Leaf S3 集成的WS2812燈，默認GPIO是18。 ``` #define PIN 18 ``` 設置GPIO引腳號 ``` #define NUMPIXELS 1 ``` 設置燈的個數，如果您想連接更多WS2812，可以換一個IO，並修改燈的數量。 ## 項目七 觸摸傳感器 Leaf S3 提供了多達 10 個電容式傳感器 GPIO，能夠探測由手指或其他物品直接接觸或接近而產生的電容差異。這種低噪聲特性和電路的高靈敏度設計適用於較小的觸摸板，可以直接用於觸摸開關。本項目闡述瞭如何通過Arduino 代碼獲取 Leaf S3 的觸摸傳感器狀態，並打印狀態。 ### 觸摸實驗：所需元件 Leaf S3 主板 X 1 ![](../assets/images/Leaf S3.png) >注意：該項目不需要連接其他傳感器。 ### 觸摸實驗：代碼 打開 Arduino IDE。儘管可以直接複製代碼，我們還是建議您自己手動輸入代碼熟悉下。 代碼如下: <details> <summary>展開查看</summary> <pre><code> void setup() { Serial.begin(115200); delay(1000); // give me time to bring up serial monitor Serial.println(\"Leaf S3 Touch Test\"); } void loop(){ Serial.println(touchRead(T2)); // get value using T0 >D9 delay(100); } </code></pre> </details> 輸入完成後，點擊“編譯”檢查代碼有無錯誤。確保沒有錯誤後就可以開始上傳了，點擊“上傳”之後 IDE 會把代碼發送給 Leaf S3 主板。打開 Arduino IDE 串口監視器，並用手觸摸 GPIO2（T2 對應的是GPIO2），可以看到會打印出的數據突然變小，如下圖所示： ![](../assets/images/Lesson8 1.png) ### 觸摸實驗：代碼分析 獲取觸摸傳感器的 GPIO 狀態，只需要調用 touchRead 函數，函數原型如下： ``` uint16_t touchRead(uint8_t pin) ``` 返回“0”表示沒有觸摸，“1”表示觸摸。其中 pin 是 T0~T9，對應到 Leaf 的引腳如下表所示： <table> <tr> <td></td> </tr> <tr> <td>觸摸傳感器序號 </td> <td>對應的 ESP32 硬件 </td> <td>Leaf S3</td> <td> </td> </tr> <tr> <td>T1</td> <td>GPIO1</td> <td>IO1</td> </tr> <tr> <td>T2 </td> <td>GPIO2 </td> <td>IO2</td> </tr> <tr> <td>T3 </td> <td>GPIO3</td> <td>IO3</td> </tr> <tr> <td>T4 </td> <td>GPIO4</td> <td>IO4</td> </tr> <tr> <td>T5 </td> <td>GPIO5</td> <td>IO5</td> </tr> <tr> <td>T6 </td> <td>GPIO6</td> <td>IO6</td> </tr> <tr> <td>T7 </td> <td>GPIO7</td> <td>IO7</td> </tr> <tr> <td>T8 </td> <td>GPIO8</td> <td>IO8</td> </tr> <tr> <td>T9 </td> <td>GPIO9</td> <td>IO9</td> </tr> <tr> <td>T10</td> <td>GPIO10</td> <td>IO10</td> </tr> <tr> <td>T11</td> <td>GPIO11</td> <td>IO11</td> </tr> <tr> <td>T12</td> <td>GPIO12</td> <td>IO12</td> </tr> <tr> <td>T13</td> <td>GPIO13</td> <td>IO13</td> </tr> <tr> <td>T14</td> <td>GPIO14</td> <td>IO14</td></tr> <tr> <td></td> </tr> </table>"},"/Leaf_S3_doc/zh_tw/Arduino/Environment.html":{"title":"安裝","content":"# 安裝 這篇文章將會指引您安裝Leaf S3的Arduino支持。 ## 使用Arduino IDE安裝支持 ![](../assets/images/logo_arduino.png) 這是直接從 Arduino IDE 安裝 Arduino ESP32 的方法。 > 注意：有關 SoC 支持的概述，請查看[Supported Soc](https://docs.espressif.com/projects/arduino esp32/en/latest/getting_started.html#supported soc s) 的表格，您可以在其中找到特定芯片是否處於穩定或開發版本。 穩定版鏈接：https://raw.githubusercontent.com/espressif/arduino esp32/gh pages/package_esp32_index.json 開發版鏈接：https://raw.githubusercontent.com/espressif/arduino esp32/gh pages/package_esp32_dev_index.json > 從 Arduino IDE 版本 1.6.4 開始，Arduino 允許使用 Boards Manager 安裝第三方平台包。我們有適用於 Windows、macOS 和 Linux 的軟件包。 要使用 Boards Managaer 開始安裝過程，請執行以下步驟： 安裝 1.8 或更高版本的當前上游 Arduino IDE。當前版本位於arduino.cc網站。 啟動 Arduino 並打開 文件>首選項 窗口，並點擊圖示中的位置。 ![](../assets/images/install_guide_preferences.png) 在Additional Board Manager URLs後面輸入上述發布鏈接之一。您可以添加多個 URL，一行一個。 ![](../assets/images/install_guide_boards_manager_url.png) 從 工具 > 開發板 菜單打開 開發板管理器 並安裝esp32平台。 ![](../assets/images/install_guide_boards_manager_esp32.png) 重啟arduino IDE之後可以看到多了ESP32選項，按照圖示配置即可 ![](../assets/images/Board_chose.jpg)"},"/Leaf_S3_doc/zh_tw/index.html":{"title":"【 BPI-Leaf-S3 開發板 】","content":"# 【 BPI Leaf S3 開發板 】 ## 介紹 ![](assets/images/BPI Leaf S3.jpg) 香蕉派Leaf系列是專為物聯網設計的低功耗微控制器開發板。 BPI Leaf S3板載ESP32 S3芯片，支持 2.4 GHz Wi Fi 和低功耗藍牙 (Bluetooth® LE) 雙模無線通信，外圍兼容低功耗硬件設計，深度睡眠模式下功耗僅為10uA。 支持USB和外接3.7V鋰電池兩種供電方式，可實現雙電源下自動切換電源功能，並支持USB充電方式。體積小巧，接口方便，上手簡單，可直接應用於物聯網低功耗項目。 BPI Leaf S3開發板在軟件方面支持ESP IDF、Arduino、MicroPython等多種方式進行編程開發 。 BPI Leaf S3開發板上標記了與芯片對應的所有IO管腳，且IO管腳順序與Espressif ESP32 S3 DevKitC 1開發板一致，開發者可根據實際需求，可將DevKitC 1支持的外圍設備添加到BPI Leaf S3上，也可將開發板插在麵包板上使用。 ## 使用 MicroPython 編程 ![](assets/images/Mircopython.png) MicroPython實現了大部分Python 3 特性和語法，易學易上手，驗證程序效果無需編譯直接下載進芯片運行。 無論是否有編程基礎，MicroPython的上手難度絕對遠低於其他編程語言，其代碼易讀性高，且開源社區有多年積累的豐富資源，就如同Python一樣擁有極強的生命力與應用價值。 通過燒寫 MicroPython 固件，就可以在開發板中使用 Python 語言進行編程。 ## 使用 Arduino 編程 提供了入門 Arduino 的軟件工具和最佳示例，降低進入 ESP32 嵌入式專業開發的門檻。 ![](assets/images/Arduino_logo_1200x350.png) >Arduino 將不會闡述過多基礎內容，請具備 C/C++ 的語言開發基礎。 ## 資料與資源 [WIKI](https://wiki.banana pi.org/BPI Leaf S3_%E5%BC%80%E5%8F%91%E6%9D%BF) [GitHub: BPI Leaf S3 開發板原理圖PDF](https://github.com/BPI STEAM/BPI Leaf S3 Doc/blob/main/sch/BPI Leaf S3 Chip V0.1A.pdf) [ESP32 S3 技術規格書](https://github.com/BPI STEAM/BPI Leaf S3 Doc/blob/main/Example/Arduino) [ESP32 S3 技術參考手冊](https://www.espressif.com/sites/default/files/documentation/esp32 s3_technical_reference_manual_cn.pdf) ## 樣品購買 [官方速賣通](https://www.aliexpress.com/item/1005004428945296.html?spm 5261.ProductManageOnline.0.0.48af4edfYbyEoI) [官方淘寶](https://item.taobao.com/item.htm?spm a2126o.success.0.0.29034831FGnLQW&id 677287234553) OEM&OEM 定制服務 ： sales@banana pi.com"},"/Leaf_S3_doc/zh_tw/no_translate.html":{"title":"no_translate_title","content":" title: no_translate_title class: md_page <div id \"visit_from\"></div> <div id \"no_translate_hint\">no_translate_hint</div> <div> <span id \"visit_hint\">visit_hint</span> <a id \"translate_src\"></a> </div> <div> <script> function getQueryVariable(variable) { var query window.location.search.substring(1); var vars query.split(\"&\"); for (var i 0;i<vars.length;i++) { var pair vars[i].split(\" \"); if(pair[0] variable){return pair[1];} } return(false); } var ref getQueryVariable(\"ref\"); var from getQueryVariable(\"from\"); var link document.getElementById(\"translate_src\"); var fromDis document.getElementById(\"visit_from\"); link.href ref; link.text ref; fromDis.innerHTML from; </script> </div>"}}