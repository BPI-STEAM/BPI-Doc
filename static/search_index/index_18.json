{"/Leaf_S3_doc/zh/MicroPython/Firmware.html":{"title":"Micropython 固件下载与烧录","content":"# Micropython 固件下载与烧录 在[MicroPython官网](https://micropython.org/)可以找到支持ESP32S3芯片的固件 https://micropython.org/download/ESP32_GENERIC_S3/ 点击连接进入页面后即可在下方看到几个固件的下载地址，选择一个.bin 后缀的文件下载到本地即可。 ![](../assets/images/Micropython_operating_env_6.jpg) 注意固件名中标注的日期，离当前时间越近的功能越新。 可以用两种工具来烧录固件，乐鑫科技官方的FLASH下载工具或esptool ，二选其一即可。 ## 设置固件下载模式 有两种操作方法： 1.通过USB连接到电脑，按住BOOT键，再按一下RESET键并松开，最后松开BOOT键。 2.在断开供电的条件下按住BOOT键，再通过USB连接到电脑，最后松开BOOT键。 由此可知，芯片是通过BOOT键所控制的GPIO0来选择复位或重新上电时的启动模式。 在设备管理器中确认COM接口，固件下载模式与普通模式下的com接口序号通常是不一样的。 ![](../assets/images/Micropython_operating_env_5.png) ## Windows FLASH下载工具 下载并解压：[FLASH下载工具下载地址](https://www.espressif.com/zh hans/support/download/other tools) 打开软件并选择芯片型号为ESP32S3,将下载模式设置为usb： ![](../assets/images/Micropython_operating_env_7.png) 此时需要设置开发板为固件下载模式。 在芯片处于固件下载模式的条件下，在FLASH下载工具窗口中修改COM接口为对应的接口，此处为COM22。 添加MicroPython固件，对于ESP32 S3芯片要设置flash起始地址为 `0x0000` 。 ![](../assets/images/Micropython_operating_env_8.png) 先点击ERASE按钮清除flash上的数据，再点击START烧写固件到flash中。 烧录完成后按一次RESET键，使开发板进入普通使用模式。 ## esptool 以Windows PowerShell的具体操作步骤为例。 使用以下命令安装esptool： ```shell pip install esptool ``` 如果未来有需要，则可以使用以下命令升级esptool： ```shell pip install U esptool ``` 通过命令或其他方法在PowerShell中进入固件所在的目录。 可以在Windows文件夹窗口中以按住shift键再单击右键的方式在此文件夹中打开PowerShell窗口。 此时需要设置开发板为固件下载模式，详见上文。 通过以下命令清除flash，需要修改COM接口为对应的接口，此处为COM1。 ```shell python m esptool chip esp32s3 port COM1 erase_flash ``` 通过以下命令烧录固件，需要修改固件文件名为当前对应需要烧录的文件名。 ```shell python m esptool chip esp32s3 port COM1 baud 460800 before usb_reset after no_reset write_flash 0x0 GENERIC_S3_SPIRAM 20220618 v1.19.1.bin ``` 如果是通过USB烧录，完成后按一次RESET键复位，使开发板进入普通使用模式。 如果是通过UART烧录，则会在完成后自动复位。"},"/Leaf_S3_doc/zh/MicroPython/Basic.html":{"title":"基础用例","content":"# 基础用例 >[GitHub BPI Leaf S3 例程](https://github.com/BPI STEAM/BPI Leaf S3 Doc/tree/main/Example/MicroPython zh/02.Use_Peripherals) ## 点亮板载LED灯珠 在完成[MicroPython 运行环境设置](Environment.html)后，可以立即尝试编程。 新建一个 main.py 脚本文件，在其中输入以下代码： ```py from machine import Pin from neopixel import NeoPixel import time pin_48 Pin(48) np NeoPixel(pin_48, 1,bpp 3, timing 1) while True: np[0] (25,25,25) np.write() time.sleep_ms(250) np[0] (0,0,0) np.write() time.sleep_ms(250) ``` 保存文件到MicroPython设备中，点击“Run”运行按钮，即可让板载彩色LED灯珠闪烁。 修改 `np[0] (25,25,25)`等号右侧元组内的数据，可以改变颜色，分别对应R，G，B三色亮度等级，设定范围是0 255，建议使用范围0 25，亮度过高时请勿长时间直视！ [neopixel — control of WS2812 / NeoPixel LEDs — MicroPython 文档](https://docs.micropython.org/en/latest/library/neopixel.html) ## 使彩灯循环显示九种颜色 ```py from machine import Pin from neopixel import NeoPixel import time pin_48 Pin(48, Pin.OUT) np NeoPixel(pin_48, 1,bpp 3, timing 1) RED (255, 0, 0) ORANGE (255, 100, 0) YELLOW (255, 255, 0) GREEN (0, 255, 0) CYAN (0, 255, 255) BLUE (0, 0, 255) PURPLE (180, 0, 255) WHITE (255, 255, 255) OFF (0, 0, 0) color_list [RED,ORANGE,YELLOW,GREEN,CYAN,BLUE,PURPLE,WHITE,OFF] brightness 0.1 while True: for i in color_list: color (round(i[0]*brightness),round(i[1]*brightness),round(i[2]*brightness)) np[0] color np.write() time.sleep(1) ``` ## 全彩LED灯珠循环显示彩虹色 基于上一节，我们可以更进一步，编写循环自动改变灯珠颜色。 ```py from machine import Pin from neopixel import NeoPixel import time def rainbow(num 1,level 25,delay 100): def write_all(num,delay,red,green,blue): for j in range (num): np[j] (red,green,blue) np.write() time.sleep_ms(delay) red,green,blue level,0,0 rainbow_step_list2 [(0,1,0),( 1,0,0),(0,0,1),(0, 1,0),(1,0,0),(0,0, 1)] for step in rainbow_step_list2: for i in range (level): red+ step[0] green+ step[1] blue+ step[2] write_all(num,delay,red,green,blue) np NeoPixel(Pin(48, Pin.OUT), 1,bpp 3, timing 1) while True: rainbow(num 1,level 25,delay 10) ``` 此例程可适用于任意长度的ws2812灯带。 修改 `NeoPixel(Pin(48, Pin.OUT), 1,bpp 3, timing 1)` 中第一个参数至任意想要串接灯带的GPIO管脚。 修改 `rainbow(num 1,level 25,delay 100)` 中的num参数为灯带上对应灯珠的数量。 当然我们也可以根据自己的想法使用for循环或while循环制作自己想要的颜色变化规律。 ## 设计按键中断程序,控制彩灯 BPI Leaf S3 有两颗按键，BOOT 与 RST，RST控制芯片硬件复位，而BOOT则与GPIO0相连，其电路如下图所示。 ![](../assets/images/bpi leaf s3_boot_sch.png) 可见当开发板正常通电工作时，GPIO0在BOOT按键未按下时，串联一颗电阻接到3.3v，此时为高电位；当BOOT按键按下时，GPIO0将直接接地，此时则为低电位。ESP32 S3芯片通过检测此GPIO管脚的电位即可判断按钮是否被按下。 [MicroPython GPIO中断程序 machine.Pin.irq 文档](https://docs.micropython.org/en/latest/library/machine.Pin.html#machine.Pin.irq) 在程序中，通过检测 GPIO中断的触发方式，即可设计一套记录按键被按压的次数的中断程序，用判断当前已经按压的次数来控制彩灯的颜色。 <iframe src \"//player.bilibili.com/player.html?aid 345819290&bvid BV1Nd4y1M7oW&cid 841776119&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ```python from machine import Pin from neopixel import NeoPixel from array import array import time import micropython micropython.alloc_emergency_exception_buf(100) p_48 Pin(48, Pin.OUT) np NeoPixel(p_48, 1,bpp 3, timing 1) p0 Pin(0,Pin.IN,Pin.PULL_UP) trig_locks array('B',[0]) trig_timeticks_list array('L',[0,0]) count array('L',[0]) def p0_irq(pin): if pin.value() 0 and trig_locks[0] 0: trig_timeticks_list[0] time.ticks_ms() trig_locks[0] 1 elif pin.value() 1 and trig_locks[0] 1: trig_timeticks_list[1] time.ticks_diff(time.ticks_ms(),trig_timeticks_list[0]) trig_locks[0] 0 if trig_timeticks_list[1] > 20: count[0] count[0] + 1 if count[0] > 8: count[0] 0 p0.irq(handler p0_irq,trigger Pin.IRQ_FALLING Pin.IRQ_RISING ) RED (255, 0, 0) ORANGE (255, 100, 0) YELLOW (255, 255, 0) GREEN (0, 255, 0) CYAN (0, 255, 255) BLUE (0, 0, 255) PURPLE (180, 0, 255) WHITE (255, 255, 255) OFF (0, 0, 0) color_list [RED,ORANGE,YELLOW,GREEN,CYAN,BLUE,PURPLE,WHITE,OFF] brightness 0.1 while True: print (count) i color_list[count[0]] color (round(i[0]*brightness),round(i[1]*brightness),round(i[2]*brightness)) np[0] color np.write() time.sleep(0.1) ``` ## PWM 单色LED呼吸灯 ### 外部硬件需求 一个可以在3.3v电压下工作的LED灯。 ### 接线参考 例程中使用的是GPIO13管脚，将LED灯正极与GPIO13管脚连接，负极与GND连接。 ### Code ```py from machine import Pin, PWM import time PWM_LED PWM(Pin(13)) PWM_LED.freq(1000) PWM_LED.duty(0) while True: for i in range(0,1024,1): PWM_LED.duty(i) time.sleep_ms(2) for i in range(1022,0, 1): PWM_LED.duty(i) time.sleep_ms(1) ``` ## TB6612FNG模块 PWM驱动电机 ### 外部硬件需求 一个TB6612FNG模块，一个3.3~5V直流电机。 ### 接线参考 TB6612FNG BPI Leaf S3 : :: : PWMA 11 AIN2 13 AIN1 12 STBY 10 VM 5V VCC 3.3V GND GND AO1 电机N极 AO2 电机S极 > AO1/AO2 与电机的连接可任意调换接线顺序，以此改变旋转方向。 ### 运行效果 电机将启动朝一个方向旋转并在7秒逐渐加速到当前电流可达到的最大转速，然后在5秒内逐渐减速至停转，随后反向旋转并重复这个过程。 ### Code ```py from machine import Pin,PWM import time PWM_A PWM(Pin(11)) #Set PWM output pin PWM_A.freq(20000) #Set PWM frequency PWM_A.duty(0) #Set PWM duty cycle AIN1 Pin(12,Pin.OUT) AIN2 Pin(13,Pin.OUT) STBY Pin(10,Pin.OUT) STBY.on() #When STBY pin is at high level, TB6612FNG starts. def MOTOR_Forward(): AIN1.on() AIN2.off() def MOTOR_Reverse(): AIN1.off() AIN2.on() while True: MOTOR_Forward() #for cycle is used to control the PWM duty cycle change. #The PWM duty cycle control precision is 10bit, ie 0~1023. #Some motors require a certain PWM duty cycle to start. for i in range(350,1024,1): PWM_A.duty(i) time.sleep_ms(10) for i in range(1022,0, 1): PWM_A.duty(i) time.sleep_ms(5) MOTOR_Reverse() for i in range(350,1024,1): PWM_A.duty(i) time.sleep_ms(10) for i in range(1022,0, 1): PWM_A.duty(i) time.sleep_ms(5) ``` ## 使用ADC检测电位器电压 ### 外部硬件需求 一个电位器。 ![](https://i.imgur.com/mnuHlMR.jpg) ### ESP32 S3的ADC ESP32 S3芯片内部集成了两个**ADC模数转换器** ，测量范围 0mV 3100mV，分辨率为12bit，即将0mV 3100mV分为2^12 4096级，每一级为一个数字量。 两个ADC模数转换器各有10个测量通道，ADC1为GPIO1 ~ 10,ADC2为GPIO11 ~ 20 。 ### 接线参考 GND接GND，VCC接3V3，S输出端接GPIO11管脚，使用的是ADC2的通道1进行测量。 GPIO1~20管脚都可做ADC输入管脚。 ### Code ```py from machine import Pin,ADC import time adc11 ADC(Pin(11),atten ADC.ATTN_11DB) #adc11 ADC(Pin(11)） #adc11.atten(ADC.ATTN_11DB) while True: read adc11.read() read_u16 adc11.read_u16() read_uv adc11.read_uv() print(\"read {0},read_u16 {1},read_uv {2}\".format(read,read_u16,read_uv)) time.sleep_ms(100) ``` 衰减值 可测量的输入电压范围 ADC.ATTN_0DB 0 mV ~ 950 mV ADC.ATTN_2_5DB 0 mV ~ 1250 mV ADC.ATTN_6DB 0 mV ~ 1750 mV ADC.ATTN_11DB 0 mV ~ 3100 mV 1. `ADC(*，atten)`初始化一个GPIO管脚的ADC通道，可以选择使用`atten`设定衰减值，它控制芯片可测量的输入电压范围，如果不设置，将为默认值`atten ADC.ATTN_0DB`或上一次所设定的值。 2. 可以在初始化一个ADC通道后通过`ADC.atten()`修改衰减值。 3. `ADC.read()`读取ADC并返回读取结果，ESP32 S3芯片的ADC所返回的是12位精度的数据。 4. `ADC.read_u16()`读取ADC并将返回16位的数据。 5. `ADC.read_uv()`根据ADC的特性以`uV`微伏为单位返回校准的输入电压。返回值只有`mV`毫伏分辨率（即，将始终是1000微伏的倍数）。 WiFi功能也使用了ADC2，因此在WiFi处于活动状态时尝试从ADC2的测量通道GPIO11 ~ 20读取模拟值将引发异常。 建议使用`ADC.read_uv()`来读取电压值，它是根据ADC模数转换器的特性经过校准后返回的十进制常数，较比另外两个读取方法更加准确，同时也建议使用时直接经过整除运算：`ADC.read_uv()//1000` 获取`mV`毫伏分辨率的数据。 直接打印输出`ADC.read()`或`ADC.read_u16()`得到的是十进制数值，可用`hex()`函数将数据类型转化为十六进制，例如`hex(ADC.read())`，或用`bin()`函数将数据类型转化为二进制。 ## 用电位器无极调控彩灯亮度 在 [使彩灯循环显示九种颜色](#使彩灯循环显示九种颜色) 小节的基础上，可使用电位器来控制彩灯的亮度。 <iframe width \"720\" height \"405\" frameborder \"0\" src \"https://www.ixigua.com/iframe/7130573075816383014?autoplay 0\" referrerpolicy \"unsafe url\" allowfullscreen></iframe> ### Code ```py from machine import Pin,ADC from neopixel import NeoPixel from array import array import time import micropython adc1 ADC(Pin(1),atten ADC.ATTN_11DB) micropython.alloc_emergency_exception_buf(100) p_48 Pin(48, Pin.OUT) np NeoPixel(p_48, 1,bpp 3, timing 1) p0 Pin(0,Pin.IN,Pin.PULL_UP) trig_locks array('B',[0]) trig_timeticks_list array('L',[0,0]) count array('L',[0]) def p0_irq(pin): if pin.value() 0 and trig_locks[0] 0: trig_timeticks_list[0] time.ticks_ms() trig_locks[0] 1 elif pin.value() 1 and trig_locks[0] 1: trig_timeticks_list[1] time.ticks_diff(time.ticks_ms(),trig_timeticks_list[0]) trig_locks[0] 0 if trig_timeticks_list[1] > 20: count[0] count[0] + 1 if count[0] > 8: count[0] 0 p0.irq(handler p0_irq,trigger Pin.IRQ_FALLING Pin.IRQ_RISING ) RED (255, 0, 0) ORANGE (255, 100, 0) YELLOW (255, 255, 0) GREEN (0, 255, 0) CYAN (0, 255, 255) BLUE (0, 0, 255) PURPLE (180, 0, 255) WHITE (255, 255, 255) OFF (0, 0, 0) color_list [RED,ORANGE,YELLOW,GREEN,CYAN,BLUE,PURPLE,WHITE,OFF] while True: adc1_read adc1.read() # 12bit adc1_read_mv adc1.read_uv()/1000 adc1_read_u16 adc1.read_u16() # 16bit brightness adc1_read/4095 i color_list[count[0]] color (round(i[0]*brightness),round(i[1]*brightness),round(i[2]*brightness)) np[0] color np.write() print(adc1_read,adc1_read_u16,adc1_read_mv,\"mv\",count[0],color) time.sleep(0.1) ``` ## 使用ADC测量电位器，用以调整电机转速 ### 外部硬件需求 * 电位器 x 1 * TB6612FNG电机驱动模块 x 1 * 5v直流电机 x 1 * 一些连接线材 ### 接线参考 PotentiometerBPI Leaf S3 GNDGND VCC3V3 S14 TB6612FNGBPI Leaf S3 PWMA11 AIN213 AIN112 STBY10 VM5V VCC3.3V GNDGND TB6612FNGMotor AO1Motor N pole AO2Motor S pole ### 运行效果 开发板将间隔100ms在REPL输出ADC读取到的电压值，单位为mv，以及对应控制的PWM占空比。 用手调整电位器，改变其输出电压，电压越大，开发板输出的PWM占空比越高，电机转速越快。 <iframe width \"720\" height \"405\" frameborder \"0\" src \"https://www.ixigua.com/iframe/7094798929295835681?autoplay 0\" referrerpolicy \"unsafe url\" allowfullscreen></iframe> ### Code ```py from machine import Pin,ADC,PWM import time adc14 ADC(Pin(14),atten ADC.ATTN_11DB) PWM_A PWM(Pin(11)) #Set PWM output pin PWM_A.freq(20000) #Set PWM frequency PWM_A.duty(0) #Set PWM duty cycle AIN1 Pin(12,Pin.OUT) AIN2 Pin(13,Pin.OUT) STBY Pin(10,Pin.OUT) AIN1.on() #MOTOR forward AIN2.off() STBY.on() #When STBY pin is at high level, TB6612FNG starts. while True: read_mv adc14.read_uv()//1000 if read_mv < 3000: duty_set int(1023/3000 * read_mv) else: duty_set 1023 PWM_A.duty(duty_set) Duty_cycle int(duty_set/1023*100) print(\"ADC_read {0}mv,Duty_cycle {1}%\".format(read_mv,Duty_cycle)) time.sleep_ms(100) ``` ## UART 串口数据读写 ### 外部硬件需求 USB转UART模块（CH340，CP2102等）。 ### 软件需求 一个串口调试软件例如[PuTTY](https://putty.org/)，以及USB转UART模块所需驱动。 ### 接线参考 将BPI Leaf S3开发板通过USB连接电脑，USB转UART模块的RX接GPIO17（BPI Leaf S3的TX），TX接GPIO18（BPI Leaf S3的RX），GND接GND（共地），USB转UART模块的USB接口连接电脑，可以是连接BPI Leaf S3的同一台电脑，也可以是不同的两台电脑。 ### 运行效果 在BPI Leaf S3所在电脑的MicroPython REPL中将间隔一秒输出一次从USB转UART模块中接收到的数据。 而在USB转UART模块所在的电脑的串口调试软件窗口中则可以看到，每间隔一秒输出一行由BPI Leaf S3发送的字符 `Hello World!` 。 ### Code ``` from machine import UART import time uart1 UART(1, tx 17, rx 18) # Select the UART interface and specify the pins used by TX and RX uart1.init(115200, bits 8, parity None, stop 1) # Initialization, set the baud rate, set the number of characters, set the parity, set the stop bit def test(): for i in range(50): uart1.write('Hello World!') # write data time.sleep(0.5) print(uart1.read()) # read data time.sleep(0.5) test() ``` ## I²C，SSD1306 OLED 显示 SSD1306 OLED屏幕模块是一个很常见的可以使用I2C通信协议的屏幕模块，最大输出128*64 bit的图像，无灰阶，单颗像素仅有亮灭两个状态，控制逻辑相对简单，很适合入门学习单片机驱动屏幕显示的项目。 ### 外部硬件需求 一块具备I²C接口的SSD1306 OLED屏幕模块，最好为128*64像素的。 ### 驱动库下载 [micropython/ssd1306.py 驱动](https://github.com/micropython/micropython lib/blob/master/micropython/drivers/display/ssd1306/ssd1306.py) 将 ssd1306.py 下载到本地后，再上传到MicroPython设备中。 ### 接线参考 SSD1306 OLEDBoard GNDGND VCC3V3 SCL16 SDA15 ### 扫描I²C地址 ```py from machine import I2C,Pin sda_pin Pin(15,Pin.PULL_UP) scl_pin Pin(16,Pin.PULL_UP) i2c I2C(1,sda sda_pin, scl scl_pin, freq 400_000) i2c_list i2c.scan() i2c_total len(i2c_list) print(\"Total num:\",i2c_total) j 0 for i in i2c_list: j j+1 print(\"NO.{0},address:{1}\".format(j,hex(i))) ``` 通常SSD1306的地址为0x3c。 ### 显示字符 [MicroPython framebuf 文档](https://docs.micropython.org/en/latest/library/framebuf.html#module framebuf) ```py from machine import I2C, Pin from ssd1306 import SSD1306_I2C sda_pin Pin(15, Pin.PULL_UP) scl_pin Pin(16, Pin.PULL_UP) i2c I2C(1, sda sda_pin, scl scl_pin, freq 800_000) print(i2c.scan()) oled SSD1306_I2C(128, 64, i2c, addr 0x3c) def display(): # The framebuf library only supports ASCII printing characters encoded as 32~126 oled.text(\" !\\\"#$%&'()*+, ./\", 0, 0) oled.text(\"0123456789:;< >?\", 0, 8) oled.text(\"@ABCDEFGHIJKLMNO\", 0, 16) oled.text(\"PQRSTUVWXYZ[\\]^_\", 0, 24) oled.text(\"`abcdefghijklmno\", 0, 32) oled.text(\"pqrstuvwxyz{}~\", 0, 40) oled.show() def testAscii(): # The return value of chr() is the ASCII character corresponding to the current integer Ascii '' for i in range(32, 127): Ascii Ascii + chr(i) for i in range(128, 256): Ascii Ascii + chr(i) return Ascii def display_Ascii(): # The framebuf library only supports ASCII printing characters encoded as 32~126 oled.text(testAscii()[0:16], 0, 0) oled.text(testAscii()[16:32], 0, 8) oled.text(testAscii()[32:48], 0, 16) oled.text(testAscii()[48:64], 0, 24) oled.text(testAscii()[64:80], 0, 32) oled.text(testAscii()[80:95], 0, 40) oled.show() if __name__ \"__main__\": display() # print(testAscii()) # display_Ascii() # ASCII printing characters (character encoding: 32 127) # 32~126 (95 in total) are characters: 32 is a space, among which 48~57 are ten Arabic numerals from 0 to 9, # 65～90 are 26 uppercase English letters, # 97~122 are 26 lowercase English letters, # The rest are some punctuation marks, operation symbols, etc. # The 127th character represents the delete command on the keyboard. # ASCII extension code (character encoding: 128 255) # The last 128 are called extended ASCII codes. # Many x86 based systems support the use of extended (or \"high\") ASCII. # The extended ASCII code allows the 8th bit of each character # to be used to determine additional 128 special symbol characters, foreign language letters and graphic symbols. ``` ## OLED显示电位器电压与实时进度条 继续使用[用电位器无极调控彩灯亮度](#用电位器无极调控彩灯亮度) 章节中中用ADC检测电位器电压的方法，可以设计一个让OLED屏幕显示电位器电压与实时进度条的程序。 <iframe src \"//player.bilibili.com/player.html?aid 730872804&bvid BV1MD4y1179T&cid 841775129&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ### 接线参考 PotentiometerBoard GNDGND VCC3V3 SGPIO1 SSD1306 OLEDBoard GNDGND VCC3V3 SCL16 SDA15 ### Code ```py from machine import Pin,ADC,I2C from ssd1306 import SSD1306_I2C import time adc1 ADC(Pin(1),atten ADC.ATTN_11DB) sda_pin Pin(15,Pin.PULL_UP) scl_pin Pin(16,Pin.PULL_UP) i2c I2C(1,sda sda_pin, scl scl_pin, freq 800_000) print(i2c.scan()) oled SSD1306_I2C(128, 64, i2c, addr 0x3c) #Init, white background oled.fill(1) oled.rect(0,32,128,10,0) while True: #Read ADC adc1_read adc1.read() # 12bit adc1_read_mv adc1.read_uv()//1000 adc1_read_u16 adc1.read_u16() # 16bit #Set progress bar bar_width round (adc1_read / 4095 * 128) oled.fill_rect(bar_width,33,128 bar_width,8,0) oled.fill_rect(0,33,bar_width,8,1) #Set ADC text, centered text_adc1 str(adc1_read_mv) + \" mV\" start_x_text_adc1 64 len(text_adc1)*4 oled.fill_rect(36,24,56,8,1) oled.text(text_adc1,start_x_text_adc1,24,0) #Show oled.show() print(adc1_read,adc1_read_u16,adc1_read_mv,\"mv\",bar_width,\"width\") time.sleep(0.05) ```"},"/Leaf_S3_doc/zh/MicroPython/Environment.html":{"title":"MicroPython 使用环境搭建","content":"# MicroPython 使用环境搭建 MicroPython的使用并不依赖于特定的开发工具，只要能与开发板建立串口通信，即可获得 MicroPython的交互式解释器（REPL），而各种第三方工具则是以此为基础，提供一些其他的便利功能。 比如多数IDE或编辑器都可以提供代码补全功能，一些工具则提供上传或下载文件的功能。 ## 安装Python环境 打开[Python官网](https://www.python.org/) 。 对于Windows 系统来说，最便捷的安装包下载方法就是在官网首页点击如下图所示的图标进行下载。 ![](../assets/images/Micropython_operating_env_1.png) 其他操作系统或是其他发行版本则可以在 Downloads 选项栏中进行选择。 建议使用python 3.7以上的版本。 开始安装时一定要记得勾选Add Python 3.x to PATH，这样可以免除再手动添加进PATH。 ![](../assets/images/Micropython_operating_env_2.png) 按照安装提示逐步操作即可顺利完成安装 。 ## 安装Thonny IDE 以Windows PowerShell的具体操作步骤为例。 其他系统或安装方法可参考[Thonny官网](https://thonny.org/)上的说明。 右键Windows开始菜单即可看到Windows PowerShell ，单击打开。 ![](../assets/images/Micropython_operating_env_3.png) 我们在此处通过pip来安装Thonny IDE。 pip是 Python 包管理工具，首先要确认pip是否是最新版，直接使用以下命令升级pip： ```shell pip install U pip ``` 使用以下命令安装Thonny： ```shell pip install thonnyapp ``` 如果未来有需要，则可以使用以下命令升级Thonny： ```shell pip install U thonnyapp ``` 用Windows搜索即可快速找到Thonny，也可以在开始菜单栏里找到它。 ![](../assets/images/Micropython_operating_env_4.png) ## 连接开发板至电脑 将开发板通过USB数据线连接至电脑。 正确连接时开发板的电源指示灯会亮起。 我们需要知道开发板是否被电脑识别，并找出连接到了哪一个 COM 口（用于串口通信，下载程序等）。 首先在桌面找到“此电脑”,右键，选择“管理”，打开“设备管理器”，点开“端口（COM 和 LPT）”。 此时会在列表中新加入一个 COM 口（示例图中是 COM21）。 ![](../assets/images/Micropython_operating_env_5.png) ## 烧录MicroPython固件 Leaf S3开发板默认出厂固件是MicroPython，如果您需要烧录固件，可以[参考这里](Firmware.html) ## 配置Thonny IDE 打开Thonny，单击 运行，单击 选择解释器： ![](../assets/images/Micropython_operating_env_9.png) 将解释器设置为 MicroPython(ESP32)： ![](../assets/images/Micropython_operating_env_10.png) 选择开发板的COM口： ![](../assets/images/Micropython_operating_env_11.png) 确认设置后，就在Shell中打开了MicroPython REPL。 ![](../assets/images/Micropython_operating_env_12.png) REPL启动并输出信息即意味着MicroPython固件烧录成功，可以开始正常使用了。 单击 视图，勾选 文件，即可看到本地文件目录和开发板上的文件目录： ![](../assets/images/Micropython_operating_env_13.png) ![](../assets/images/Micropython_operating_env_14.png) 其他视图窗口也可按需设置使用。 在设置中可以选择个人喜欢的主题风格。 ![](../assets/images/Micropython_operating_env_15.png)"},"/Leaf_S3_doc/zh/MicroPython/ESPNOW.html":{"title":"","content":"## 什么是ESP NOW？ ESP NOW 是乐鑫定义的一种无线通信协议，能够在无路由器的情况下直接、快速、低功耗地控制智能设备。它能够与 Wi Fi 和 Bluetooth LE 共存，支持乐鑫 ESP8266、ESP32、ESP32 S 和 ESP32 C 等多系列 SoC。ESP NOW 广泛应用于智能家电、远程控制和传感器等领域。 ESP NOW 是基于数据链路层的无线通信协议，它将五层 OSI 上层协议精简为一层，数据传输时无需依次经过网络层、传输层、会话层、表示层、应用层等复杂的层级，也无需层层增加包头和解包，大大缓解了网络拥挤时因为丢包而导致的卡顿和延迟，拥有更高的响应速度。 ![](../assets/images/espnow model zh min.png) * ESP NOW 可与 Wi Fi、Bluetooth LE 共存，支持乐鑫多系列支持 Wi Fi 功能的 SoC。 * 配对快速且用户友好，支持单对多、多对多设备连接和控制。 * 占用较少的 CPU 和 flash 资源。 * 可以作为独立的辅助模块，为系统提供设备配网、调试和固件升级等功能。 * 基于 ECDH 和 AES 算法保证数据传输具有更高的安全性。 * 新增窗口同步机制，极大地降低了功耗。 MicroPython 已将 ESP NOW 的功能支持合并入GitHub master ，[#6515](https://github.com/micropython/micropython/pull/6515)。 > [MicroPython ESP NOW API 文档](https://docs.micropython.org/en/latest/library/espnow.html) ## 实现一个最简单的无线通信，点亮彩灯 使用两块BPI Leaf S3开发板，一个做为发送端，一个作为接收端，无需提前连接任何wifi。 发送端将在启动后广播一段信息，然后进入循环等待接收一个返回的信息，如果收到一个返回信息则亮一下蓝灯。 接收端将在启动后进入循环接收信息，在接收到信息后打印信息，如果收到信息则亮一下绿灯，并向发送端返回一个信息，然后继续接收信息。 **发送端** ```py import network import espnow import time from neopixel import NeoPixel from machine import Pin np NeoPixel(Pin(48), 25) np[0] (0, 0, 0) np.write() # A WLAN interface must be active to send()/recv() sta network.WLAN(network.STA_IF) sta.active(True) sta.disconnect() e espnow.ESPNow() e.active(True) peer b'\\xbb\\xbb\\xbb\\xbb\\xbb\\xbb' # MAC address of peer's wifi interface e.add_peer(peer) # Must add_peer() before send() e.send(peer, \"Starting...\", True) for i in range(100): e.send(peer, str(i)*20, True) sended e.send(peer, b'end', True) print(sended) while True: host, msg e.recv() if msg: # msg None if timeout in recv() print(host, msg) if msg b'All received.': np[0] (0, 0, 25) np.write() time.sleep(0.5) np[0] (0, 0, 0) np.write() break ``` **接收端** ```py import network import espnow import time from neopixel import NeoPixel from machine import Pin np NeoPixel(Pin(48), 25) np[0] (0, 0, 0) np.write() # A WLAN interface must be active to send()/recv() sta network.WLAN(network.STA_IF) sta.active(True) sta.disconnect() e espnow.ESPNow() e.active(True) while True: host, msg e.recv() if msg: # msg None if timeout in recv() print(host, msg) if msg b'end': try: e.add_peer(host) # Must add_peer() before send() except OSError: pass sended e.send(host, \"All received.\", True) print(sended) np[0] (0, 25, 0) np.write() time.sleep(0.5) np[0] (0, 0, 0) np.write() ```"},"/Leaf_S3_doc/zh/Unboxing/Gettingstart.html":{"title":"Hello World","content":"# Hello World 我们可以从输出一段“Hello World”文字开始，以此作为了解和学习MicroPython的第一步。 > 本文所述操作基于Thonny IDE，需要先完成对Thonny IDE的配置，与开发板建立连接。[Thonny IDE运行环境搭建可以参考这里](../Programming/Environment.html)。 ## 使用REPL **REPL**即**Read Eval Print Loop**的缩写名词，译为 **读取 求值 输出 循环**。 我们可以通过实际操作来明白它的意思。 将已经安装了MicroPython固件的开发板连接电脑，运行Thonny IDE并正确配置后，在Shell窗口中将出现这样的文本内容： ``` MicroPython v1.17 on 2022 01 09; ESP32S3 module with ESP32S3 Type \"help()\" for more information. >>> ``` 注意最后一行的`>>>`提示符，我们可以直接在这后面输入算式或是代码，按下键盘`enter`回车键就会立即在下一行得到输出结果。 ```python >>> 1+2 3 >>> print(\"Hello World\") Hello World >>> ``` 现在可以很直观的理解了，它会读取我们输入的信息，执行运算求值，输出结果，然后等待我们后续的输入，一直循环这个过程，这也是**REPL**又被译为**交互式解释器**的原因，我们可以直接通过输入代码来和硬件交互，没有像传统的C语言那样需要在中间执行编译的过程，我们输入的信息没有经过编译就传输给芯片自行解释并运行了，这本是Python语言的一大重要特性，MicroPython完美继承了它。 如果仅仅是使用MicroPython REPL，很多具有串口信息收发功能的软件都可以操作，感兴趣的话可以试试各种串口工具，这可以令人更深刻的理解 “没有中间执行编译的过程” 的意思。 >关于REPL的应用，更详尽全面的内容可以参考[MicroPython文档：REPL](https://docs.micropython.org/en/latest/reference/repl.html) ## 代码编辑器 Thonny IDE当然不仅仅可以进行REPL的操作，作为python代码编辑器，本职功能还是有的。 新建一个文件并在其编辑区内输入代码。 ```python print(1+2) print(\"Hello World\") ``` 完成代码编辑后，点击**保存**，可以选择将文件保存到MicroPython设备中，这将直接将整个文件的数据传输到flash中。可将文件命名为`main.py`，设备会在每次上电或复位后执行有这个文件名的程序，而其他名称的文件仅在被`main.py`调用时或是我们在Thonny中点击**运行**时被执行。 ![](../assets/images/Quick_Start.png) 现在点击**运行**，同样是无需编译的，在Shell中会立即得到结果。 ``` 3 Hello World ``` 另外也可以尝试REPL的键盘控制快捷键**ctrl+D**软件复位，可以看到复位后程序立即执行并打印出信息。"},"/Leaf_S3_doc/zh/Unboxing/Introduction.html":{"title":"【 开发板介绍 】","content":"# 【 开发板介绍 】 BPI Leaf S3板载ESP32 S3芯片，支持 2.4 GHz Wi Fi 和低功耗蓝牙 (Bluetooth® LE) 双模无线通信。板子支持USB和外接3.7V锂电池两种供电方式，可实现双电源下自动切换电源功能，并支持USB充电方式。体积小巧，接口方便，上手简单，可直接应用于物联网低功耗项目。 BPI Leaf S3开发板在软件方面支持ESP IDF、Arduino、MicroPython等多种方式进行编程开发 。 BPI Leaf S3开发板上标记了与芯片对应的所有IO管脚，且IO管脚顺序与Espressif ESP32 S3 DevKitC 1开发板一致，开发者可根据实际需求，可将DevKitC 1支持的外围设备添加到BPI Leaf S3上，也可将开发板插在面包板上使用。 ## 关键特性 ESP32 S3，Xtensa® 32 bit LX7 片上外设 PSRAM , 片外 FLASH Ultra low power 10uA 2.4G WIFI ，Bluetooth 5 ，Bluetooth mesh GPIO , ADC , TOUCH , PWM , I2C , SPI , RMT , I2S , UART , LCD，CAMERA ，USB , JTAG 1 * 4pin I2C连接座 1 * USB Type C 1 * 2pin 电池连接座，支持充电 1 * 全彩色LED ## 硬件 ### 接口示意图 ![](../assets/images/Leaf S3_board.png) ### 硬件规格 <table> <tr> <td>BPI Leaf S3 规格表</td> </tr> <tr> <td>SoC主控芯片</td> <td>ESP32 S3，Xtensa® 32 位 LX7 双核处理器</td> </tr> <tr> <td>主频</td> <td>240MHz MAX</td> </tr> <tr> <td>工作温度</td> <td> 40℃~+85℃</td> </tr> <tr> <td>片上 ROM</td> <td>384 KB</td> </tr> <tr> <td>片上 SRAM</td> <td>320 KB</td> </tr> <tr> <td>片外 FLASH ROM</td> <td>8MB</td> </tr> <tr> <td>片上外设 PSRAM</td> <td>2MB</td> </tr> <tr> <td>WIFI</td> <td>IEEE 802.11 b/g/n ，2.4Ghz频带，150Mbps</td> </tr> <tr> <td>蓝牙</td> <td>Bluetooth 5 ，Bluetooth mesh</td> </tr> <tr> <td>GPIO</td> <td>BPI Leaf S3已引出36个可用GPIO</td> </tr> <tr> <td>ADC</td> <td>2 × 12 位 SAR ADC，支持 20 个模拟通道输入</td> </tr> <tr> <td>TOUCH 电容式触摸传感器</td> <td>14</td> </tr> <tr> <td>SPI</td> <td>4</td> </tr> <tr> <td>I2C</td> <td>2，支持主机或从机模式</td> </tr> <tr> <td>I2S</td> <td>2，串行立体声数据的输入输出</td> </tr> <tr> <td>LCD</td> <td>1，支持 8 位 ~16 位并行 RGB、I8080、MOTO6800 接口</td> </tr> <tr> <td>CAMERA</td> <td>1，支持 8 位 ~16 位 DVP 图像传感器接口</td> </tr> <tr> <td>UART</td> <td>3 ，支持异步通信（RS232 和RS485）和 IrDA</td> </tr> <tr> <td>PWM</td> <td>8 路独立通道，14位精度</td> </tr> <tr> <td>MCPWM</td> <td>2</td> </tr> <tr> <td>USB</td> <td>1 × 全速USB 2.0 OTG，Type C母口</td> </tr> <tr> <td>USB Serial/JTAG 控制器</td> <td>1，USB 全速标准，CDC ACM ，JTAG</td> </tr> <tr> <td>温度传感器</td> <td>1，测量范围为–20 °C 到 110 °C，用于监测芯片内部温度</td> </tr> <tr> <td>SD/MMC</td> <td>1 × SDIO主机接口，具有2个卡槽，支持SD卡3.0和3.01，SDIO 3.0，CE ATA 1.1，MMC 4.41，eMMC 4.5和4.51</td> </tr> <tr> <td>TWAI® 控制器</td> <td>1 ，兼容 ISO11898 1（CAN 规范 2.0）</td> </tr> <tr> <td>通用 DMA 控制器</td> <td>5 个接收通道和 5 个发送通道</td> </tr> <tr> <td>RMT</td> <td>4 通道发射，4通道接收，共享 384 x 32 bit 的 RAM</td> </tr> <tr> <td>脉冲计数器</td> <td>4个脉冲计数控制器（单元），每个单元有2个独立的通道</td> </tr> <tr> <td>定时器</td> <td>4 × 54 位通用定时器，16 位时钟预分频器，1 × 52 位系统定时器，3 × 看门狗定时器</td> </tr> <tr> <td>外部晶振</td> <td>40Mhz</td> </tr> <tr> <td>RTC 和低功耗管理</td> <td>电源管理单元 (PMU)+ 超低功耗协处理器 (ULP)</td> </tr> <tr> <td>低功耗电流</td> <td>10uA</td> </tr> <tr> <td>工作电压</td> <td>3.3V</td> </tr> <tr> <td>输入电压</td> <td>3.3V~5.5V</td> </tr> <tr> <td>最大放电电流</td> <td>2A@3.3V DC/DC</td> </tr> <tr> <td>USB充电</td> <td>支持</td> </tr> <tr> <td>最大充电电流</td> <td>500mA</td> </tr> <tr> <td>可控全彩色LED</td> <td>1</td> </tr> </table> ### 硬件尺寸 ![](../assets/images/Leaf S3_board_dimension.png) <table> <tr> <td>BPI Leaf S3 尺寸表</td> </tr> <tr> <td>管脚间距</td> <td>2.54mm</td> </tr> <tr> <td>安装孔间距</td> <td>23mm/ 62.25mm</td> </tr> <tr> <td>安装孔尺寸</td> <td>内径2mm/外径3mm</td> </tr> <tr> <td>主板尺寸</td> <td>26 × 65.25(mm)/1.02 x 2.57(inches)</td> </tr> <tr> <td>板厚</td> <td>1.2mm</td> </tr> <tr> <td></td> </tr> </table> 管脚间距兼容万能板（洞洞板、点阵板），面包板，便于调试应用。 ## 资料与资源 [GitHub: BPI Leaf S3 开发板原理图PDF](https://github.com/BPI STEAM/BPI Leaf S3 Doc/blob/main/sch/BPI Leaf S3 Chip V0.1A.pdf) [ESP32 S3 技术规格书](https://www.espressif.com/sites/default/files/documentation/esp32 s3_datasheet_cn.pdf) [ESP32 S3 技术参考手册](https://www.espressif.com/sites/default/files/documentation/esp32 s3_technical_reference_manual_cn.pdf)"},"/Leaf_S3_doc/zh/Arduino/Basic.html":{"title":"板载资源的使用","content":"# 板载资源的使用 本章主要是通过一些示例项目，阐述 Leaf S3 主控板的外设基本使用方法，通过下面的项目，您可以进行修改完成您的自己的项目。 其中 Leaf S3 外设主要包括：UART、I2C、SPI、ADC、PWM、DAC等。 ## 开始之前的准备 BPI Leaf S3 开发板上的typec使用的是ESP32 S3的原生USB接口，而不是传统的USB转TLL芯片。 为了让您的开发板能正确下载程序，您需要将BPI Leaf S3设置为下载模式，有以下两种方法： 通过USB连接到电脑，按下BOOT键，再按一下Reset键并松开，最后松开BOOT键。 在断开所有供电的状态下，按住BOOT键，然后将开发板插上电脑，最后松开BOOT键。 这时候可以在设备管理器中看到一个多的COM口 ![](../assets/images/Device_manager.jpg) 在IDE中选择这个端口 ![](../assets/images/Device_manager_1.jpg) ## 项目一 串口实验 在最开始的章节中，我们上传了一个 Blink 闪烁程序来测试板子上的 LED 状态灯。现在，我们使用 UART 串口，每秒打印一次计时数据。 ### 串口实验:所需元件 Leaf S3 主板 X 1 ![](../assets/images/Leaf S3.png) ### 串口实验:硬件连接 此项目不需要其他传感器，所以只需要把Leaf S3用USB连到电脑就能用。 ### 串口实验:代码 打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。 代码如下: <details> <summary>展开查看</summary> <pre><code> void setup() { Serial.begin(115200); //设置串口通信波特率 } void loop() { static unsigned long i 0; //定义变量i Serial.println(i++); //i加一后输出i delay(1000); //延时1秒 } </code></pre> </details> 输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后 IDE 会把代码发送给 Leaf S3 主板。上传完成之后，你需要按一下复位键，这样代码就能正常运行了 ### 串口实验:实验现象 完成之前步骤的上传后，打开 Arduino IDE 自带的串口监视器，可以看到如下的打印信息： ![](../assets/images/Lesson1 1.png) ## 项目二 PWM(呼吸灯) 呼吸灯，即让 Leaf S3 通过 PWM 驱动 LED 灯，实现 LED 的亮度渐变，看起来就像是在呼吸一样。关于 PWM 的解释，请阅览知识扩展部分。 ### PWM实验：所需元件 Leaf S3 主板 X 1 ![](../assets/images/Leaf S3.png) LED X 1 (建议串联一个电阻限流) ![](../assets/images/led.png) ### PWM实验：硬件连接 将LED连接到Leaf S3的GPIO13就可以了，长的那个脚接GPIO13，短的接到GND ### PWM实验：代码 打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。 代码如下: <details> <summary>展开查看</summary> <pre><code> #define LED_CHANNEL_0 0 //设置通道0 #define LED_TIMER_13_BIT 13 //设置13位定时器 #define LED_BASE_FREQ 5000 //设置定时器频率位5000Hz #define LED_PIN 13 //设置LED灯 int brightness 0; // LED亮度 int fadeAmount 1; // LED数量 //设置led灯的亮度 void ledcAnalogWrite(uint32_t value, uint32_t valueMax 255) { //计算占空比 uint32_t duty (LED_BASE_FREQ / valueMax) * min(value, valueMax); //设置占空比 ledcWrite(LED_CHANNEL_0, duty); } void setup() { ledcSetup(LED_CHANNEL_0, LED_BASE_FREQ, LED_TIMER_13_BIT); ledcAttachPin(LED_PIN, LED_CHANNEL_0); } void loop() { ledcAnalogWrite(brightness); brightness + fadeAmount; if (brightness < 0 brightness > 255) { fadeAmount fadeAmount; } delay(30); } </code></pre> </details> 输入完成后，点击“编译”按钮检查代码是否有错误。确定没有错误后可以开始上传了，点击“上传”按钮 。IDE 会把代码发送给 Leaf S3 主板。上传完成后您就可以看见Type C旁边的LED 灯开始“呼吸”了！ 现在让我们来回顾一下代码和硬件，看看它是如何工作。 ### PWM实验：相关知识 什么是 PWM 控制信号？ PWM（pulse width modulation）脉冲宽度调制，MCU（微控制器）通过对开关器件的通断进行控制，使输出端得到一系列幅值相等的脉冲，用这些脉冲来代替正弦波或所需的波形。如下图所示： ![](../assets/images/Lesson2 1.jpg) 其中，tON 是高电平持续时间，tPWM 是 PWM 波的周期，tPWM tON 是低电平持续时间，占空比是指高电平持续时间占整个周期的比例，即 D ton/tPWM 。 ### PWM实验：代码分析 Leaf S3 的 PWM 比普通的 Arduino UNO 高级的多，设置上不能简单的使用analogWrite 函数来驱动 PWM，而是需要设置 timer 函数，以及相关的频率参数等才能工作。 ``` #define LEDC_CHANNEL_0 0 ``` 定义了定时器使用的通道，Leaf S3 总共有 16 个通道，这里用的是通道 0。 ``` #define LEDC_TIMER_13_BIT 13 ``` 定义了定时器为 13 位定时器，即定时器最大计数为 2 的 13 次方。 ``` #define LEDC_BASE_FREQ 5000 ``` 这是设置定时器的频率，单位是 Hz。接下来的 brightness 和 fadeAmount 参数分别表示 PWM 的占空比和每次变化的数值。 ``` void ledcAnalogWrite(uint32_t value, uint32_t valueMax 255) ``` 这个函数是计算 PWM 占空比和设置 PWM 占空比，类似 Arduino 的 analogWrite 函数，可以看到，传递参数的最大值是 255，这是为了和 analogWrite 兼容。 ``` ledcSetup(LEDC_CHANNEL_0, LEDC_BASE_FREQ, LEDC_TIMER_13_BIT); \t ledcAttachPin(LED_PIN, LEDC_CHANNEL_0); ``` 这两个函数是 Leaf S3 定时器设置函数，函数原型及原理这里不讲述，如果您感兴趣可以看看底层源码（源码地址：C:\\Users\\“your PC”\\AppData\\Local\\Arduino15\\packages\\esp32\\ hardware\\ adafruit_metro_esp32s2 \\0.0.3\\libraries\\ESP32\\），这里只需要知道怎么用这些函数来设置相关的 timer 就可以了。 关于什么是 PWM 信号，在前面已经阐述过了，这里不再说明。 >注意：Leaf S3 的任何引脚都可以配置成 PWM 输出，您可以尝试着修改代码，完成您的项目。 ## 项目三 ADC ADC（模数转换器即 A/D 转换器），是指将模拟信号转变成数字信号。Leaf S3 的ADC 是13位的，最大输出值为 8191，而 Arduino UNO 是 10 位的，最大输出值是 1023，因此，在精度上比Arduino UNO 要高，而且转换速率快，且在使用上兼容 Arduino analogRead 函数，直接读取即可。 ### ADC实验：所需元件 模拟角度传感器 X 1 ![](../assets/images/Lesson3 1.png) 面包板 X 1 ![](../assets/images/Lesson3 2.png) Leaf S3 主板 X 1 ![](../assets/images/Leaf S3.png) ### ADC实验：硬件连接 把 电位计插接到 Leaf S3 主板上，然后将模拟角度传感器插接到 IO2（实验中用的是IO2）。 元件连接好后，使用 USB 线连接 Leaf S3 和电脑。 ### ADC实验：代码 打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。代码如下: <details> <summary>展开查看</summary> <pre><code> void setup() { // put your setup code here, to run once: Serial.begin(115200); } void loop() { // put your main code here, to run repeatedly: Serial.println(analogRead(2)); delay(100); } </code></pre> </details> 输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后IDE 会把代码发送给 Leaf S3 主板。上传完成后，打开 Arduino IDE 的串口监视器，旋转模拟角度传感器，可以看到串口监视器中的数值变化，如下图所示： ![](../assets/images/Lesson3 3.png) ### ADC实验：代码分析 由于Leaf S3 的 ADC 在使用上完全兼容 Arduino，因此这里不再对analogRead 函数进行过多的讲解。 注意：如果您对 Arduino 的基本函数不是特别熟悉，您可以[点击链接](https://www.arduino.cc/en/Tutorial/BuiltInExamples)进行学习。 ## 项目四 I2C Leaf S3 的 I2C 可以配置到任意 I/O 口，您可以通过传递相关参数进行配置。为了方便使用，我们已经将 I2C 进行了默认配置，在使用上完全兼容 Arduino，默认配置引脚可以在第一章简介中查看到。本项目是基于 I2C 默认配置，驱动 OLED 显示屏。 所需元件 I2C OLED 12864 显示屏 X 1 ![](../assets/images/Lesson4 1.png) 面包板 X 1 ![](../assets/images/Lesson3 2.png) Leaf S3 主板 X 1 ![](../assets/images/Leaf S3.png) ### I2C实验：硬件连接 把Leaf S3 主板插到面包板上，然后将 OLED显示屏插接到 I2C 接口。（SDA是33，SCL是34）元件连接好后，使用 USB 线连接 Leaf S3 和电脑。 ### I2C实验：代码 打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。代码如下: <details> <summary>展开查看</summary> <pre><code> #include <Wire.h> int UG2864Address 0x3C;//OLED UG2864器件7位地址 prog_char F8X16[][16] PROGMEM { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,// 0 0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00,//!1 0x00,0x10,0x0C,0x06,0x10,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//\"2 0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00,//#3 0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00,//$4 0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00,//%5 0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10,//&6 0x10,0x16,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//'7 0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00,//(8 0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00,//)9 0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00,//*10 0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00,//+11 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00,0x00,0x00,//,12 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,// 13 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00,//.14 0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00,///15 0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00,//016 0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//117 0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00,//218 0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00,//319 0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00,//420 0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00,//521 0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00,//622 0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00,//723 0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00,//824 0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00,//925 0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,//:26 0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x60,0x00,0x00,0x00,0x00,//;27 0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00,//<28 0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,// 29 0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00,//>30 0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00,//?31 0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00,//@32 0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20,//A33 0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00,//B34 0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00,//C35 0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00,//D36 0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00,//E37 0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00,//F38 0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00,//G39 0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20,//H40 0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//I41 0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00,//J42 0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00,//K43 0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00,//L44 0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00,//M45 0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00,//N46 0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00,//O47 0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00,//P48 0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00,//Q49 0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20,//R50 0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00,//S51 0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//T52 0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//U53 0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00,//V54 0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00,//W55 0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20,//X56 0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//Y57 0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00,//Z58 0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00,//[59 0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00,//\\60 0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00,//]61 0x00,0x00,0x04,0x02,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//^62 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,//_63 0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//`64 0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20,//a65 0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00,//b66 0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00,//c67 0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20,//d68 0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00,//e69 0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//f70 0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00,//g71 0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//h72 0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//i73 0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,//j74 0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00,//k75 0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//l76 0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F,//m77 0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//n78 0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//o79 0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00,//p80 0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80,//q81 0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00,//r82 0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00,//s83 0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00,//t84 0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20,//u85 0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00,//v86 0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00,//w87 0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00,//x88 0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00,//y89 0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00,//z90 0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40,//{91 0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,//92 0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00,//}93 0x00,0x06,0x01,0x01,0x02,0x02,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//~94 }; char ch_buf[17] {0}; int RES 6;//Gadgeteer PIN6 int DC 7;//Gadgeteer PIN3 void Writec(unsigned char COM) { Wire.beginTransmission(UG2864Address); Wire.write(0x00); Wire.write(COM); Wire.endTransmission(); } void Writed(unsigned char DATA) { Wire.beginTransmission(UG2864Address); Wire.write(0x40); Wire.write(DATA); Wire.endTransmission(); } void SSD1306() { Writec(0XAE);//display off Writec(0X00);//set lower column address Writec(0X10);//set higher column address Writec(0X40);//set display start line Writec(0XB0);//set page address Writec(0X81);//set contract control Writec(0XCF);// VCC Generated by Internal DC/DC Circuit Writec(0XA0);//set segment remap column address 127 is mapped to SEG0 Writec(0XA6);//normal / reverse normal display Writec(0XA8);//multiplex ratio Writec(0X3F);//1/64 Writec(0XC0);//Com scan direction remapped mode. Scan from COM[N 1] to COM0 Writec(0XD3);//set display offset Writec(0X00); Writec(0XD5);//set osc division Writec(0X80); Writec(0XD9);//set pre charge period Writec(0X11); Writec(0XDa);//set COM pins Writec(0X12); Writec(0X8d);/*set charge pump enable*/ Writec(0X14); Writec(0Xdb);//Set VcomH Writec(0X20); Writec(0XAF);//display ON } void fill(unsigned char dat) { unsigned char i,j; Writec(0x00);//set lower column address Writec(0x10);//set higher column address Writec(0xB0);//set page address for(j 0;j<8;j++) { Writec(0xB0+j);//set page address Writec(0x00);//set lower column address Writec(0x10);//set higher column address for(i 0;i<128;i++) { Writed(dat); } } } void show_string(unsigned char x,unsigned char y,char *s) { unsigned char i,j,lower,higher; char *t; t s; lower y%16; higher y/16; if((x>3) (y>120)) return; Writec(0xB0+x*2);//set page address Writec(lower);//set lower column address Writec(0x10+higher);//set higher column address for(j 0;*s! '\\0';j++) { for(i 0;i<8;i++){ ch_buf[i] pgm_read_word(&F8X16[*s 32][i]); } for(i 0;i<8;i++) Writed(ch_buf[i]); s++; } Writec(0xB0+x*2+1);//set page address Writec(lower);//set lower column address Writec(0x10+higher);//set higher column address s t; for(j 0;*s! '\\0';j++) { for(i 0;i<8;i++){ ch_buf[i] pgm_read_word(&F8X16[*s 32][i+8]); } for(i 0;i<8;i++) Writed(ch_buf[i]); s++; } } void oled_init(void) { pinMode(RES,OUTPUT);//RES pinMode(DC,OUTPUT);//D/C# digitalWrite(DC,LOW); Wire.begin(); digitalWrite(RES,HIGH); delay(100); digitalWrite(RES,LOW); delay(100); digitalWrite(RES,HIGH); delay(100); SSD1306(); fill(0x00); } void setup() { oled_init(); } void loop() { fill(0x00); show_string(0,12,\"BananaPi\"); show_string(2,12,\"banana pi.org\"); while(1); } </code></pre> </details> 输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后 IDE \t会把代码发送给 Leaf S3 主板。上传完成后，OLED 显示屏会显示“BananaPi banana pi.org”字样。 ### I2C实验：代码分析 本项目的代码相对于前面的项目较多，主要是基于 I2C 通信对 OLED 显示屏底层寄存器的直接驱动。 ``` void Writec(unsigned char COM) ``` 设置寄存器函数，通过 I2C 对 OLED 显示屏设置，I2C 使用方法完全兼容 Arduino。 ``` void Writed(unsigned char DATA) ``` 写数据函数，I2C 使用方法完全兼容 Arduino。 >注意：Leaf S3 的 I2C 与 Arduino 完全兼容，主要是调用 Wire 库文件使用。 ## 项目五 SPI 在很多传感器中，都使用 SPI 通信，因为 SPI 通信速率相对于 I2C 更快，没有地址冲突的弊端。SPI，是 一种高速的、全双工、同步的通信总线，而 Leaf S3 的 SPI 可以配置到所有 I/O，您可以阅览底层 代码进行使用（初学者不建议使用）。为了更好的使用体验，Leaf S3 默认情况下配置了IO35、IO36、IO37 为 SPI 口，在使用上则完全兼容 Arduino。 本项目使用 Leaf S3，通过 SPI 读取 BME280 温湿度传感器的数据，示例中使用的是BME280 库文件，关于 SPI 驱动您可以阅览 BEM280 库文件，[点击链接](https://github.com/DFRobot/DFRobot_BME280)下载 BME280 库文件。 ### SPI实验：所需元件 BME280 温湿度传感器 X 1 ![](../assets/images/Lesson5 1.png) >注意：BME280 传感器本身支持 I2C 和 SPI 通信，这里我们采用 SPI 通信。 面包板 X 1 ![](../assets/images/Lesson3 2.png) Leaf S3 主板 X 1 ![](../assets/images/Leaf S3.png) ### SPI实验：代码 打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。 （这个程序需要DFRobot_BME280库，需要在[GitHub](https://github.com/DFRobot/DFRobot_BME280)下载，解压到Arduino\\ Library 文件夹下 ）代码如下： <details> <summary>展开查看</summary> <pre><code> /*! * read_data_spi.ino * * Download this demo to test read data from bme280, connect sensor through spi interface * Connect cs pin to io 2 * Data will print on your serial monitor * * Copyright [DFRobot](http://www.dfrobot.com), 2016 * Copyright GNU Lesser General Public License * * version V1.0 * date 12/03/2019 */ #include \"DFRobot_BME280.h\" #include \"Wire.h\" typedef DFRobot_BME280_SPI BME; // ******** use abbreviations instead of full names ******** # define PIN_CS 2 BME bme(&SPI, PIN_CS); // select TwoWire peripheral and set cs pin id #define SEA_LEVEL_PRESSURE 1015.0f // show last sensor operate status void printLastOperateStatus(BME::eStatus_t eStatus) { switch(eStatus) { case BME::eStatusOK: Serial.println(\"everything ok\"); break; case BME::eStatusErr: Serial.println(\"unknow error\"); break; case BME::eStatusErrDeviceNotDetected: Serial.println(\"device not detected\"); break; case BME::eStatusErrParameter: Serial.println(\"parameter error\"); break; default: Serial.println(\"unknow status\"); break; } } void setup() { Serial.begin(115200); bme.reset(); Serial.println(\"bme read data test\"); while(bme.begin() ! BME::eStatusOK) { Serial.println(\"bme begin faild\"); printLastOperateStatus(bme.lastOperateStatus); delay(2000); } Serial.println(\"bme begin success\"); delay(100); } void loop() { float temp bme.getTemperature(); uint32_t press bme.getPressure(); float alti bme.calAltitude(SEA_LEVEL_PRESSURE, press); float humi bme.getHumidity(); Serial.println(); Serial.println(\" start print \"); Serial.print(\"temperature (unit Celsius): \"); Serial.println(temp); Serial.print(\"pressure (unit pa): \"); Serial.println(press); Serial.print(\"altitude (unit meter): \"); Serial.println(alti); Serial.print(\"humidity (unit percent): \"); Serial.println(humi); Serial.println(\" end print \"); delay(1000); } </code></pre> </details> 输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后 IDE 会把代码发送给 Leaf S3 主板。打开 Arduino 串口监视器，可以看到打印信息如下： ![](../assets/images/Lesson5 2.png) ### SPI实验：代码分析 本项目采用的是 BME280 库文件，在 Item 5.ino 文件中并没有对 SPI 底层进行操作，不过，Leaf ESP32 S3 的 SPI 使用完全兼容 Arduino。 ## 项目六 WS2812 Leaf S3 集成了一个型号为WS2812的RGB彩灯。 本项目是点亮 Leaf S3 的RGB彩灯的实验， ### WS2812实验：所需元件 Leaf S3 主板 X 1 ![](../assets/images/Leaf S3.png) >注意：该项目不需要连接其他传感器。 ### WS2812实验：代码 打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。 （这个程序需要Adafruit_NeoPixel库，需要在[GitHub](https://github.com/adafruit/Adafruit_NeoPixel)下载，解压到Arduino\\ Library 文件夹下）代码如下: <details> <summary>展开查看</summary> <pre><code> // NeoPixel Ring simple sketch (c) 2013 Shae Erisson // Released under the GPLv3 license to match the rest of the // Adafruit NeoPixel library #include <Adafruit_NeoPixel.h> #ifdef __AVR__ #include <avr/power.h> // Required for 16 MHz Adafruit Trinket #endif // Which pin on the Arduino is connected to the NeoPixels? #define PIN 48 // On Trinket or Gemma, suggest changing this to 1 // How many NeoPixels are attached to the Arduino? #define NUMPIXELS 1 // Popular NeoPixel ring size // When setting up the NeoPixel library, we tell it how many pixels, // and which pin to use to send signals. Note that for older NeoPixel // strips you might need to change the third parameter see the // strandtest example for more information on possible values. Adafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800); #define DELAYVAL 500 // Time (in milliseconds) to pause between pixels void setup() { // These lines are specifically to support the Adafruit Trinket 5V 16 MHz. // Any other board, you can remove this part (but no harm leaving it): #if defined(__AVR_ATtiny85__) && (F_CPU 16000000) clock_prescale_set(clock_div_1); #endif // END of Trinket specific code. pixels.begin(); // INITIALIZE NeoPixel strip object (REQUIRED) } void loop() { pixels.clear(); // Set all pixel colors to 'off' // The first NeoPixel in a strand is #0, second is 1, all the way up // to the count of pixels minus one. for(int i 0; i < NUMPIXELS; i++) { // For each pixel... // pixels.Color() takes RGB values, from 0,0,0 up to 255,255,255 // Here we're using a moderately bright green color: pixels.setPixelColor(i, pixels.Color(0, 150, 0)); pixels.show(); // Send the updated pixel colors to the hardware. delay(DELAYVAL); // Pause before next pass through loop } } </code></pre> </details> 输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后 IDE 会把代码发送给 Leaf S3 主板。复位后WS2812灯会开始亮绿灯， >注意：如果需要其他颜色，可以修改代码中的RGB值。 ### WS2812实验：代码分析 本项目使用 Leaf S3 集成的WS2812灯，默认GPIO是48。 ``` #define PIN 48 ``` 设置GPIO引脚号 ``` #define NUMPIXELS 1 ``` 设置灯的个数，如果您想连接更多WS2812，可以换一个IO，并修改灯的数量。 ## 项目七 触摸传感器 Leaf S3 提供了多达 10 个电容式传感器 GPIO，能够探测由手指或其他物品直接接触或接近而产生的电容差异。这种低噪声特性和电路的高灵敏度设计适用于较小的触摸板，可以直接用于触摸开关。本项目阐述了如何通过Arduino 代码获取 Leaf S3 的触摸传感器状态，并打印状态。 ### 触摸实验：所需元件 Leaf S3 主板 X 1 ![](../assets/images/Leaf S3.png) >注意：该项目不需要连接其他传感器。 ### 触摸实验：代码 打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。 代码如下: <details> <summary>展开查看</summary> <pre><code> void setup() { Serial.begin(115200); delay(1000); // give me time to bring up serial monitor Serial.println(\"Leaf S3 Touch Test\"); } void loop(){ Serial.println(touchRead(T2)); // get value using T0 >D9 delay(100); } </code></pre> </details> 输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后 IDE 会把代码发送给 Leaf S3 主板。打开 Arduino IDE 串口监视器，并用手触摸 GPIO2（T2 对应的是GPIO2），可以看到会打印出的数据突然变小，如下图所示： ![](../assets/images/Lesson8 1.png) ### 触摸实验：代码分析 获取触摸传感器的 GPIO 状态，只需要调用 touchRead 函数，函数原型如下： ``` uint16_t touchRead(uint8_t pin) ``` 返回“0”表示没有触摸，“1”表示触摸。其中 pin 是 T0~T9，对应到 Leaf 的引脚如下表所示： <table> <tr> <td></td> </tr> <tr> <td>触摸传感器序号 </td> <td>对应的 ESP32 硬件 </td> <td>Leaf S3</td> <td> </td> </tr> <tr> <td>T1</td> <td>GPIO1</td> <td>IO1</td> </tr> <tr> <td>T2 </td> <td>GPIO2 </td> <td>IO2</td> </tr> <tr> <td>T3 </td> <td>GPIO3</td> <td>IO3</td> </tr> <tr> <td>T4 </td> <td>GPIO4</td> <td>IO4</td> </tr> <tr> <td>T5 </td> <td>GPIO5</td> <td>IO5</td> </tr> <tr> <td>T6 </td> <td>GPIO6</td> <td>IO6</td> </tr> <tr> <td>T7 </td> <td>GPIO7</td> <td>IO7</td> </tr> <tr> <td>T8 </td> <td>GPIO8</td> <td>IO8</td> </tr> <tr> <td>T9 </td> <td>GPIO9</td> <td>IO9</td> </tr> <tr> <td>T10</td> <td>GPIO10</td> <td>IO10</td> </tr> <tr> <td>T11</td> <td>GPIO11</td> <td>IO11</td> </tr> <tr> <td>T12</td> <td>GPIO12</td> <td>IO12</td> </tr> <tr> <td>T13</td> <td>GPIO13</td> <td>IO13</td> </tr> <tr> <td>T14</td> <td>GPIO14</td> <td>IO14</td> </tr> <tr> <td></td> </tr> </table>"},"/Leaf_S3_doc/zh/Arduino/Environment.html":{"title":"环境搭建","content":"# 环境搭建 这篇文章将会指引您安装Leaf S3的Arduino支持。 ![](../assets/images/logo_arduino.png) > 参考[arduino esp32 DOC Getting Started » Installing](https://docs.espressif.com/projects/arduino esp32/en/latest/installing.html) ## 使用Arduino IDE安装支持 这是直接从 Arduino IDE 安装 Arduino ESP32 的方法。 > 从 Arduino IDE 版本 1.6.4 开始，Arduino 允许使用 Boards Manager（开发板管理器）安装第三方平台包。有适用于 Windows、macOS 和 Linux 的软件包。 Arduino IDE 下载地址：https://www.arduino.cc/en/software > Arduino IDE 2.0与Arduino IDE 1.8.x的UI有些许差异，本文基于1.8.13版本编写，但不影响使用2.0版本的用户参考。 要使用 Boards Managaer（开发板管理器）安装esp32平台包，请执行以下步骤： 安装当前上游 Arduino IDE 1.8 或更高版本。 启动 Arduino 并打开 File（文件）> Preferences（首选项）窗口，找到Additional Board Manager URLs（附加开发板管理器网址）。 ![](../assets/images/install_guide_preferences.png) 稳定版链接： ``` https://raw.githubusercontent.com/espressif/arduino esp32/gh pages/package_esp32_index.json ``` 开发版链接： ``` https://raw.githubusercontent.com/espressif/arduino esp32/gh pages/package_esp32_dev_index.json ``` 在Additional Board Manager URLs后面输入上述发布链接之一。您可以添加多个 URL，一行一个。 ![](../assets/images/install_guide_boards_manager_url.png) 从菜单打开 Tools（工具） > Board（开发板）> Board Manager（开发板管理器） 搜索并安装esp32平台。 ![](../assets/images/install_guide_boards_manager_esp32.png) 重启arduino IDE之后可以看到在开发板选项中多了ESP32 Arduino选项。 选择 `ESP32S3 Dev Module` 这个型号，再参照下图所示的内容进行配置一遍即可，配置不当是无法使用的，请一定要参照下图所示的内容进行配置！ ![](../assets/images/Board_chose.jpg) # 从GitHub下载或克隆arduino esp32仓库，手动安装 > 仅限Windows系统。 > 2022/10/26 master分支已合并BPI Leaf S3板型，预计年底更新后可以直接从Board Manager中添加并使用此板形。 打开GitHub页面：https://github.com/espressif/arduino esp32 点击`Code`按钮,点击`Download ZIP`即可用最简单的方式将仓库下载到本地，建议初学者使用此方法。 ![](../assets/images/arduino esp32_download_zip.png) 也可通过GitHub Desktop或Git克隆master分支到本地。 [安装和配置GitHub Desktop](https://docs.github.com/cn/desktop/installing and configuring github desktop) [git 中文手册](https://git scm.com/book/zh/v2) 解压zip文件到Arduino IDE安装路径的`/hardware/espressif/`路径中，将解压出的文件夹重命名为`esp32`。 ![](../assets/images/arduino esp32_unzip.png) 打开 `/hardware/espressif/esp32/tools`路径， 并双击运行` get.exe` 。 ![](../assets/images/win gui 4.png) `get.exe` 完成后，您应该会在目录中看到以下文件。 ![](../assets/images/win gui 5.png) 重启arduino IDE之后可以看到在开发板选项中多了ESP32 Arduino选项。 ![](../assets/images/arduino esp32_leaf_s3.png)"},"/Leaf_S3_doc/zh/index.html":{"title":"【 BPI-Leaf-S3 开发板 】","content":"# 【 BPI Leaf S3 开发板 】 ## 介绍 ![](assets/images/BPI Leaf S3.jpg) 香蕉派Leaf系列是专为物联网设计的低功耗微控制器开发板。 BPI Leaf S3板载ESP32 S3芯片，支持 2.4 GHz Wi Fi 和低功耗蓝牙 (Bluetooth® LE) 双模无线通信，外围兼容低功耗硬件设计，深度睡眠模式下功耗仅为10uA。 ## 使用 MicroPython 编程 MicroPython实现了大部分Python 3 特性和语法，易学易上手，验证程序效果无需编译直接下载进芯片运行。 无论是否有编程基础，MicroPython的上手难度绝对远低于其他编程语言，其代码易读性高，且开源社区有多年积累的丰富资源，就如同Python一样拥有极强的生命力与应用价值。 通过烧写 MicroPython 固件，就可以在开发板中使用 Python 语言进行编程。 ![](assets/images/Mircopython.png) ## 使用 Arduino 编程 提供了入门 Arduino 的软件工具和最佳示例，降低进入 ESP32 嵌入式专业开发的门槛。 ![](assets/images/Arduino_logo_1200x350.png) >Arduino 将不会阐述过多基础内容，请具备 C/C++ 的语言开发基础。 ## 资料与资源 [官方WIKI](https://wiki.banana pi.org/BPI Leaf S3_%E5%BC%80%E5%8F%91%E6%9D%BF) [GitHub: BPI Leaf S3 开发板原理图PDF](https://github.com/BPI STEAM/BPI Leaf S3 Doc/blob/main/sch/BPI Leaf S3 Chip V0.1A.pdf) [ESP32 S3 技术规格书](https://www.espressif.com/sites/default/files/documentation/esp32 s3_datasheet_cn.pdf) [ESP32 S3 技术参考手册](https://www.espressif.com/sites/default/files/documentation/esp32 s3_technical_reference_manual_cn.pdf) ## 样品购买 [官方速卖通](https://www.aliexpress.com/item/1005004428945296.html?spm 5261.ProductManageOnline.0.0.48af4edfYbyEoI) [官方淘宝](https://item.taobao.com/item.htm?spm a2126o.success.0.0.29034831FGnLQW&id 677287234553) OEM&OEM 定制服务 ： sales@banana pi.com"},"/Leaf_S3_doc/zh/no_translate.html":{"title":"no_translate_title","content":" title: no_translate_title class: md_page <div id \"visit_from\"></div> <div id \"no_translate_hint\">no_translate_hint</div> <div> <span id \"visit_hint\">visit_hint</span> <a id \"translate_src\"></a> </div> <div> <script> function getQueryVariable(variable) { var query window.location.search.substring(1); var vars query.split(\"&\"); for (var i 0;i<vars.length;i++) { var pair vars[i].split(\" \"); if(pair[0] variable){return pair[1];} } return(false); } var ref getQueryVariable(\"ref\"); var from getQueryVariable(\"from\"); var link document.getElementById(\"translate_src\"); var fromDis document.getElementById(\"visit_from\"); link.href ref; link.text ref; fromDis.innerHTML from; </script> </div>"}}