{"/PicoW_S3_doc/zh/CircuitPython/flash_tinyuf2.html":{"title":"烧录tinyUF2固件的方法","content":"# 烧录tinyUF2固件的方法 > 所有对flash的操作不可逆，注意提前备份代码等重要文件。 ## 下载tinyUF2固件 1. 进入[BPI PicoW S3 CircuitPython 下载](https://circuitpython.org/board/bpi_picow_s3/)页面。 2. 在页面底部找到`Install, Repair, or Update UF2 Bootloader`栏目，点击最下方的`DOWNLOAD BOOTLOADER ZIP`按钮下载压缩包。 3. 在本地解压压缩包，`combined.bin`文件是我们需要的固件。 ## 将开发板置于ESP bootloader模式 ![](../assets/images/picow_s3_circuitpython_download_2.jpg) 1. 通过USB连接开发板与电脑。 2. 使用任何导体（如金属引脚或镊子）将BOOT0触点短路，以将EPS32S3芯片置于bootloader模式。 3. 按一次`Reset`按键。 4. 松开BOOT0触点，进入ESP bootloader模式的特点为没进入tinyUF2或运行其他固件程序，指示灯不会有任何闪烁，且新增的串行设备名称为 USB JTAG/serial debug unit。 ![](../assets/images/picow_s3_circuitpython_download_5.jpg) ## 在浏览器中烧录固件 > 支持Chrome，Edge浏览器，内核版本需高于89。 1. 打开[ESP Web Flasher](https://nabucasa.github.io/esp web flasher/)页面。 2. 点击`Connect`按钮，将弹出一个选项栏，选择开发板所在的串口。 ![](../assets/images/picow_s3_tinyuf2_download_1.png) ![](../assets/images/picow_s3_tinyuf2_download_2.png) 3. 正常连接后，点击`Erase`按钮擦除开发板的flash内容，这个过程不可逆。 ![](../assets/images/picow_s3_tinyuf2_download_3.jpg) 4. 点击`Choose a file...`按钮，在弹出的文件选择窗口中跳转到`combined.bin`文件所在的目录，选择此文件并点击确认。 5. 点击`Program`按钮即可开始烧录固件，大约等待五分钟即可完成。 6. 完成后，手动按一次`Reset`按键，成功烧录的标志是彩灯为长绿灯，如果没有得到此结果，可以重试前五步，或尝试下一个烧录方法。 ## esptool本地烧录固件 1. 打开[Python官网](https://www.python.org/) 。 对于Windows 系统来说，最便捷的安装包下载方法就是在官网首页点击如下图所示的图标进行下载。 ![](../assets/images/Micropython_operating_env_1.png) 其他操作系统或是其他发行版本则可以在 Downloads 选项栏中进行选择。 建议使用python 3.7以上的版本。 2. 开始安装时一定要记得勾选Add Python 3.x to PATH，这样可以免除再手动添加进PATH。 ![](../assets/images/Micropython_operating_env_2.png) 按照安装提示逐步操作即可顺利完成安装 。 3. 以Windows PowerShell的具体操作步骤为例，使用以下命令安装esptool： ```shell pip install esptool ``` 如果未来有需要，则可以使用以下命令升级esptool： ```shell pip install U esptool ``` 4. 通过命令或其他方法在PowerShell中进入固件所在的目录。 5. 可以在Windows文件夹窗口中以按住shift键再单击右键的方式在此文件夹中打开PowerShell窗口。 6. 此时需要设置开发板为bootloader模式，详见上文。 7. 通过以下命令清除flash，需要修改COM接口为对应的接口，此处为COM22。 ```shell python m esptool chip esp32s3 port COM22 baud 460800 erase_flash ``` 8. 通过以下命令烧录`combined.bin`固件，需要修改COM接口为对应的接口，此处为COM22。 ```shell python m esptool chip esp32s3 port COM22 baud 460800 write_flash z 0x0 combined.bin ``` 9. 完成后，手动按一次`Reset`按键，成功烧录的标志是彩灯为长绿灯，如果没有得到此结果，可以重试前两步命令。"},"/PicoW_S3_doc/zh/CircuitPython/Basic.html":{"title":"基础功能使用","content":"# 基础功能使用 ## REPL简单使用 ### Hello World! 1. 确保已在Mu编辑器中正确连接开发板，参考[配置使用环境(Mu编辑器)](config_mu editor.html)。 2. 在CircuitPython REPL窗口中通常会出现如下信息，`>>>`符号的出现即代表我们可以开始在其后输入命令与其交互了。 ``` ]0;🐍Wi Fi: off Done 8.0.0 beta.0 49 g14fc4a079\\Auto reload is on. Simply save files over USB to run them or enter REPL to disable. Press any key to enter the REPL. Use CTRL D to reload. ]0;🐍Wi Fi: off Done 8.0.0 beta.0 49 g14fc4a079\\]0;�Wi Fi: off REPL 8.0.0 beta.0 49 g14fc4a079\\ Adafruit CircuitPython 8.0.0 beta.0 49 g14fc4a079 on 2022 09 20; BPI PicoW S3 with ESP32S3 >>> ``` 3. 在`>>>`符号右侧开始输入命令，例如：`print(\"Hello World！\")`。 > 注意使用英文输入法，中文字符无法被REPL识别。 ```py >>> print(\"Hello World!\") Hello World! >>> ``` ### REPL快捷键 1. 复制 `ctrl + shift + c`。 2. 粘贴 `ctrl + shift + v`。 使用鼠标左键在REPL中拖选需要复制的命令，键盘按下复制快捷键，再按下粘贴快捷键即可复制粘贴命令。 3. 软复位 `ctrl + d`。 4. 中断 `ctrl + c`, 中断当前正在执行的程序，但不会重启复位。 ### 查看内置模块 1. 在REPL中输入 `help(\"modules\")` 将列出当前CircuitPython开发板内所有模块。 2. 导入模块后可再使用`help()`函数查看该模块内部可用的函数名或变量名，例如查看`board`模块，即可看到开发板所有可用的引脚与外设功能。 ```py >>> import board >>> help(board) object <module 'board'> is of type module __name__ board board_id bpi_picow_s3 GP0 board.GP0 GP1 board.GP1 GP2 board.GP2 GP3 board.GP3 GP4 board.GP4 GP5 board.GP5 GP6 board.GP6 GP7 board.GP7 GP8 board.GP8 GP9 board.GP9 GP10 board.GP10 GP11 board.GP11 GP12 board.GP12 GP13 board.GP13 GP14 board.GP14 GP15 board.GP15 GP16 board.GP16 GP17 board.GP17 GP18 board.GP18 GP19 board.GP19 GP20 board.GP20 GP21 board.GP21 GP22 board.GP22 GP25 board.GP25 LED board.GP25 GP26 board.GP26 GP26_A0 board.GP26 A0 board.GP26 GP27 board.GP27 GP27_A1 board.GP27 A1 board.GP27 GP28 board.GP28 GP28_A2 board.GP28 A2 board.GP28 GP29 board.GP29 GP29_A3 board.GP29 A3 board.GP29 NEOPIXEL board.NEOPIXEL TX board.GP0 RX board.GP1 BOOT0 board.BOOT0 UART <function> >>> ``` ## 使WS2812彩灯闪烁 1. 在Mu编辑器中点击**Load**按钮，选择CircuitPython开发板上的 code.py 文件，点击 **打开**，即可开始编辑 code.py 。 2. 在编辑器中输入如下代码： ```python import time import board import neopixel pixels neopixel.NeoPixel(board.NEOPIXEL, 1, brightness 0.1) while 1: pixels[0] (255,0,0) pixels.show() time.sleep(0.5) pixels[0] (0,255,0) pixels.show() time.sleep(0.5) pixels[0] (0,0,255) pixels.show() time.sleep(0.5) pixels[0] (255,255,255) pixels.show() time.sleep(0.5) ``` 3. 点击**Save**按钮，编辑的内容将保存到CircuitPython开发板，代码无误的情况下，开发板上的彩色LED将循环闪烁 红绿蓝白。将开发板复位或重新上电，程序将重新开始运行。 4. 在REPL中使用中断快捷键即可停止程序的运行。 5. 代码也可直接复制粘贴到REPL中运行。 > 后续所有示例都可如此编辑code.py文件或复制粘贴到REPL中运行。但在code.py文件中的程序代码执行完毕后，开发板会恢复未运行时的状态，不会保留状态，但在REPL中执行则会保留状态。 ## 使引脚输出高低电平，控制LED 1. `board.LED`控制着PicoW S3上的一颗单色LED发光二极管，高电平点亮，低电平熄灭，在REPL中输入以下代码： ```py import board import digitalio ledpin digitalio.DigitalInOut(board.LED) ledpin.direction digitalio.Direction.OUTPUT ledpin.value True ``` 2. 或者这么做： ```py import board import digitalio ledpin digitalio.DigitalInOut(board.LED) ledpin.switch_to_output(value True) # value 1 ``` 3. 让LED间隔0.5秒闪烁： ```py import board import digitalio import time ledpin digitalio.DigitalInOut(board.LED) while True: ledpin.switch_to_output(value 1) time.sleep(0.5) ledpin.switch_to_output(value 0) time.sleep(0.5) ``` 4. 在REPL中使用中断快捷键即可停止程序的运行。 5. 在REPL中输入`import board;help(board)`即可列出所有可控制的引脚。`board.GP25` 与 `board.LED`完全相同。 ## PWM输出，控制LED亮度 1. 可通过控制PWM占空比来控制LED灯亮度，控制占空比从0%~100%，采用16位精度，十进制为 0~65535 ，16进制为 0~FFFF 。在REPL中输入以下代码： ```py import board import pwmio ledpin pwmio.PWMOut(board.LED, frequency 25000, duty_cycle 0) ledpin.duty_cycle 32768 # mid point 0 65535 50 % duty cycle ``` 2. 仅需在REPL中再次输入最后一行代码即可改变PWM占空比，使LED达到最大亮度： ```py ledpin.duty_cycle 65535 ``` 3. 使用`while`和`for`循环生成呼吸灯：： ```py import board import pwmio import time ledpin pwmio.PWMOut(board.LED, frequency 25000, duty_cycle 0) while True: for i in range(0, 65535, 1): ledpin.duty_cycle i for i in range(65535, 0, 1): ledpin.duty_cycle i ``` ## PWM输出，控制180度舵机 ![](../assets/images/MG90S Wiring Diagram.jpg) 以MG90S舵机为例，其他各种舵机参考其对应的使用手册，在以下代码中修改相应的参数。 1. MG90S舵机关键参数： * 控制角度，0° ~ 180° * PWM 占空时长控制，500us ~ 2500us 对应 0° ~ 180° * 工作电压：4.8V 至 6V（典型值为 5V） * 失速扭矩：1.8 kg/cm (4.8V) * 最大失速扭矩：2.2 kg/cm (6V) * 工作速度为 0.1s/60° (4.8V) 2. 求取任意一个旋转角度所需的占空时长的表达式为： ``` 设y为占空时长，x为旋转角度 y (2500 500)/180*x+500 y (100*x+4500)/9 ``` 3. 根据参数，可以确定舵机角度由PWM波的高电平持续时长所控制，且由于舵机的控制必须由周期性的PWM波形控制，所以一个周期时长必须超过控制此舵机达到180°所需的占空时长，即超过2500us，则PWM频率要低于400hz。 4. 设定PWM频率为200hz，则周期时长为5000us，对应控制此舵机旋转 0° ~ 180°的占空比为10% ~ 50% 。 5. circuitpython的PWM占空比控制精度为16bit，100%占空比在 2进制中表达为 1111 1111 1111 1111，16进制表达为 FFFF，10进制表达为 65535。 6. 求取任意一个旋转角度所需的占空比的表达式为： ``` 设y为占空比，x为旋转角度 y ((50 10)/180*x+10)/100*65535 y (4369*x+196605)/30 ``` 7. 舵机与BPI PicoW S3的接线方式: > BPI PicoW S3的VBS引脚可输出+5V；除GP0以外，所有GP引脚都可以用于输出PWM，仅需在程序中修改到对应引脚即可。 舵机 BPI PicoW S3 : : : : GND 棕色 GND +5V 红色 VBS PWM 橙色 GP0 8. 根据以上表达式与参数设计一个可以任意控制此舵机旋转角度的程序： ```py import board import pwmio import time servo_1 pwmio.PWMOut(board.GP0, frequency 200, duty_cycle 0)#200hz, one cycle 5000us def get_duty_cycle(x): return int((4369*x+196605)/30) servo_1.duty_cycle get_duty_cycle(90)# 90 degrees ``` 9. 通过一个逻辑分析仪可以读出此程序所控制输出的PWM占空时长，与计算的数值应当相符。 ![](../assets/images/MG90S_pulseveiw_2.png) ![](../assets/images/MG90S_pulseveiw_1.png) 10. 使用列表设计一套连续的舵机动作： ```py import board import pwmio import time servo_1 pwmio.PWMOut(board.GP0, frequency 200, duty_cycle 0)#200hz, one cycle 5000us def get_duty_cycle(x): return int((4369*x+196605)/30) action_list1 [0,45,90,135,180,0,180,45,135,90] while True: for i in action_list1: servo_1.duty_cycle get_duty_cycle(i) time.sleep(0.5) ``` ## ADC输入，读取双轴摇杆坐标 ![](../assets/images/Dual axis_joystick.jpg) 这是一个常见的双轴XY摇杆模块，使用了两个电位器最为其核心器件，通过芯片的ADC 模/数转换器 读取它们各自的电压数值，即可将读数转化为其在XY坐标轴上的位置。 **接线参考** 双轴摇杆 BPI PicoW S3 : : : : GND GND +5V 3V3 VRx GP27_A1 VRY GP26_A0 1. 在CircuitPython中提供的ADC精度是16bit，即最大值的16进制表达为 FFFF，10进制表达为 65535，对应的电压量程为0mv ~ 3300mv。BPI PicoW S3所使用的EPS32S3芯片实际ADC电压量程为0mv ~ 3100mv，所以实际应用时仅能测量到3100mv。 2. 基础ADC读数，读取两个电位器的数值，转换为电压数值。 > 请注意，xy轴在代码中是反向的，在逆时针旋转90°后可以使用双轴操纵杆模块。该方法可以在操纵杆沿y轴向上移动时使ADC读数增加，反之亦然，这符合普通直角坐标系的规律。 ```python import board,analogio,time x_axis_pin analogio.AnalogIn(board.A0) y_axis_pin analogio.AnalogIn(board.A1) while True: x_axis x_axis_pin.value y_axis y_axis_pin.value # print((x_axis,y_axis)) x_value x_axis / 65535 * 3300 y_value y_axis / 65535 * 3300 print(\"{0}mv,{1}mv\".format(x_value,y_value)) time.sleep(0.1) ``` 3. 在Mu编辑器中，点击`Plotter`图标即可显示绘图仪，可以实时将REPL输出的数值显示为与时间相关的折线图。 ![](../assets/images/circuitpython_plotter.png) 4. 以下程序可实现校准坐标零点的功能。开始运行的前五秒，请静止摇杆等待获取零点数值。 > 注意代码中将xy轴对换了，将双轴摇杆模块逆时针旋转90°即可对应使用。此做法可使摇杆在y轴上移时ADC读数增加，反之减少，符合常见直角坐标系的规律。 ```python import board,analogio,time x_axis_pin analogio.AnalogIn(board.A0) y_axis_pin analogio.AnalogIn(board.A1) def get_zero(times 500, sleep 0.01): x_total 0 y_total 0 for i in range (times): x_axis x_axis_pin.value y_axis y_axis_pin.value x_total + x_axis y_total + y_axis time.sleep(sleep) x_zero x_total // times y_zero y_total // times return (x_zero,y_zero) zero get_zero(times 500, sleep 0.01) print(zero) while True: x_axis x_axis_pin.value zero[0] y_axis y_axis_pin.value zero[1] print((x_axis,y_axis)) time.sleep(0.1) ``` 5. 以下程序可获取摇杆方向，这是双轴摇杆最常见的应用。 ```python import board,analogio,time x_axis_pin analogio.AnalogIn(board.A0) y_axis_pin analogio.AnalogIn(board.A1) direction_list [\"East\",\"Southeast\",\"South\",\"Southwest\",\"West\",\"Northwest\",\"North\",\"Northeast\",\"Centre\"] def get_zero(times 500, sleep 0.01): x_total 0 y_total 0 for i in range (times): x_axis x_axis_pin.value y_axis y_axis_pin.value x_total + x_axis y_total + y_axis time.sleep(sleep) x_zero x_total // times y_zero y_total // times return (x_zero,y_zero) def get_direction(zero (32767,32767)): x_axis x_axis_pin.value zero[0] y_axis y_axis_pin.value zero[1] if x_axis > 10000 and 10000 < y_axis < 10000: return direction_list[0] elif x_axis > 10000 and y_axis < 10000: return direction_list[1] elif 10000 < x_axis < 10000 and y_axis < 10000: return direction_list[2] elif x_axis < 10000 and y_axis < 10000: return direction_list[3] elif x_axis < 10000 and 10000 < y_axis < 10000: return direction_list[4] elif x_axis < 10000 and y_axis > 10000: return direction_list[5] elif 10000 < x_axis < 10000 and y_axis > 10000: return direction_list[6] elif x_axis > 10000 and y_axis > 10000: return direction_list[7] else : return direction_list[8] zero get_zero(times 50, sleep 0.01) print(zero) while True: x_axis x_axis_pin.value zero[0] y_axis y_axis_pin.value zero[1] print((x_axis,y_axis)) print(get_direction(zero zero)) time.sleep(0.1) ``` 6. 以下程序可设置坐标精度等级，计算每级跨度，可以按需求消除抖动，增强数据的实用性。 ```python import board,analogio,time x_axis_pin analogio.AnalogIn(board.A0) y_axis_pin analogio.AnalogIn(board.A1) def get_zero(times 500, sleep 0.01): x_total 0 y_total 0 for i in range (times): x_axis x_axis_pin.value y_axis y_axis_pin.value x_total + x_axis y_total + y_axis time.sleep(sleep) x_zero x_total // times y_zero y_total // times return (x_zero,y_zero) def get_extremum(times 500, sleep 0.01): x_list [] y_list [] for i in range (times): x_axis x_axis_pin.value y_axis y_axis_pin.value x_list.append(x_axis) y_list.append(y_axis) time.sleep(sleep) x_extremum (min(x_list),max(x_list)) y_extremum (min(y_list),max(y_list)) return (x_extremum,y_extremum) def get_spacing(level 16 , zero (32767,32767) ,x_extremum (0,65535),y_extremum (0,65535)): x_temp_1 (zero[0] x_extremum[0]) // level x_temp_2 (x_extremum[1] zero[0] ) // level y_temp_1 (zero[1] y_extremum[0]) // level y_temp_2 (y_extremum[1] zero[1] ) // level x_spacing (x_temp_1,x_temp_2) y_spacing (y_temp_1,y_temp_2) return (x_spacing,y_spacing) def get_coordinates(zero (32767,32767), x_spacing (2048,2048),y_spacing (2048,2048)): x_value x_axis_pin.value zero[0] y_value y_axis_pin.value zero[1] if x_value > 0: x_axis x_value // x_spacing[1] else: x_axis (( x_value) // x_spacing[0]) if y_value > 0: y_axis y_value // y_spacing[1] else: y_axis (( y_value) // y_spacing[0]) return (x_axis,y_axis) zero get_zero(times 500, sleep 0.01) print(zero) (x_extremum,y_extremum) get_extremum(times 500, sleep 0.01) print((x_extremum, y_extremum)) (x_spacing,y_spacing) get_spacing(level 128 , zero zero, x_extremum x_extremum,y_extremum y_extremum) print((x_spacing, y_spacing)) while True: coordinates get_coordinates(zero zero, x_spacing x_spacing, y_spacing y_spacing) print(coordinates) time.sleep(0.1) ``` ## 使用增量型旋转编码器 ![](../assets/images/rotary_incremental_encoder_pic.png) ![](../assets/images/rotary_incremental_encoder_pic_1.jpg) **接线参考** **增量型旋转编码器****BPI PicoW S3** GNDGND +VBUS SW DTGP0 CLKGP1 1. 增量型旋转编码器外观粗看与一些常见的旋转电位器相似，其关键的不同之处大致分为三点。 1. 微控制器使用ADC外设来读取旋转电位器输出的模拟信号（电压值），确定转轴当前角位；微控制器通过GPIO接收增量型旋转编码器输出的数字信号，可通过软件程序判断信号所对应的转轴动作。 2. 微控制器可在一定精度下，确定旋转电位器转轴当前角位，但因为模拟信号的持续性与抗干扰能力差的原因，无法准确判断它是否有动作；增量型旋转编码器仅在转轴运动到一个触点时，向微控制器发出一段动作数字信号，如果一个增量型旋转编码器一周有20个触点，它旋转一周就触发20次动作信号，微控制器可以精确的判断它是否动作，向哪个方向转动，信号触发了多少次。 3. 旋转电位器通常不可向任意转向进行无限旋转，会停止在最大或最小限位点；增量型旋转编码器可向任意转向进行无限旋转。 2. 增量型旋转编码器采用正交编码器生成其A和B的输出信号。从A和B输出发射的脉冲是正交编码的，这意味着当增量编码器以恒定速度运动时，A和B波形是方波，A和B之间存在90度的相位差。最终A和B信号将从两个管脚传输给微控制器。 ![](../assets/images/rotary_incremental_encoder_pic_2.gif) 3. 理论上，在任何特定时间，对于旋转编码器，A和B信号之间，顺时针旋转的相位差为+90°，逆时针旋转的相位差为−90°，具体则取决于设备内部的正交编码器设计。 4. A或B输出上的脉冲频率与转轴的速度（位置变化率）成正比。较高的频率表示较快的速度，而较低的频率表示较慢的速度。当转轴静止时，静态、不变的信号输出在A和B上，所以有很多测速方案使用增量型旋转编码器。 > 参考 [维基百科: 增量编码器](https://en.wikipedia.org/wiki/Incremental_encoder#Quadrature_decoder) 。 5. 用CircuitPython设计一个程序读取在GP0与GP1引脚上的信号，当其中一个发生变化时同时输出两个引脚当前的值，连接开发板与增量型旋转编码器后运行程序。 ```python import board import digitalio dt digitalio.DigitalInOut(board.GP0) clk digitalio.DigitalInOut(board.GP1) dt.switch_to_input() clk.switch_to_input() dt_last_value 0 clk_last_value 0 while True: if dt.value ! dt_last_value or clk.value ! clk_last_value: dt_last_value int(dt.value) clk_last_value int(clk.value) print((dt_last_value,clk_last_value)) ``` 6. 逐级转动转轴，观察输出信号，如果有逻辑分析仪或示波器也可接入观察。 1. 转轴逆时针旋转时，REPL的输出。 ``` (1, 1) (1, 0) (0, 0) (0, 1) (1, 1) (1, 0) (0, 0) (0, 1) (1, 1) ``` 2. 转轴逆时针旋转时，逻辑分析仪所观察到的波形。 ![](../assets/images/rotary_incremental_encoder_0.png) 3. 转轴顺时针旋转时，REPL的输出。 ``` (1, 1) (0, 1) (0, 0) (1, 0) (1, 1) (0, 1) (0, 0) (1, 0) (1, 1) ``` 4. 转轴逆时针旋转时，逻辑分析仪所观察到的波形。 ![](../assets/images/rotary_incremental_encoder_1.png) 7. 首先可以观察到的现象是，转轴完成一级动作后，两个引脚上的信号都为1，可以设计程序，当值都变为1时输出一次计数值，计数值可作为判断编码器完成一次动作的依据。 ```python import board import digitalio dt digitalio.DigitalInOut(board.GP0) clk digitalio.DigitalInOut(board.GP1) dt.switch_to_input() clk.switch_to_input() dt_last_value 0 clk_last_value 0 count 0 while True: if dt.value ! dt_last_value or clk.value ! clk_last_value: dt_last_value int(dt.value) clk_last_value int(clk.value) print((dt_last_value,clk_last_value)) if (dt_last_value,clk_last_value) (1,1): print(' ',count_1,' ') count + 1 ``` 8. 再确定编码器顺时针旋转与逆时针旋转的动作，在两个引脚上输出的信号变化的规律与差异。 1. 逆时针旋转的规律为(1, 1)>(1, 0)>(0, 0)>(0, 1)>(1, 1)。 2. 顺时针旋转的规律为(1, 1)>(0, 1)>(0, 0)>(1, 0)>(1, 1)。 由此可设计一个顺时针旋转使计数+1，逆时针旋转使计数 1的程序，并加入消抖除错的功能。 ```python import board import digitalio import time dt digitalio.DigitalInOut(board.GP0) clk digitalio.DigitalInOut(board.GP1) dt.switch_to_input() clk.switch_to_input() dt_last_value 0 clk_last_value 0 count 0 start_sign 0 clockwise_sign 0 while True: if dt.value ! dt_last_value or clk.value ! clk_last_value: dt_last_value int(dt.value) clk_last_value int(clk.value) print((dt_last_value,clk_last_value)) if start_sign 0 and (dt_last_value,clk_last_value) (0,0): start_sign 1 elif start_sign 1: if (dt_last_value,clk_last_value) (1, 0): clockwise_sign 1 elif (dt_last_value,clk_last_value) (0, 1): clockwise_sign 1 elif (dt_last_value,clk_last_value) (1, 1): count count + clockwise_sign clockwise_sign 0 start_sign 0 print(' ',count,' ') ``` 9. 此程序中的消抖除错功能的实现，并不是逐步判断验证是否符合信号规律，或许还有更多办法可以实现消抖除错，欢迎讨论。 10. 另外 CircuitPython 的rotaryio模块可直接实现正反转计数功能。（内部程序有所差异，但最终实现功能基本一致）。 ```python import rotaryio import board encoder rotaryio.IncrementalEncoder(board.GP0,board.GP1) last_position 0 while True: position encoder.position if position ! last_position: print(position) last_position position ``` ## 下载安装CircuitPython库，驱动ssd1306 oled屏幕 ![](../assets/images/adafruit_ssd1306_4.jpg) [CircuitPython库 官网页面](https://circuitpython.org/libraries) [Adafruit CircuitPython库 文档页面](https://docs.circuitpython.org/projects/bundle/en/latest/index.html) [Adafruit SSD1306 库 文档页面](https://docs.circuitpython.org/projects/ssd1306/en/latest/index.html) [Adafruit framebuf 库 文档页面](https://docs.circuitpython.org/projects/framebuf/en/latest/) 本节以ssd1306驱动库与framebuf库为例，指导如何下载安装CircuitPython库。 1. 在新页面打开[Adafruit CircuitPython库 文档页面](https://docs.circuitpython.org/projects/bundle/en/latest/index.html)。 2. 在页面中找到并打开 **SSD1306 OLED (framebuf)** 项，然后点击左侧的**Download from GitHub**项，跳转到其GitHub releases页面，点击 **adafruit circuitpython ssd1306 8.x mpy 2.12.12.zip** 项将其下载到本地。 ![](../assets/images/adafruit_ssd1306_1.jpg) ![](../assets/images/adafruit_ssd1306_2.jpg) ![](../assets/images/adafruit_ssd1306_3.jpg) 3. 回到Adafruit CircuitPython库 文档页面，在页面中找到并打开 **Framebuf Module** 项，然后点击左侧的**Download from GitHub**项，跳转到其GitHub releases页面，点击 **adafruit circuitpython framebuf 8.x mpy 1.4.14.zip** 项将其下载到本地。 > 下载最新版本即可。 4. 将下载的两个压缩包解压，内部文件夹结构如下： ``` ├─examples │ ├─xxx.py │ ├─xxx.py │ └─...... ├─lib │ ├─a.mpy │ ├─b.mpy │ └─...... └─requirements ├─a │ └─requirements.txt ├─b │ └─requirements.txt └─...... ``` 5. examples文件夹中的是一些库的使用例程，lib文件夹中扩展名为`.mpy`的即是库文件，requirements文件夹中的 requirements.txt 文件，其中记录了各库文件所依赖的，必要的其他库文件名称，有一些已经包含在CircuitPython固件中，而不在其内的则需另外下载安装。例如 **adafruit_ssd1306** 库绘制图形和文字的方法全部依赖于**adafruit_framebuf** 库，所以我们在第3步中也将其下载到本地。 6. 将两个lib文件夹中扩展名为`.mpy`的库文件复制到 **CIRCUITPY** 磁盘中的lib文件夹内，即可在程序中调用这两个库。 7. adafruit_framebuf 库还需将其examples文件夹中的 **font5x8.bin** 文件复制到**CIRCUITPY** 磁盘中的根目录，即 code.py 文件所在的地方。此为字库文件，显示文字需要使用它。 8. 将一块i2c协议的ssd1306 oled屏幕模块与开发板连接。 **接线参考** ssd1306 BPI PicoW S3 : : : : GND GND VCC 3V3 SCL GP0 SDA GP1 9. 编辑 code.py 文件，在其中输入以下代码即可驱动此屏幕模块输出图形和字符。 修改代码中的变量 `bgColor`数值为1，即可使显示背景为白色，显示图形为黑色。 在两个库的文档中可查找到API参考，配合例程即可快速理解，上手使用ssd1306显示模块。 ```python import board import busio import adafruit_ssd1306 import time i2c busio.I2C(board.GP0, board.GP1) display adafruit_ssd1306.SSD1306_I2C(128, 64, i2c, addr 0x3C) bgColor 0 display.fill(bgColor) for i in range(0,display.height,4): for j in range(0,display.width,4): display.pixel(j, i, not bgColor) display.show() display.fill(bgColor) for i in range(0,display.height,4): display.hline(0, i,display.width, not bgColor) display.show() display.fill(bgColor) for i in range(0,display.width,8): display.vline(i, 0,display.height, not bgColor) display.show() display.fill(bgColor) for i in range(0,display.height,4): display.line(0, 0, display.width, i, not bgColor) display.line(display.width, display.height, 0, display.height i, not bgColor) display.show() display.fill(bgColor) for i in range(0,display.width//2,4): display.circle(display.width//2, display.height//2, i, not bgColor) display.show() display.fill(bgColor) for i in range(0,display.height,16): for j in range(0,display.width,16): display.rect(j, i, 12, 12, not bgColor) display.show() for i in range(0,display.height,16): for j in range(0,display.width,16): display.fill_rect(j+2, i+2, 8, 8, not bgColor) display.show() display.fill(bgColor) display.text(\"Hello\", 0, 24, not bgColor, font_name 'font5x8.bin', size 2) display.show() time.sleep(0.25) display.text(\"World!\", 0, 40, not bgColor, font_name 'font5x8.bin', size 3) display.show() time.sleep(0.25) display.text(\">>>\", 60, 0, not bgColor, font_name 'font5x8.bin', size 4) display.show() time.sleep(1) display.fill(bgColor) char_width 6 char_height 8 chars_per_line display.width // 6 for i in range(255): x char_width * (i % chars_per_line) y char_height * (i // chars_per_line) display.text(chr(i), x, y, not bgColor, font_name 'font5x8.bin', size 1) display.show() ``` # 多功能应用 ## OLED实时动画显示双轴摇杆位置 基于前文: [ADC输入，读取双轴摇杆坐标](#adc输入读取双轴摇杆坐标) [下载安装CircuitPython库，驱动ssd1306 oled屏幕](#下载安装circuitpython库驱动ssd1306 oled屏幕) 我们可设计一个使OLED实时动画显示双轴摇杆位置的程序。 **接线参考** ssd1306 BPI PicoW S3 : : : : GND GND VCC 3V3 SCL GP0 SDA GP1 双轴摇杆 BPI PicoW S3 : : : : GND GND +5V 3V3 VRx GP27_A1 VRY GP26_A0 ```python import time import board import busio import analogio import adafruit_ssd1306 def get_zero(times 500, sleep 0.01): x_total 0 y_total 0 for i in range (times): x_axis x_axis_pin.value y_axis y_axis_pin.value x_total + x_axis y_total + y_axis time.sleep(sleep) x_zero x_total // times y_zero y_total // times return (x_zero,y_zero) def get_extremum(times 500, sleep 0.01): x_list [] y_list [] for i in range (times): x_axis x_axis_pin.value y_axis y_axis_pin.value x_list.append(x_axis) y_list.append(y_axis) time.sleep(sleep) x_extremum (min(x_list),max(x_list)) y_extremum (min(y_list),max(y_list)) return (x_extremum,y_extremum) def get_spacing(level 16 , zero (32767,32767) ,x_extremum (0,65535),y_extremum (0,65535)): x_temp_1 (zero[0] x_extremum[0]) // level x_temp_2 (x_extremum[1] zero[0] ) // level y_temp_1 (zero[1] y_extremum[0]) // level y_temp_2 (y_extremum[1] zero[1] ) // level x_spacing (x_temp_1,x_temp_2) y_spacing (y_temp_1,y_temp_2) return (x_spacing,y_spacing) def get_coordinates(zero (32767,32767), x_spacing (2048,2048),y_spacing (2048,2048)): x_value x_axis_pin.value zero[0] y_value y_axis_pin.value zero[1] if x_value > 0: x_axis x_value // x_spacing[1] else: x_axis (( x_value) // x_spacing[0]) if y_value > 0: y_axis y_value // y_spacing[1] else: y_axis (( y_value) // y_spacing[0]) return (x_axis,y_axis) # i2c init i2c busio.I2C(board.GP0, board.GP1) display adafruit_ssd1306.SSD1306_I2C(128, 64, i2c, addr 0x3C) # Uniformly set the color and background color of displayed characters or graphics. # Monochrome OLEDs only need to set one and then negate the other. display_color 0 bg_color not display_color # Fill background color. display.fill(bg_color) display.show() # Set 2 axis rocker pin. x_axis_pin analogio.AnalogIn(board.A0) y_axis_pin analogio.AnalogIn(board.A1) # Calibrate the zero point. # Take the xy axis reading when the dual axis joystick is at rest and set it to zero point. display.text('Zero adjustment', 0, 20, display_color, font_name 'font5x8.bin', size 1) display.text('Do not touch', 0, 28, display_color, font_name 'font5x8.bin', size 1) display.show() zero get_zero(times 200, sleep 0.01) display.text('Do not touch', 0, 28, bg_color, font_name 'font5x8.bin', size 1) str_zero \"x {},y {}\".format(zero[0],zero[1]) display.text(str_zero, 0, 28, display_color, font_name 'font5x8.bin', size 1) display.show() print(str_zero) time.sleep(2) # Different hardware measures different extreme values. display.fill(bg_color) display.text('Extremum adjustment', 0, 20, display_color, font_name 'font5x8.bin', size 1) display.text('Rotary rocker', 0, 28, display_color, font_name 'font5x8.bin', size 1) display.show() (x_extremum,y_extremum) get_extremum(times 400, sleep 0.01) display.text('Extremum adjustment', 0, 20, bg_color, font_name 'font5x8.bin', size 1) display.text('Rotary rocker', 0, 28, bg_color, font_name 'font5x8.bin', size 1) str_x_extremum \"x_min {},x_max {}\".format(x_extremum[0],x_extremum[1]) str_y_extremum \"y_min {},y_max {}\".format(y_extremum[0],y_extremum[1]) display.text(str_x_extremum, 0, 20, display_color, font_name 'font5x8.bin', size 1) display.text(str_y_extremum, 0, 28, display_color, font_name 'font5x8.bin', size 1) print((str_x_extremum, str_y_extremum)) display.show() time.sleep(2) # Setting the scale spacing can eliminate unnecessary jitter. (x_spacing,y_spacing) get_spacing(level 32 , zero zero, x_extremum x_extremum,y_extremum y_extremum) print((x_spacing, y_spacing)) display.fill(bg_color) display.text('x ', 70, 16, display_color, font_name 'font5x8.bin', size 2) display.text('y ', 70, 32, display_color, font_name 'font5x8.bin', size 2) (x_axis,y_axis) (0,0) (x_axis_1,y_axis_1) (1,1) (x_axis_2,y_axis_2) (0,0) display.show() while True: # Get the coordinate value in a loop. (x_axis,y_axis) get_coordinates(zero zero, x_spacing x_spacing, y_spacing y_spacing) # Only refresh the display when the coordinates change. if (x_axis,y_axis) (x_axis_1,y_axis_1): pass else: # Using background color inversion for identical pixels, # pixels can be refreshed with minimal performance cost. display.fill_rect(x_axis_2 3, y_axis_2 3, 6, 6, bg_color) display.text(str(x_axis_1), 90, 16, bg_color, font_name 'font5x8.bin', size 2) display.text(str(y_axis_1), 90, 32, bg_color, font_name 'font5x8.bin', size 2) (x_axis_1,y_axis_1) (x_axis,y_axis) (x_axis_2,y_axis_2) (x_axis+32, y_axis+32) display.fill_rect(x_axis_2 3, y_axis_2 3, 6, 6, display_color) display.text(str(x_axis_1), 90, 16, display_color, font_name 'font5x8.bin', size 2) display.text(str(y_axis_1), 90, 32, display_color, font_name 'font5x8.bin', size 2) display.show() ```"},"/PicoW_S3_doc/zh/CircuitPython/supported_by_circuitpython.html":{"title":"已得到CircuitPython官方支持","content":"# 已得到CircuitPython官方支持 1. 已得到adafruit/circuitpython GitHub存储库支持。 https://github.com/adafruit/circuitpython/pull/7031 分支已合并。 2. 已得到adafruit/tinyuf2 GitHub存储库支持。 https://github.com/adafruit/tinyuf2/pull/250 分支已合并。 3. 已得到adafruit/circuitpython org GitHub存储库支持。 https://github.com/adafruit/circuitpython org/pull/1070 分支已合并。 https://github.com/adafruit/circuitpython org/pull/1077 分支已合并。 4. circuitpython.org 网页已可下载circuitpython固件与tinyuf2固件。 https://circuitpython.org/board/bpi_picow_s3/"},"/PicoW_S3_doc/zh/CircuitPython/update_circuitpython.html":{"title":"更新CircuitPython固件的方法","content":"# 更新CircuitPython固件的方法 > 出厂已安装 tinyUF2 + CircuitPython固件，升级circuipython仅需双击复位键进入UF2 bootloader模式，无需擦除flash。 > 本方法适用于已具备tinyUF2固件的开发板，如果开发板的flash被擦除或出现无法进入UF2模式的故障，则需先参考[烧录tinyUF2固件的方法](flash_tinyuf2.html)。 1. 进入[BPI PicoW S3 CircuitPython 下载](https://circuitpython.org/board/bpi_picow_s3/)页面。 ![](../assets/images/picow_s3_circuitpython_download.jpg) 2. 点击DOWNLOAD UF2 NOW 按钮即可下载最新释放的`.uf2`固件。 3. 通过USB连接开发板与电脑，在此电脑文件管理页面将出现一个名为`CIRCUITPY`的磁盘，此为CircuitPython模式下的磁盘，通过双击开发板上的`Reset`按键的方式，使其变更为UF2模式下的磁盘，以下为具体操作步骤。 1. 快速按一次`Reset`按键。 ![](../assets/images/picow_s3_circuitpython_download_2.jpg) 2. 紫灯亮起时再快速按一次`Reset`按键。 ![](../assets/images/picow_s3_circuitpython_download_3.jpg) 3. 成功触发的标志是彩灯在片刻红灯后转变为长绿灯，如果没有得到此结果，可以重试前两步。 ![](../assets/images/picow_s3_circuitpython_download_4.jpg) 4. UF2模式下的磁盘名称为`UF2BOOT`，将第1步下载的`.uf2`固件复制到此磁盘中，过程中彩灯会闪烁橙灯，请勿在此过程中断开连接或对开发板进行任何操作。 5. 完成CircuitPython固件更新后会自动复位，在此电脑文件管理页面将重新出现一个`CIRCUITPY`磁盘，通过REPL可以查看具体的固件版本。"},"/PicoW_S3_doc/zh/CircuitPython/config_mu-editor.html":{"title":"配置使用环境(Mu编辑器)","content":"# 配置使用环境(Mu编辑器) ## 下载安装Mu编辑器 1. 进入[**Mu编辑器官网**](https://codewith.mu/)，点击 **Download** 按钮进入新页面。 ![](../assets/images/Download_mu_1.png) 2. 选择你的电脑当前使用的操作系统，点击对应操作系统的 **Download** 按钮开始下载安装包。 ![](../assets/images/Download_mu_2.png) 3. 点击对应操作系统的 **Instuctions** 按钮即可查看详细的安装步骤，根据指引安装即可。 ## 建立Mu编辑器与开发板的连接 > BPI PicoW S3出厂已安装tinyUF2与CircuitPython固件。 1. 启动Mu编辑器，将模式更改为CircuitPython，如果您已正确连接CircuitPython开发板，将提示您是否直接切换到该模式。 ![](../assets/images/Download_mu_3.png) ![](../assets/images/Download_mu_4.png) 2. 点击**Serrial**按钮，然后按任意键即可进入CircuitPython REPL。 ![](../assets/images/Download_mu_5.png)"},"/PicoW_S3_doc/zh/MicroPython/micropython_uf2_firmware.html":{"title":"","content":"## 通过UF2安装MicroPython固件 > 出厂已安装 tinyUF2 + CircuitPython固件，安装micropython UF2固件 仅需双击复位键进入UF2 bootloader模式，无需擦除flash。 > 本方法适用于已具备tinyUF2固件的开发板，如果开发板的flash被擦除或出现无法进入UF2 bootloader模式的故障，则需先参考[烧录tinyUF2固件的方法](../CircuitPython/flash_tinyuf2.html)。 1. 点击此链接：[ESP32S3 micropython固件下载地址](https://micropython.org/download/ESP32_GENERIC_S3/)。 2. 找到下方 Firmware > Nightly builds，下载第一项，最新的，后缀名为 `.uf2`的固件。 ![](../assets/images/micropython_downlord_uf2.png) 3. 使用一根具有供电与数据功能的microUSB线连接开发板与你的计算机。在文件管理页面将出现一个名为`CIRCUITPY`的磁盘，此为CircuitPython模式下的磁盘，通过双击开发板上的`Reset`按键的方式，使其变更为UF2模式下的磁盘，以下为具体操作步骤。 1. 快速按一次`Reset`按键。 ![](../assets/images/picow_s3_circuitpython_download_2.jpg) 2. 紫灯亮起时再快速按一次`Reset`按键。 ![](../assets/images/picow_s3_circuitpython_download_3.jpg) 3. 成功触发的标志是彩灯在片刻红灯后转变为长绿灯，如果没有得到此结果，可以重试前两步。 ![](../assets/images/picow_s3_circuitpython_download_4.jpg) 4. UF2模式下的磁盘名称为`UF2BOOT`，将第1步下载的`.uf2`固件复制到此磁盘中，过程中彩灯会闪烁橙灯，请勿在此过程中断开连接或对开发板进行任何操作。 5. 完成MicroPython固件拷贝后会自动复位，在文件管理页面将不会出现任何新磁盘，MicroPython不提供类似功能，可通过thonny或mpremote来进行开发。 ## 在MicroPython中格式化分区的方法 因为BPI PicoW S3开发板出厂使用CircuitPython固件，切换为MicroPython固件后，文件分区内会残留旧文件，还需手动格式化清除文件。 另外，micropython.uf2固件在tinyUF2 bootloader中，用户分区只能使用FAT格式，可能偶尔会发生一些文件错误，目前最简单的除错办法是手动格式化分区。 请在连接上MicroPython REPL后，依次输入以下命令： ```py os.umount(\"/\") os.VfsFat.mkfs(bdev) vfs os.VfsFat(bdev) os.mount(vfs, \"/\") ```"},"/PicoW_S3_doc/zh/MicroPython/micropython_bin_firmware.html":{"title":"","content":"## 安装MicroPython.bin固件 > 所有对flash的操作不可逆，注意提前备份代码等重要文件。 ### 下载tinyUF2固件 1. 点击此链接：[ESP32S3 micropython固件下载地址](https://micropython.org/download/ESP32_GENERIC_S3/)。 2. 找到下方 Firmware > Nightly builds，下载第一项，最新的，后缀名为 `.bin`的固件。 ![](../assets/images/micropython_downlord_bin.png) ### 将开发板置于ESP bootloader模式 ![](../assets/images/picow_s3_circuitpython_download_2.jpg) 1. 通过USB连接开发板与电脑。 2. 使用任何导体（如金属引脚或镊子）将BOOT0触点短路，以将EPS32S3芯片置于bootloader模式。 3. 按一次`Reset`按键。 4. 松开BOOT0触点，进入ESP bootloader模式的特点为没进入tinyUF2或运行其他固件程序，指示灯不会有任何闪烁，且新增的串行设备名称为 USB JTAG/serial debug unit。 ![](../assets/images/picow_s3_circuitpython_download_5.jpg) ### 在浏览器中烧录固件 > 支持Chrome，Edge浏览器，内核版本需高于89。 1. 打开[ESP Web Flasher](https://nabucasa.github.io/esp web flasher/)页面。 2. 点击`Connect`按钮，将弹出一个选项栏，选择开发板所在的串口。 ![](../assets/images/picow_s3_tinyuf2_download_1.png) ![](../assets/images/picow_s3_tinyuf2_download_2.png) 3. 正常连接后，点击`Erase`按钮擦除开发板的flash内容，这个过程不可逆。 ![](../assets/images/picow_s3_tinyuf2_download_3.jpg) 4. 点击`Choose a file...`按钮，在弹出的文件选择窗口中跳转到micropython固件文件所在的目录，选择此文件并点击确认。 5. 点击`Program`按钮即可开始烧录固件，大约等待五分钟即可完成。 6. 完成后，手动按一次`Reset`按键，在任意串口工具中查看MicroPython REPL是否有输出，如果没有，可以重试前五步，或尝试下一个烧录方法。 ## esptool本地烧录固件 1. 打开[Python官网](https://www.python.org/) 。 对于Windows 系统来说，最便捷的安装包下载方法就是在官网首页点击如下图所示的图标进行下载。 ![](../assets/images/Micropython_operating_env_1.png) 其他操作系统或是其他发行版本则可以在 Downloads 选项栏中进行选择。 建议使用python 3.7以上的版本。 2. 开始安装时一定要记得勾选Add Python 3.x to PATH，这样可以免除再手动添加进PATH。 ![](../assets/images/Micropython_operating_env_2.png) 按照安装提示逐步操作即可顺利完成安装 。 3. 以Windows PowerShell的具体操作步骤为例，使用以下命令安装esptool： ```shell pip install esptool ``` 如果未来有需要，则可以使用以下命令升级esptool： ```shell pip install U esptool ``` 4. 通过命令或其他方法在PowerShell中进入固件所在的目录。 5. 可以在Windows文件夹窗口中以按住shift键再单击右键的方式在此文件夹中打开PowerShell窗口。 6. 此时需要设置开发板为bootloader模式，详见上文。 7. 通过以下命令清除flash，需要修改COM接口为对应的接口，此处为COM22。 ```shell python m esptool chip esp32s3 port COM22 baud 460800 erase_flash ``` 8. 通过以下命令烧录固件，需要修改COM接口为对应的接口，此处为COM22，注意将最后的文件名修改为你所下载的固件文件名。 ```shell python m esptool chip esp32s3 port COM22 baud 460800 write_flash z 0x0 GENERIC_S3_SPIRAM 20230627 unstable v1.20.0 261 g813d559bc.bin ``` 9. 完成后，手动按一次`Reset`按键，在任意串口工具中查看MicroPython REPL是否有输出。"},"/PicoW_S3_doc/zh/Unboxing/Introduction.html":{"title":"【 开发板介绍 】","content":"# 【 开发板介绍 】 BPI PicoW S3板载ESP32 S3芯片，支持 2.4 GHz Wi Fi 和低功耗蓝牙 (Bluetooth® LE) 双模无线通信。板子支持USB和IO供电两种供电方式，可实现双电源下自动切换电源功能。体积小巧，接口方便，上手简单，可直接应用于物联网低功耗项目。 BPI PicoW S3开发板在软件方面支持ESP IDF、Arduino、MicroPython等多种方式进行编程开发 。 BPI PicoW S3开发板上标记了与芯片对应的所有IO管脚，外形与Raspberry Pico W开发板一致，开发者可根据实际需求，可将Raspberry Pico W支持的外围设备添加到BPI PicoW S3上，也可将开发板插在面包板上使用。 ## 关键特性 ESP32 S3，Xtensa® 32 bit LX7 片上外设 PSRAM , 片外 FLASH Ultra low power 10uA 2.4G WIFI ，Bluetooth 5 ，Bluetooth mesh GPIO , ADC , TOUCH , PWM , I2C , SPI , RMT , I2S , UART , LCD，CAMERA ，USB , JTAG 1 * MicroUSB 1 * 全彩色LED ## 硬件 ### 接口示意图 ![](../assets/images/PicoW S3_board.png) ### 硬件规格 <table> <tr> <td>BPI PicoW S3 规格表</td> </tr> <tr> <td>SoC主控芯片</td> <td>ESP32 S3，Xtensa® 32 位 LX7 双核处理器</td> </tr> <tr> <td>主频</td> <td>240MHz MAX</td> </tr> <tr> <td>工作温度</td> <td> 40℃~+85℃</td> </tr> <tr> <td>片上 ROM</td> <td>384 KB</td> </tr> <tr> <td>片上 SRAM</td> <td>320 KB</td> </tr> <tr> <td>片外 FLASH ROM</td> <td>8MB</td> </tr> <tr> <td>片上外设 PSRAM</td> <td>2MB</td> </tr> <tr> <td>WIFI</td> <td>IEEE 802.11 b/g/n ，2.4Ghz频带，150Mbps</td> </tr> <tr> <td>蓝牙</td> <td>Bluetooth 5 ，Bluetooth mesh</td> </tr> <tr> <td>GPIO</td> <td>BPI PicoW S3已引出27个可用GPIO</td> </tr> <tr> <td>ADC</td> <td>2 × 12 位 SAR ADC，支持 20 个模拟通道输入</td> </tr> <tr> <td>TOUCH 电容式触摸传感器</td> <td>14</td> </tr> <tr> <td>SPI</td> <td>4</td> </tr> <tr> <td>I2C</td> <td>2，支持主机或从机模式</td> </tr> <tr> <td>I2S</td> <td>2，串行立体声数据的输入输出</td> </tr> <tr> <td>LCD</td> <td>1，支持 8 位 ~16 位并行 RGB、I8080、MOTO6800 接口</td> </tr> <tr> <td>CAMERA</td> <td>1，支持 8 位 ~16 位 DVP 图像传感器接口</td> </tr> <tr> <td>UART</td> <td>3 ，支持异步通信（RS232 和RS485）和 IrDA</td> </tr> <tr> <td>PWM</td> <td>8 路独立通道，14位精度</td> </tr> <tr> <td>MCPWM</td> <td>2</td> </tr> <tr> <td>USB</td> <td>1 × 全速USB 2.0 OTG，MicroUSB母口</td> </tr> <tr> <td>USB Serial/JTAG 控制器</td> <td>1，USB 全速标准，CDC ACM ，JTAG</td> </tr> <tr> <td>温度传感器</td> <td>1，测量范围为–20 °C 到 110 °C，用于监测芯片内部温度</td> </tr> <tr> <td>SD/MMC</td> <td>1 × SDIO主机接口，具有2个卡槽，支持SD卡3.0和3.01，SDIO 3.0，CE ATA 1.1，MMC 4.41，eMMC 4.5和4.51</td> </tr> <tr> <td>TWAI® 控制器</td> <td>1 ，兼容 ISO11898 1（CAN 规范 2.0）</td> </tr> <tr> <td>通用 DMA 控制器</td> <td>5 个接收通道和 5 个发送通道</td> </tr> <tr> <td>RMT</td> <td>4 通道发射，4通道接收，共享 384 x 32 bit 的 RAM</td> </tr> <tr> <td>脉冲计数器</td> <td>4个脉冲计数控制器（单元），每个单元有2个独立的通道</td> </tr> <tr> <td>定时器</td> <td>4 × 54 位通用定时器，16 位时钟预分频器，1 × 52 位系统定时器，3 × 看门狗定时器</td> </tr> <tr> <td>外部晶振</td> <td>40Mhz</td> </tr> <tr> <td>RTC 和低功耗管理</td> <td>电源管理单元 (PMU)+ 超低功耗协处理器 (ULP)</td> </tr> <tr> <td>低功耗电流</td> <td>10uA</td> </tr> <tr> <td>工作电压</td> <td>3.3V</td> </tr> <tr> <td>输入电压</td> <td>3.3V~5.5V</td> </tr> <tr> <td>最大放电电流</td> <td>2A@3.3V DC/DC</td> </tr> <tr> <td>可控全彩色LED</td> <td>1</td> </tr> </table> ### 硬件尺寸 ![](../assets/images/PicoW S3_board_dimension.png) <table> <tr> <td>BPI PicoW S3 尺寸表</td> </tr> <tr> <td>管脚间距</td> <td>2.54mm</td> </tr> <tr> <td>安装孔间距</td> <td>11.4mm/ 47mm</td> </tr> <tr> <td>安装孔尺寸</td> <td>内径2.1mm/外径3.4mm</td> </tr> <tr> <td>主板尺寸</td> <td>21 × 51.88(mm)/0.83 x 2.04(inches)</td> </tr> <tr> <td>板厚</td> <td>1.2mm</td> </tr> <tr> <td></td> </tr> </table> 管脚间距兼容万能板（洞洞板、点阵板），面包板，并且能直接贴在其他PCB上，便于调试应用。 ## 资料与资源 [GitHub: BPI PicoW S3 开发板原理图PDF](https://github.com/BPI STEAM/BPI PicoW Doc/blob/main/sch/BPI PicoW V0.4.pdf) [ESP32 S3 技术规格书](https://www.espressif.com/sites/default/files/documentation/esp32 s3_datasheet_cn.pdf) [ESP32 S3 技术参考手册](https://www.espressif.com/sites/default/files/documentation/esp32 s3_technical_reference_manual_cn.pdf)"},"/PicoW_S3_doc/zh/Arduino/Basic.html":{"title":"板载资源的使用","content":"# 板载资源的使用 本章主要是通过一些示例项目，阐述 PicoW S3 主控板的外设基本使用方法，通过下面的项目，您可以进行修改完成您的自己的项目。 其中 PicoW S3 外设主要包括：UART、I2C、SPI、ADC、PWM、DAC等。 ## 开始之前的准备 BPI PicoW S3 开发板上的MicorUSB使用的是ESP32 S3的原生USB接口，而不是传统的USB转TLL芯片。 为了让您的开发板能正确下载程序，您需要将BPI PicoW S3设置为下载模式，有以下两种方法： 通过USB连接到电脑，使用镊子将BOOT短接，再按一下Reset键并松开，最后断开BOOT短接。 在断开所有供电的状态下，将BOOT短接，然后将开发板插上电脑，最后断开BOOT短接。 ![](../assets/images/PicoW BOOT.png) 这时候可以在设备管理器中看到一个多的COM口 ![](../assets/images/Device_manager.jpg) 在IDE中选择这个端口 ![](../assets/images/Device_manager_1.jpg) ## 项目一 串口实验 在最开始的章节中，我们上传了一个 Blink 闪烁程序来测试板子上的 LED 状态灯。现在，我们使用 UART 串口，每秒打印一次计时数据。 ### 所需元件 PicoW S3 主板 X 1 ![](../assets/images/PicoW S3.png) ### 硬件连接 此项目不需要其他传感器，所以只需要把PicoW S3用USB连到电脑就能用。 ### 输入代码 打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。 代码如下: <details> <summary>展开查看</summary> <pre><code> void setup() { Serial.begin(115200); //设置串口通信波特率 } void loop() { static unsigned long i 0; //定义变量i Serial.println(i++); //i加一后输出i delay(1000); //延时1秒 } </code></pre> </details> 输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后 IDE 会把代码发送给 PicoW S3 主板。上传完成之后，你需要按一下复位键，这样代码就能正常运行了 ### 实验现象 完成之前步骤的上传后，打开 Arduino IDE 自带的串口监视器，可以看到如下的打印信息： ![](../assets/images/Lesson1 1.png) ## 项目二 PWM(呼吸灯) 呼吸灯，即让 PicoW S3 通过 PWM 驱动 LED 灯，实现 LED 的亮度渐变，看起来就像是在呼吸一样。关于 PWM 的解释，请阅览知识扩展部分。 ### 所需元件 PicoW S3 主板 X 1 ![](../assets/images/PicoW S3.png) LED X 1 (建议串联一个电阻限流) ![](../assets/images/led.png) ### 硬件连接 将LED连接到PicoW S3的GPIO13就可以了，长的那个脚接GPIO13，短的接到GND ### 输入代码 打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。 代码如下: <details> <summary>展开查看</summary> <pre><code> #define LED_CHANNEL_0 0 //设置通道0 #define LED_TIMER_13_BIT 13 //设置13位定时器 #define LED_BASE_FREQ 5000 //设置定时器频率位5000Hz #define LED_PIN 13 //设置LED灯 int brightness 0; // LED亮度 int fadeAmount 1; // LED数量 //设置led灯的亮度 void ledcAnalogWrite(uint32_t value, uint32_t valueMax 255) { //计算占空比 uint32_t duty (LED_BASE_FREQ / valueMax) * min(value, valueMax); //设置占空比 ledcWrite(LED_CHANNEL_0, duty); } void setup() { ledcSetup(LED_CHANNEL_0, LED_BASE_FREQ, LED_TIMER_13_BIT); ledcAttachPin(LED_PIN, LED_CHANNEL_0); } void loop() { ledcAnalogWrite(brightness); brightness + fadeAmount; if (brightness < 0 brightness > 255) { fadeAmount fadeAmount; } delay(30); } </code></pre> </details> 输入完成后，点击“编译”按钮检查代码是否有错误。确定没有错误后可以开始上传了，点击“上传”按钮 。IDE 会把代码发送给 PicoW S3 主板。上传完成后您就可以看见Type C旁边的LED 灯开始“呼吸”了！ 现在让我们来回顾一下代码和硬件，看看它是如何工作。 ### 知识学习 什么是 PWM 控制信号？ PWM（pulse width modulation）脉冲宽度调制，MCU（微控制器）通过对开关器件的通断进行控制，使输出端得到一系列幅值相等的脉冲，用这些脉冲来代替正弦波或所需的波形。如下图所示： ![](../assets/images/Lesson2 1.jpg) 其中，tON 是高电平持续时间，tPWM 是 PWM 波的周期，tPWM tON 是低电平持续时间，占空比是指高电平持续时间占整个周期的比例，即 D ton/tPWM 。 ### 代码分析 PicoW S3 的 PWM 比普通的 Arduino UNO 高级的多，设置上不能简单的使用analogWrite 函数来驱动 PWM，而是需要设置 timer 函数，以及相关的频率参数等才能工作。 ``` #define LEDC_CHANNEL_0 0 ``` 定义了定时器使用的通道，PicoW S3 总共有 16 个通道，这里用的是通道 0。 ``` #define LEDC_TIMER_13_BIT 13 ``` 定义了定时器为 13 位定时器，即定时器最大计数为 2 的 13 次方。 ``` #define LEDC_BASE_FREQ 5000 ``` 这是设置定时器的频率，单位是 Hz。接下来的 brightness 和 fadeAmount 参数分别表示 PWM 的占空比和每次变化的数值。 ``` void ledcAnalogWrite(uint32_t value, uint32_t valueMax 255) ``` 这个函数是计算 PWM 占空比和设置 PWM 占空比，类似 Arduino 的 analogWrite 函数，可以看到，传递参数的最大值是 255，这是为了和 analogWrite 兼容。 ``` ledcSetup(LEDC_CHANNEL_0, LEDC_BASE_FREQ, LEDC_TIMER_13_BIT); \t ledcAttachPin(LED_PIN, LEDC_CHANNEL_0); ``` 这两个函数是 PicoW S3 定时器设置函数，函数原型及原理这里不讲述，如果您感兴趣可以看看底层源码（源码地址：C:\\Users\\“your PC”\\AppData\\Local\\Arduino15\\packages\\esp32\\ hardware\\ adafruit_metro_esp32s2 \\0.0.3\\libraries\\ESP32\\），这里只需要知道怎么用这些函数来设置相关的 timer 就可以了。 关于什么是 PWM 信号，在前面已经阐述过了，这里不再说明。 >注意：PicoW S3 的任何引脚都可以配置成 PWM 输出，您可以尝试着修改代码，完成您的项目。 ## 项目三 ADC ADC（模数转换器即 A/D 转换器），是指将模拟信号转变成数字信号。PicoW S3 的ADC 是13位的，最大输出值为 8191，而 Arduino UNO 是 10 位的，最大输出值是 1023，因此，在精度上比Arduino UNO 要高，而且转换速率快，且在使用上兼容 Arduino analogRead 函数，直接读取即可。 ### 所需元件 模拟角度传感器 X 1 ![](../assets/images/Lesson3 1.png) 面包板 X 1 ![](../assets/images/Lesson3 2.png) PicoW S3 主板 X 1 ![](../assets/images/PicoW S3.png) ### 硬件连接 把 电位计插接到 PicoW S3 主板上，然后将模拟角度传感器插接到 IO2（实验中用的是IO2）。 元件连接好后，使用 USB 线连接 PicoW S3 和电脑。 ### 输入代码 打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。代码如下: <details> <summary>展开查看</summary> <pre><code> void setup() { // put your setup code here, to run once: Serial.begin(115200); } void loop() { // put your main code here, to run repeatedly: Serial.println(analogRead(2)); delay(100); } </code></pre> </details> 输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后IDE 会把代码发送给 PicoW S3 主板。上传完成后，打开 Arduino IDE 的串口监视器，旋转模拟角度传感器，可以看到串口监视器中的数值变化，如下图所示： ![](../assets/images/Lesson3 3.png) ### 代码分析 由于PicoW S3 的 ADC 在使用上完全兼容 Arduino，因此这里不再对analogRead 函数进行过多的讲解。 注意：如果您对 Arduino 的基本函数不是特别熟悉，您可以[点击链接](https://www.arduino.cc/en/Tutorial/BuiltInExamples)进行学习。 ## 项目四 I2C PicoW S3 的 I2C 可以配置到任意 I/O 口，您可以通过传递相关参数进行配置。为了方便使用，我们已经将 I2C 进行了默认配置，在使用上完全兼容 Arduino，默认配置引脚可以在第一章简介中查看到。本项目是基于 I2C 默认配置，驱动 OLED 显示屏。 所需元件 I2C OLED 12864 显示屏 X 1 ![](../assets/images/Lesson4 1.png) 面包板 X 1 ![](../assets/images/Lesson3 2.png) PicoW S3 主板 X 1 ![](../assets/images/PicoW S3.png) ### 硬件连接 把PicoW S3 主板插到面包板上，然后将 OLED显示屏插接到 I2C 接口。（SDA是33，SCL是34）元件连接好后，使用 USB 线连接 PicoW S3 和电脑。 ### 输入代码 打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。代码如下: <details> <summary>展开查看</summary> <pre><code> #include <Wire.h> int UG2864Address 0x3C;//OLED UG2864器件7位地址 prog_char F8X16[][16] PROGMEM { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,// 0 0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00,//!1 0x00,0x10,0x0C,0x06,0x10,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//\"2 0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00,//#3 0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00,//$4 0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00,//%5 0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10,//&6 0x10,0x16,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//'7 0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00,//(8 0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00,//)9 0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00,//*10 0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00,//+11 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00,0x00,0x00,//,12 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,// 13 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00,//.14 0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00,///15 0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00,//016 0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//117 0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00,//218 0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00,//319 0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00,//420 0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00,//521 0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00,//622 0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00,//723 0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00,//824 0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00,//925 0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,//:26 0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x60,0x00,0x00,0x00,0x00,//;27 0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00,//<28 0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,// 29 0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00,//>30 0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00,//?31 0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00,//@32 0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20,//A33 0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00,//B34 0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00,//C35 0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00,//D36 0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00,//E37 0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00,//F38 0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00,//G39 0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20,//H40 0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//I41 0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00,//J42 0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00,//K43 0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00,//L44 0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00,//M45 0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00,//N46 0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00,//O47 0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00,//P48 0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00,//Q49 0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20,//R50 0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00,//S51 0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//T52 0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//U53 0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00,//V54 0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00,//W55 0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20,//X56 0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//Y57 0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00,//Z58 0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00,//[59 0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00,//\\60 0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00,//]61 0x00,0x00,0x04,0x02,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//^62 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,//_63 0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//`64 0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20,//a65 0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00,//b66 0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00,//c67 0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20,//d68 0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00,//e69 0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//f70 0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00,//g71 0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//h72 0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//i73 0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,//j74 0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00,//k75 0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//l76 0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F,//m77 0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//n78 0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//o79 0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00,//p80 0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80,//q81 0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00,//r82 0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00,//s83 0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00,//t84 0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20,//u85 0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00,//v86 0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00,//w87 0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00,//x88 0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00,//y89 0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00,//z90 0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40,//{91 0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,//92 0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00,//}93 0x00,0x06,0x01,0x01,0x02,0x02,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//~94 }; char ch_buf[17] {0}; int RES 6;//Gadgeteer PIN6 int DC 7;//Gadgeteer PIN3 void Writec(unsigned char COM) { Wire.beginTransmission(UG2864Address); Wire.write(0x00); Wire.write(COM); Wire.endTransmission(); } void Writed(unsigned char DATA) { Wire.beginTransmission(UG2864Address); Wire.write(0x40); Wire.write(DATA); Wire.endTransmission(); } void SSD1306() { Writec(0XAE);//display off Writec(0X00);//set lower column address Writec(0X10);//set higher column address Writec(0X40);//set display start line Writec(0XB0);//set page address Writec(0X81);//set contract control Writec(0XCF);// VCC Generated by Internal DC/DC Circuit Writec(0XA0);//set segment remap column address 127 is mapped to SEG0 Writec(0XA6);//normal / reverse normal display Writec(0XA8);//multiplex ratio Writec(0X3F);//1/64 Writec(0XC0);//Com scan direction remapped mode. Scan from COM[N 1] to COM0 Writec(0XD3);//set display offset Writec(0X00); Writec(0XD5);//set osc division Writec(0X80); Writec(0XD9);//set pre charge period Writec(0X11); Writec(0XDa);//set COM pins Writec(0X12); Writec(0X8d);/*set charge pump enable*/ Writec(0X14); Writec(0Xdb);//Set VcomH Writec(0X20); Writec(0XAF);//display ON } void fill(unsigned char dat) { unsigned char i,j; Writec(0x00);//set lower column address Writec(0x10);//set higher column address Writec(0xB0);//set page address for(j 0;j<8;j++) { Writec(0xB0+j);//set page address Writec(0x00);//set lower column address Writec(0x10);//set higher column address for(i 0;i<128;i++) { Writed(dat); } } } void show_string(unsigned char x,unsigned char y,char *s) { unsigned char i,j,lower,higher; char *t; t s; lower y%16; higher y/16; if((x>3) (y>120)) return; Writec(0xB0+x*2);//set page address Writec(lower);//set lower column address Writec(0x10+higher);//set higher column address for(j 0;*s! '\\0';j++) { for(i 0;i<8;i++){ ch_buf[i] pgm_read_word(&F8X16[*s 32][i]); } for(i 0;i<8;i++) Writed(ch_buf[i]); s++; } Writec(0xB0+x*2+1);//set page address Writec(lower);//set lower column address Writec(0x10+higher);//set higher column address s t; for(j 0;*s! '\\0';j++) { for(i 0;i<8;i++){ ch_buf[i] pgm_read_word(&F8X16[*s 32][i+8]); } for(i 0;i<8;i++) Writed(ch_buf[i]); s++; } } void oled_init(void) { pinMode(RES,OUTPUT);//RES pinMode(DC,OUTPUT);//D/C# digitalWrite(DC,LOW); Wire.begin(); digitalWrite(RES,HIGH); delay(100); digitalWrite(RES,LOW); delay(100); digitalWrite(RES,HIGH); delay(100); SSD1306(); fill(0x00); } void setup() { oled_init(); } void loop() { fill(0x00); show_string(0,12,\"BananaPi\"); show_string(2,12,\"banana pi.org\"); while(1); } </code></pre> </details> 输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后 IDE \t会把代码发送给 PicoW S3 主板。上传完成后，OLED 显示屏会显示“BananaPi banana pi.org”字样。 ### 代码分析 本项目的代码相对于前面的项目较多，主要是基于 I2C 通信对 OLED 显示屏底层寄存器的直接驱动。 ``` void Writec(unsigned char COM) ``` 设置寄存器函数，通过 I2C 对 OLED 显示屏设置，I2C 使用方法完全兼容 Arduino。 ``` void Writed(unsigned char DATA) ``` 写数据函数，I2C 使用方法完全兼容 Arduino。 >注意：PicoW S3 的 I2C 与 Arduino 完全兼容，主要是调用 Wire 库文件使用。 ## 项目五 SPI 在很多传感器中，都使用 SPI 通信，因为 SPI 通信速率相对于 I2C 更快，没有地址冲突的弊端。SPI，是 一种高速的、全双工、同步的通信总线，而 PicoW S3 的 SPI 可以配置到所有 I/O，您可以阅览底层 代码进行使用（初学者不建议使用）。为了更好的使用体验，PicoW S3 默认情况下配置了IO35、IO36、IO37 为 SPI 口，在使用上则完全兼容 Arduino。 本项目使用 PicoW S3，通过 SPI 读取 BME280 温湿度传感器的数据，示例中使用的是BME280 库文件，关于 SPI 驱动您可以阅览 BEM280 库文件，[点击链接](https://github.com/DFRobot/DFRobot_BME280)下载 BME280 库文件。 ### 所需元件 BME280 温湿度传感器 X 1 ![](../assets/images/Lesson5 1.png) >注意：BME280 传感器本身支持 I2C 和 SPI 通信，这里我们采用 SPI 通信。 面包板 X 1 ![](../assets/images/Lesson3 2.png) PicoW S3 主板 X 1 ![](../assets/images/PicoW S3.png) ### 输入代码 打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。 （这个程序需要DFRobot_BME280库，需要在[GitHub](https://github.com/DFRobot/DFRobot_BME280)下载，解压到Arduino\\ Library 文件夹下 ）代码如下： <details> <summary>展开查看</summary> <pre><code> /*! * read_data_spi.ino * * Download this demo to test read data from bme280, connect sensor through spi interface * Connect cs pin to io 2 * Data will print on your serial monitor * * Copyright [DFRobot](http://www.dfrobot.com), 2016 * Copyright GNU Lesser General Public License * * version V1.0 * date 12/03/2019 */ #include \"DFRobot_BME280.h\" #include \"Wire.h\" typedef DFRobot_BME280_SPI BME; // ******** use abbreviations instead of full names ******** # define PIN_CS 2 BME bme(&SPI, PIN_CS); // select TwoWire peripheral and set cs pin id #define SEA_LEVEL_PRESSURE 1015.0f // show last sensor operate status void printLastOperateStatus(BME::eStatus_t eStatus) { switch(eStatus) { case BME::eStatusOK: Serial.println(\"everything ok\"); break; case BME::eStatusErr: Serial.println(\"unknow error\"); break; case BME::eStatusErrDeviceNotDetected: Serial.println(\"device not detected\"); break; case BME::eStatusErrParameter: Serial.println(\"parameter error\"); break; default: Serial.println(\"unknow status\"); break; } } void setup() { Serial.begin(115200); bme.reset(); Serial.println(\"bme read data test\"); while(bme.begin() ! BME::eStatusOK) { Serial.println(\"bme begin faild\"); printLastOperateStatus(bme.lastOperateStatus); delay(2000); } Serial.println(\"bme begin success\"); delay(100); } void loop() { float temp bme.getTemperature(); uint32_t press bme.getPressure(); float alti bme.calAltitude(SEA_LEVEL_PRESSURE, press); float humi bme.getHumidity(); Serial.println(); Serial.println(\" start print \"); Serial.print(\"temperature (unit Celsius): \"); Serial.println(temp); Serial.print(\"pressure (unit pa): \"); Serial.println(press); Serial.print(\"altitude (unit meter): \"); Serial.println(alti); Serial.print(\"humidity (unit percent): \"); Serial.println(humi); Serial.println(\" end print \"); delay(1000); } </code></pre> </details> 输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后 IDE 会把代码发送给 PicoW S3 主板。打开 Arduino 串口监视器，可以看到打印信息如下： ![](../assets/images/Lesson5 2.png) ### 代码分析 本项目采用的是 BME280 库文件，在 Item 5.ino 文件中并没有对 SPI 底层进行操作，不过，PicoW ESP32 S3 的 SPI 使用完全兼容 Arduino。 ## 项目六 WS2812 PicoW S3 集成了一个型号为WS2812的RGB彩灯。 本项目是点亮 PicoW S3 的RGB彩灯的实验， ### 所需元件 LPicoW S3 主板 X 1 ![](../assets/images/PicoW S3.png) >注意：该项目不需要连接其他传感器。 ### 输入代码 打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。 （这个程序需要Adafruit_NeoPixel库，需要在[GitHub](https://github.com/adafruit/Adafruit_NeoPixel)下载，解压到Arduino\\ Library 文件夹下）代码如下: <details> <summary>展开查看</summary> <pre><code> // NeoPixel Ring simple sketch (c) 2013 Shae Erisson // Released under the GPLv3 license to match the rest of the // Adafruit NeoPixel library #include <Adafruit_NeoPixel.h> #ifdef __AVR__ #include <avr/power.h> // Required for 16 MHz Adafruit Trinket #endif // Which pin on the Arduino is connected to the NeoPixels? #define PIN 18 // On Trinket or Gemma, suggest changing this to 1 // How many NeoPixels are attached to the Arduino? #define NUMPIXELS 1 // Popular NeoPixel ring size // When setting up the NeoPixel library, we tell it how many pixels, // and which pin to use to send signals. Note that for older NeoPixel // strips you might need to change the third parameter see the // strandtest example for more information on possible values. Adafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800); #define DELAYVAL 500 // Time (in milliseconds) to pause between pixels void setup() { // These lines are specifically to support the Adafruit Trinket 5V 16 MHz. // Any other board, you can remove this part (but no harm leaving it): #if defined(__AVR_ATtiny85__) && (F_CPU 16000000) clock_prescale_set(clock_div_1); #endif // END of Trinket specific code. pixels.begin(); // INITIALIZE NeoPixel strip object (REQUIRED) } void loop() { pixels.clear(); // Set all pixel colors to 'off' // The first NeoPixel in a strand is #0, second is 1, all the way up // to the count of pixels minus one. for(int i 0; i < NUMPIXELS; i++) { // For each pixel... // pixels.Color() takes RGB values, from 0,0,0 up to 255,255,255 // Here we're using a moderately bright green color: pixels.setPixelColor(i, pixels.Color(0, 150, 0)); pixels.show(); // Send the updated pixel colors to the hardware. delay(DELAYVAL); // Pause before next pass through loop } } </code></pre> </details> 输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后 IDE 会把代码发送给 PicoW S3 主板。复位后WS2812灯会开始亮绿灯， >注意：如果需要其他颜色，可以修改代码中的RGB值。 ### 代码分析 本项目使用 PicoW S3 集成的WS2812灯，默认GPIO是48。 ``` #define PIN 48 ``` 设置GPIO引脚号 ``` #define NUMPIXELS 1 ``` 设置灯的个数，如果您想连接更多WS2812，可以换一个IO，并修改灯的数量。 ## 项目七 触摸传感器 PicoW S3 提供了多达 14 个电容式传感器 GPIO，能够探测由手指或其他物品直接接触或接近而产生的电容差异。这种低噪声特性和电路的高灵敏度设计适用于较小的触摸板，可以直接用于触摸开关。本项目阐述了如何通过Arduino 代码获取 PicoW S3 的触摸传感器状态，并打印状态。 ### 所需元件 PicoW S3 主板 X 1 ![](../assets/images/PicoW S3.png) >注意：该项目不需要连接其他传感器。 ### 输入代码 打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。 代码如下: <details> <summary>展开查看</summary> <pre><code> void setup() { Serial.begin(115200); delay(1000); // give me time to bring up serial monitor Serial.println(\"PicoW S3 Touch Test\"); } void loop(){ Serial.println(touchRead(T2)); // get value using T0 >D9 delay(100); } </code></pre> </details> 输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后 IDE 会把代码发送给 PicoW S3 主板。打开 Arduino IDE 串口监视器，并用手触摸 GPIO2（T2 对应的是GPIO2），可以看到会打印出的数据突然变小，如下图所示： ![](../assets/images/Lesson8 1.png) ### 代码分析 获取触摸传感器的 GPIO 状态，只需要调用 touchRead 函数，函数原型如下： ``` uint16_t touchRead(uint8_t pin) ``` 返回“0”表示没有触摸，“1”表示触摸。其中 pin 是 T0~T9，对应到 PicoW 的引脚如下表所示： <table> <tr> <td></td> </tr> <tr> <td>触摸传感器序号 </td> <td>对应的 ESP32 硬件 </td> <td>PicoW S3</td> <td> </td> </tr> <tr> <td>T1</td> <td>GPIO1</td> <td>IO1</td> </tr> <tr> <td>T2 </td> <td>GPIO2 </td> <td>IO2</td> </tr> <tr> <td>T3 </td> <td>GPIO3</td> <td>IO3</td> </tr> <tr> <td>T4 </td> <td>GPIO4</td> <td>IO4</td> </tr> <tr> <td>T5 </td> <td>GPIO5</td> <td>IO5</td> </tr> <tr> <td>T6 </td> <td>GPIO6</td> <td>IO6</td> </tr> <tr> <td>T7 </td> <td>GPIO7</td> <td>IO7</td> </tr> <tr> <td>T8 </td> <td>GPIO8</td> <td>IO8</td> </tr> <tr> <td>T9 </td> <td>GPIO9</td> <td>IO9</td> </tr> <tr> <td>T10</td> <td>GPIO10</td> <td>IO10</td> </tr> <tr> <td>T11</td> <td>GPIO11</td> <td>IO11</td> </tr> <tr> <td>T12</td> <td>GPIO12</td> <td>IO12</td> </tr> <tr> <td>T13</td> <td>GPIO13</td> <td>IO13</td> </tr> <tr> <td>T14</td> <td>GPIO14</td> <td>IO14</td> </tr> <tr> <td></td> </tr> </table>"},"/PicoW_S3_doc/zh/Arduino/Environment.html":{"title":"环境搭建","content":"# 环境搭建 由于板型原因，PicoW S3的Arduino使用会比较复杂，我们不太推荐您使用PicoW S3学习Arduino。这篇文章将会指引您安装PicoW S3的Arduino支持。 ![](../assets/images/logo_arduino.png) > 参考[arduino esp32 DOC Getting Started » Installing](https://docs.espressif.com/projects/arduino esp32/en/latest/installing.html) ## 使用Arduino IDE安装支持 这是直接从 Arduino IDE 安装 Arduino ESP32 的方法。 > 从 Arduino IDE 版本 1.6.4 开始，Arduino 允许使用 Boards Manager（开发板管理器）安装第三方平台包。有适用于 Windows、macOS 和 Linux 的软件包。 Arduino IDE 下载地址：https://www.arduino.cc/en/software > Arduino IDE 2.0与Arduino IDE 1.8.x的UI有些许差异，本文基于1.8.13版本编写，但不影响使用2.0版本的用户参考。 要使用 Boards Managaer（开发板管理器）安装esp32平台包，请执行以下步骤： 安装当前上游 Arduino IDE 1.8 或更高版本。 启动 Arduino 并打开 File（文件）> Preferences（首选项）窗口，找到Additional Board Manager URLs（附加开发板管理器网址）。 ![](../assets/images/install_guide_preferences.png) 稳定版链接： ``` https://raw.githubusercontent.com/espressif/arduino esp32/gh pages/package_esp32_index.json ``` 开发版链接： ``` https://raw.githubusercontent.com/espressif/arduino esp32/gh pages/package_esp32_dev_index.json ``` 在Additional Board Manager URLs后面输入上述发布链接之一。您可以添加多个 URL，一行一个。 ![](../assets/images/install_guide_boards_manager_url.png) 从菜单打开 Tools（工具） > Board（开发板）> Board Manager（开发板管理器） 搜索并安装esp32平台。 ![](../assets/images/install_guide_boards_manager_esp32.png) 重启arduino IDE之后可以看到在开发板选项中多了ESP32 Arduino选项。 选择 `ESP32S3 Dev Module` 这个型号，再参照下图所示的内容进行配置一遍即可，配置不当是无法使用的，请一定要参照下图所示的内容进行配置！ ![](../assets/images/Board_chose.jpg)"},"/PicoW_S3_doc/zh/index.html":{"title":"【 BPI-PicoW-S3 开发板 】","content":"# 【 BPI PicoW S3 开发板 】 ## 介绍 ![](assets/images/BPI PicoW S3.jpg) 香蕉派BPI PicoW是一款低功耗微控制器，专为物联网开发和Maker DIY设计的开发板。与 Raspberry Pi Pico 板尺寸相同，支持 2.4 GHz Wi Fi 和 Bluetooth® LE 双模无线通信， 外设兼容低功耗硬件设计，深度睡眠模式下功耗仅为10uA。编程方面，PicoW S3支持ESP IDF、Arduino、micropython、CircuitPython 等多种方式。 ## 使用 CircuitPython 编程 > BPI PicoW S3出厂已安装tinyUF2与CircuitPython固件,推荐通过CircuitPython快速上手BPI PicoW S3开发板。 ![](assets/images/CircuitPython_Repo_header_logo.jpg) CircuitPython是旨在简化在单片机开发板上进行编程实验和学习的一种编程语言。 配合Mu编辑器进行CircuitPython编程是最低难度的上手方法，安装软件，连接设备即可开始使用。 ## 使用 MicroPython 编程 MicroPython实现了大部分Python 3 特性和语法，易学易上手，验证程序效果无需编译直接下载进芯片运行。 无论是否有编程基础，MicroPython的上手难度绝对远低于其他编程语言，其代码易读性高，且开源社区有多年积累的丰富资源，就如同Python一样拥有极强的生命力与应用价值。 通过烧写 MicroPython 固件，就可以在开发板中使用 Python 语言进行编程。 ![](assets/images/Mircopython.png) ## 使用 Arduino 编程 提供了入门 Arduino 的软件工具和最佳示例，降低进入 ESP32 嵌入式专业开发的门槛。 ![](assets/images/Arduino_logo_1200x350.png) >Arduino 将不会阐述过多基础内容，请具备 C/C++ 的语言开发基础。 ## 资料与资源 [官方WIKI](https://wiki.banana pi.org/BPI PicoW S3_%E5%BC%80%E5%8F%91%E6%9D%BF) [GitHub: BPI PicoW S3 开发板原理图PDF](https://github.com/BPI STEAM/BPI PicoW Doc/blob/main/sch/BPI PicoW V0.4.pdf) [ESP32 S3 技术规格书](https://www.espressif.com/sites/default/files/documentation/esp32 s3_datasheet_cn.pdf) [ESP32 S3 技术参考手册](https://www.espressif.com/sites/default/files/documentation/esp32 s3_technical_reference_manual_cn.pdf) ## 样品购买 [官方速卖通](https://www.aliexpress.com/item/1005004775634442.html?spm 5261.ProductManageOnline.0.0.15744edfAyCaNk) [官方淘宝](https://item.taobao.com/item.htm?spm a2126o.success.0.0.25b04831CHV1Nc&id 684134360199) OEM&OEM 定制服务 ： sales@banana pi.com"},"/PicoW_S3_doc/zh/no_translate.html":{"title":"no_translate_title","content":" title: no_translate_title class: md_page <div id \"visit_from\"></div> <div id \"no_translate_hint\">no_translate_hint</div> <div> <span id \"visit_hint\">visit_hint</span> <a id \"translate_src\"></a> </div> <div> <script> function getQueryVariable(variable) { var query window.location.search.substring(1); var vars query.split(\"&\"); for (var i 0;i<vars.length;i++) { var pair vars[i].split(\" \"); if(pair[0] variable){return pair[1];} } return(false); } var ref getQueryVariable(\"ref\"); var from getQueryVariable(\"from\"); var link document.getElementById(\"translate_src\"); var fromDis document.getElementById(\"visit_from\"); link.href ref; link.text ref; fromDis.innerHTML from; </script> </div>"}}