{"/Pico_RP2040_doc/zh_tw/Unboxing/Introduction.html":{"title":"开发板介绍","content":"# 开发板介绍 香蕉派Pico系列是專為物聯網設計的低功耗微控制器開發板。 BPI Pico RP2040是 Banana Pi 推出的一款搭载RP2040芯片的微控制器开发板，其最显著的特性是，在尽量保留Raspberry Pi Pico的功能，外形尺寸，引脚布局的前提下，增加一颗板载 WS2812 彩色LED；将 3 Pin DEBUG 接口替换为一个SH 1mm 4 Pin 插座，可与 Qwiic & STEMMA QT 或任何可能的外设连接；将micro USB插座替换为USB Type C插座，支持正反插，与绝大多数现代智能手机的USB Type C线通用，无需额外购买。 ## 关键特性 双核 ARM Cortex M0+ CPU 内核（高达 133 MHz） 264K SRAM 2MB Flash 26个可用GPIO引脚，其中4个支持ADC模拟输入 外设: 2 × UART 2 × SPI 控制器 2 × I2C 控制器 16 × PWM 通道 1 × USB 1.1 控制器和PHY，支持主机和设备 8 × PIO 状态机 1 × LED 1 × WS2812 LED 1 × SH 1mm 4 Pin 插座 1 × USB Type C插座 ## 硬件 ### 接口示意图 ![](../assets/images/BPI Pico RP2040 V0.2 IO.jpg) ### 硬件尺寸 ![](../assets/images/BPI Pico RP2040 V0.2 dimension.jpg) <table> <tr> <td>BPI Pico RP2040 尺寸表</td> </tr> <tr> <td>管脚间距</td> <td>2.54mm</td> </tr> <tr> <td>安装孔间距</td> <td>17.6mm/ 11.4mm</td> </tr> <tr> <td>安装孔尺寸</td> <td>内径2.1mm/外径3.4mm</td> </tr> <tr> <td>主板尺寸</td> <td>11.4 × 55.8(mm)</td> </tr> <tr> <td>板厚</td> <td>1.2mm</td> </tr> <tr> <td></td> </tr> </table> 管脚间距兼容万能板（洞洞板、点阵板），面包板，并且能直接贴在其他PCB上，便于调试应用。 ## 参考资料与资源 [GitHub: BPI Pico RP2040 开发板原理图PDF]() [RP2040 技术规格书](https://datasheets.raspberrypi.com/rp2040/rp2040 datasheet.pdf) [RP2040 技术参考手册](https://datasheets.raspberrypi.com/rp2040/hardware design with rp2040.pdf) [rp2040 product brief.pdf](https://datasheets.raspberrypi.com/rp2040/rp2040 product brief.pdf) [raspberry pi pico python sdk.pdf](https://datasheets.raspberrypi.com/pico/raspberry pi pico python sdk.pdf)"},"/Pico_RP2040_doc/zh_tw/Programming/Arduino_Gettingstart.html":{"title":"","content":"## Arduino 下載與安裝 Arduino IDE 下載地址：https://www.arduino.cc/en/software 選擇與操作系統對應的版本下載，按照安裝提示逐步安裝。 ## 安裝RP2040開發板支持包 以Arduino IDE 2.0.2為例，在Boards Manager的搜索欄中輸入`PICO`或`RP2040`，選擇`Arduino Mbed OS RP2040 Boards`，單擊`Install`安裝RP2040開發板支持包，默認安裝最新版本即可。 ![](../assets/images/arduino_env_1.png) ## 設置板型 在上方選項欄中依次點選 Tools > Boards > Arduino Mbed OS RP2040 Boards > Raspberry Pico。 ![](../assets/images/arduino_env_2.png) ## 連接開發板 初次在BPI Pico RP2040開發板上使用Arduino，需要手動讓開發板進入一次UF2 Bootloader模式，後續通常可免除此步驟。 確保有一根type c數據線，一端連接到PC，拿起開發板，保持上面無任何連線或外圍硬件，按住Boot按鈕，將type c數據線與開發板連接，鬆開Boot按鈕，PC的系統中將出現一個名為RPI RP2的新磁盤。 ## 點亮LED 在上方選項欄中依次點選 File > Examples > 01.Basics > Blink , 打開 Blink 例程， ![](../assets/images/arduino_env_3.png) 或直接在代碼編輯區輸入以下代碼。 ```c void setup() { // initialize digital pin LED_BUILTIN as an output. pinMode(LED_BUILTIN, OUTPUT); } // the loop function runs over and over again forever void loop() { digitalWrite(LED_BUILTIN, HIGH); // turn the LED on (HIGH is the voltage level) delay(1000); // wait for a second digitalWrite(LED_BUILTIN, LOW); // turn the LED off by making the voltage LOW delay(1000); // wait for a second } ``` 點擊 `Upload` 按鈕，程序將在編譯完成後上傳至開發板，板載LED將間隔1秒閃爍。 ## 參考資源 [RP2040 Arduino文檔](https://arduino pico.readthedocs.io/en/latest/)"},"/Pico_RP2040_doc/zh_tw/Programming/MicroPython_Gettingstart.html":{"title":"","content":"## MicroPython 固件下載與燒錄 在[MicroPython官網](https://micropython.org/)可以找到支持RP2040芯片的固件，BPI Pico RP2040完全兼容Raspberry Pi Pico的固件: https://micropython.org/download/rp2 pico/ 點擊連接進入頁面後即可在下方看到幾列固件下載地址，推薦選擇下載Releases欄的第一項，兼顧穩定性與新功能特性，後續例程基於v1.19.1固件編寫。 ![](../assets/images/micropython_env_1.png) Nightly builds 欄所提供的固件為每日構建，將擁有最新的功能特性，但穩定性可能稍差，且可能尚沒有對應最新功能的使用文檔。 下載完成後將得到一個 .uf2 擴展名的文件，將其燒錄到BPI Pico RP2040開發板的方式非常簡單，先確保有一根type c數據線，一端連接到PC，拿起開發板，保持上面無任何連線或外圍硬件，按住Boot按鈕，將type c數據線與開發板連接，鬆開Boot按鈕，PC的系統中將出現一個名為RPI RP2的新磁盤，將.uf2文件複製到此盤中，複製完成後開發板將自動復位，進入 MicroPython 模式。 ## 安裝Thonny IDE 以Windows為例，點擊連接下載 [thonny 3.3.13.zip](../assets/images/thonny 3.3.13.zip)，解壓後得到`thonny 3.3.13.exe`。 運行`thonny 3.3.13.exe`，按照安裝提示逐步操作即可順利完成安裝 。 也可通過pip安裝，`pip install thonny 3.3.13`，需要具備[Python](https://www.python.org/)環境，適用於macOS或Linux。 ## 建立開發板與Thonny的連接 連接開發板與電腦。 運行Thonny，點擊 Run > Select interpreter 。 ![](../assets/images/micropython_env_2.png) 選擇 MicroPython(Raspberry Pi Pico) 。 ![](../assets/images/micropython_env_3.png) 選擇開發板所在的串行接口，點擊OK確認設置。 ![](../assets/images/micropython_env_4.png) 勾選 View > Files 即可打開文件管理欄。 ![](../assets/images/micropython_env_5.png) ## 使用REPL輸出Hello World **REPL**即**Read Eval Print Loop**的縮寫名詞，譯為 **讀取 求值 輸出 循環**。 我們可以通過實際操作來明白它的意思。 將已經安裝了MicroPython固件的開發板連接電腦，運行Thonny IDE並正確配置後，在Shell窗口中將出現這樣的文本內容： ``` MicroPython v1.19.1 on 2022 06 18; Raspberry Pi Pico with RP2040 Type \"help()\" for more information. >>> ``` 注意最後一行的`>>>`提示符，我們可以直接在這後面輸入算式或是代碼，按下鍵盤`enter`回車鍵就會立即在下一行得到輸出結果。 ```python >>> 1+2 3 >>> print(\"Hello World\") Hello World >>> ``` 現在可以很直觀的理解了，它會讀取我們輸入的信息，執行運算求值，輸出結果，然後等待我們後續的輸入，一直循環這個過程，這也是**REPL**又被譯為**交互式解釋器**的原因，我們可以直接通過輸入代碼來和硬件交互，沒有像傳統的C語言那樣需要在中間執行編譯的過程，我們輸入的信息沒有經過編譯就傳輸給芯片自行解釋並運行了，這本就是Python語言的一大重要特性，MicroPython完美繼承了它。 如果僅僅是使用MicroPython REPL，很多具有串口信息收發功能的軟件都可以操作，感興趣的話可以試試各種串口工具，這可以令人更深刻的理解 “沒有中間執行編譯的過程” 的意思。 >關於REPL的應用，更詳盡全面的內容可以參考[MicroPython文檔：REPL](https://docs.micropython.org/en/latest/reference/repl.html) ## 代碼編輯器 Thonny IDE當然不僅僅可以進行REPL的操作，作為python代碼編輯器，本職功能還是有的。 新建一個文件並在其編輯區內輸入代碼。 ```python print(1+2) print(\"Hello World\") ``` 完成代碼編輯後，點擊 **Save**，可以選擇將文件保存到開發板中，這將直接將整個文件傳輸到開發板的flash中。可將文件命名為`main.py`，設備會在每次上電或複位後執行它。 ![](../assets/images/Quick_Start.png) 現在點擊 **Run current script** 運行，同樣是無需編譯的，在Shell中會立即得到結果。 ``` 3 Hello World ``` 另外也可以嘗試REPL的鍵盤控制快捷鍵**ctrl+D**軟件復位，可以看到復位後程序立即執行並打印出信息。 ## 點亮LED BPI Pico RP2040上的板載LED連接到GPIO 25引腳，你可以在REPL上點亮它。當你看到REPL提示`>>>`時，請輸入以下代碼。 ```python >>> from machine import Pin >>> led Pin(25, Pin.OUT) ``` > `machine`模塊用於控制開發板上的硬件。這是所有MicroPython端口的標準配置，你可以在[MicroPython文檔：machine](https://docs.micropython.org/en/v1.19.1/library/machine.html)中了解更多有關它的信息。 輸入以下代碼LED將亮起。 ```python >>> led.value(1) ``` 輸入以下代碼將熄滅LED。 ```python >>> led.value(0) ``` ## 使用板載彩燈 BPI Pico RP2040上的板載 WS2812 彩燈連接到GPIO 3引腳，它僅需一個信號線即可控制，在REPL中輸入以下代碼。 ```python >>> from machine import Pin >>> from neopixel import NeoPixel >>> neo NeoPixel(Pin(3), 1) ``` > `neopixel`模塊為 WS2812 彩燈提供驅動程序。你可以在[MicroPython文檔：neopixel](https://docs.micropython.org/en/v1.19.1/library/neopixel.html)中了解更多有關它的信息。 輸入以下代碼，彩燈將亮起紅色。 ```python >>> neo[0] (25,0,0) >>> neo.write() ``` `neo[0] (25,0,0)`設定第一顆彩燈的顏色。 WS2812 彩燈內有三顆純色LED，它們的顏色分別是紅，綠，藍，`(25,0,0)`元組中的元素依次對應控制它們的亮度，數值範圍 0 ~ 255， 元素的數值越大，它所控制的純色LED就越亮。 建議將元素的數值控制在50以下，數值過高時近距離直視會刺眼。 `neo.write()`執行後，芯片會將控制信號傳輸給這顆板載的 WS2812 彩燈。 你可以嘗試自行修改元組中的數據，控制彩燈的顏色，例如繼續在REPL中輸入以下代碼，使彩燈亮白色。 ```python >>> neo[0] (25,25,25) >>> neo.write() ``` ## 參考資源 [raspberry pi pico python sdk.pdf](https://datasheets.raspberrypi.com/pico/raspberry pi pico python sdk.pdf)"},"/Pico_RP2040_doc/zh_tw/index.html":{"title":"【 BPI-Pico-RP2040 開發板 】","content":"# 【 BPI Pico RP2040 開發板 】 ## 介紹 ![](assets/images/BPI Pico RP2040.jpg) 香蕉派Pico系列是專為物聯網設計的低功耗微控制器開發板。 BPI Pico RP2040 是 Banana Pi 推出的一款搭載RP2040芯片的微控制器開發板，其最顯著的特性是，在盡量保留Raspberry Pi Pico的功能，外形尺寸，引腳佈局的前提下，增加一顆板載 WS2812 彩色LED；將 3 Pin DEBUG 接口替換為一個SH 1mm 4 Pin 插座，可與 Qwiic & STEMMA QT 或任何可能的外設連接；將micro USB插座替換為USB Type C插座，支持正反插，與絕大多數現代智能手機的USB Type C線通用，無需額外購買。 跳轉到 [開箱 BPI Pico RP2040 開發板](Unboxing/Introduction.html) 頁面查看詳情。 ## 使用 MicroPython 編程 ![](assets/images/Mircopython.png) MicroPython實現了大部分Python 3 特性和語法，易學易上手，驗證程序效果無需編譯直接下載進芯片運行。 無論是否有編程基礎，MicroPython的上手難度絕對遠低於其他編程語言，其代碼易讀性高，且開源社區有多年積累的豐富資源，就如同Python一樣擁有極強的生命力與應用價值。 通過燒寫 MicroPython 固件，就可以在開發板中使用 Python 語言進行編程。 ## 使用 Arduino 編程 提供了入門 Arduino 的軟件工具和最佳示例，降低進入 ESP32 嵌入式專業開發的門檻。 ![](assets/images/Arduino_logo_1200x350.png) >Arduino 將不會闡述過多基礎內容，請具備 C/C++ 的語言開發基礎。 ## 參考資源 [BPI Pico RP2040 官方 WIKI](https://wiki.banana pi.org/BPI Pico RP2040_%E5%BC%80%E5%8F%91%E6%9D%BF) [GitHub: BPI Pico RP2040 開發板原理圖PDF](https://github.com/BPI STEAM/BPI Pico RP2040 Doc/blob/main/BPI Pico RP2040 V0.2 SCH.pdf) [rp2040 datasheet.pdf](https://datasheets.raspberrypi.com/rp2040/rp2040 datasheet.pdf) [rp2040 product brief.pdf](https://datasheets.raspberrypi.com/rp2040/rp2040 product brief.pdf) ## 樣品購買 [官方速賣通]() [官方淘寶]() OEM&OEM 定制服務 ： sales@banana pi.com"},"/Pico_RP2040_doc/zh_tw/no_translate.html":{"title":"no_translate_title","content":" title: no_translate_title class: md_page <div id \"visit_from\"></div> <div id \"no_translate_hint\">no_translate_hint</div> <div> <span id \"visit_hint\">visit_hint</span> <a id \"translate_src\"></a> </div> <div> <script> function getQueryVariable(variable) { var query window.location.search.substring(1); var vars query.split(\"&\"); for (var i 0;i<vars.length;i++) { var pair vars[i].split(\" \"); if(pair[0] variable){return pair[1];} } return(false); } var ref getQueryVariable(\"ref\"); var from getQueryVariable(\"from\"); var link document.getElementById(\"translate_src\"); var fromDis document.getElementById(\"visit_from\"); link.href ref; link.text ref; fromDis.innerHTML from; </script> </div>"}}