{"/WebBit_dev/zh/getting_started/driver.html":{"title":"驱动安装","content":"# 驱动安装 ## 连接板子 本产品采用 CH340 / CH341 串口驱动芯片，可以轻松的在 Windows 、 Linux 等系统下自动安装驱动。 > [CH341SER 相关系统驱动](http://www.wch.cn/download/CH341SER_ZIP.html) 将板子通过 MicroUSB 线连接到你的电脑里，以下以 Windows 10 为例。 ![](../assets/getting_started/driver/connect.png) ## 查看驱动 进入 **设备管理器** 确认串口驱动（Serial）是否安装，进入方法如下。 （右键）此电脑 > 属性 > **设备管理器** 开始菜单 > （输入）**设备管理器** 控制面板 > （搜索）**设备管理器** ![](../assets/getting_started/driver/error.png) 可以看到 设备显示 **USB2.0 Serial** ，说明**未安装驱动**，若此前已安装驱动，可以跳至步骤 5 。 ## 安装驱动 点此获取 [Serial CH341](http://www.wch.cn/downloads/file/5.html) 驱动，并按如下说明操作安装驱动 打开下载的 **CH341SER.ZIP** 压缩包，进入 **CH341SER** 文件夹，打开 **SETUP.EXE**，即可看到如下图。 ![](../assets/getting_started/driver/install.png) 点击 **INSTALL** （安装），等待片刻即可完成安装。 ## 确认串口 核对板子是否连接成功 ![](../assets/getting_started/driver/success.png) 可以看到原来的 **USB2.0 Serial** 消失了，取而代之的是 **USB SERIAL CH340(COM3)**，这意味着你已经成功安装驱动，并且得到板子串口名称为（**COM3**），你可以通过各种串口工具来查看串口名（COM3）的板子传出的信息。 ## 其他系统 至此板子连接成功，是 Linux 或 Mac 系统则需要你自行 baidu 或 Google 了。"},"/WebBit_dev/zh/getting_started/hardware.html":{"title":"开发板介绍","content":"# 开发板介绍 ![](../assets/https://img.shields.io/badge/open%20source bananpi brightgreen.svg) ![](../assets/https://img.shields.io/badge/support webduino blue.svg) ![](../assets/../assets/_static/facade.gif) 本产品采用 ESP WROOM 32 （ESP32）模组作为核心进行设计，拥有 40nm 工艺、使用 Tensilica LX6 双核32位处理器，频率高达 240 MHz，带有 32 个 I/O 引脚，支持 2.4G Wi Fi 、蓝牙 4.0 以上等多种通信方式，具备 448KB ROM 和 520 KB SRAM 的内存容量，处理速度达 600 DMIPS，搭配 40nm 工艺的超低功耗，是目前市面上最高效能、最稳定以及最通用的产品之一。 它又名 Webduino Bit ，是 Webduino 最新的开发板，除了原本的功能一应俱全 ( Wi Fi 控制、多装置并联、协同工作... 等 )，更是内置了许多有趣的组件与传感器。 同时 bpi:bit 开源社区还将持续兼容 micro:bit 的大部分配件以及用法。 ## 外观介绍 ![](../assets/getting_started/hardware/Interface_CN.jpg) Webduino Bit 开发板长 5 公分宽 5 公分，重量约 10 ~ 12 公克，除了下方 20 Pin 的「金手指接口」，更内置一个 25 颗全彩 LED 灯的矩阵，两个光敏电阻、两个按钮开关、一个温度感应电阻、一个蜂鸣器和一个九轴传感器 ( 三轴加速度、三轴陀螺仪与三轴磁力指南针 )，脚位配置如下： 全彩 LED 矩阵：A10 ( GPIO 4 ) 光敏传感器：左上 A0 ( GPIO 36 )、右上 A3 ( GPIO 39 ) 按钮开关：按钮 A P5 ( GPIO 35 )、按钮 B P11 ( GPIO 27 ) 温度传感器：A6 ( GPIO 34 ) 蜂鸣器：P0 ( GPIO 25 ) 九轴传感器 MPU 9250：P20 ( GPIO 21 )、P19 ( GPIO 22 ) ## 拓展引脚 ![](../assets/getting_started/hardware/goldfinger.jpg) ![](../assets/getting_started/hardware/pin define.jpg) ### LED 编号 板子按照 5 * 5 排列方式焊接了 25 颗(编号 0 ~ 24 ) 1600 万色全彩 LED (WS2812) ，所有的 LED 的控制仅使用一个引脚 (GPIO 4) 即可控制。 ![](../assets/getting_started/hardware/product.jpg) 板子正面 LED 序号排布方式如下（5 * 5） ![](../assets/getting_started/hardware/table.png) （将板子正面朝向自己，并结合底盘金手指可知其位置） ## 版本区别 板子分 1.2 和 1.4 版本等多个版本，版本号标识在板子背面右下角。 ![](../assets/getting_started/hardware/version.jpg) ## 产品支持 [**安装驱动**](driver.html) ### Webduino [Webduino 基础教学](https://webduino.com.cn/site/zh_cn/tutorials.html) [Webduino 玩家指南](https://github.com/BPI STEAM/BPI BIT WebDuino) [Webduino 中文社区](https://forum.banana pi.org.cn/c/bpi bit/webduino) ### MicroPython [MicroPython 玩家指南](https://github.com/BPI STEAM/BPI BIT MicroPython) [MicroPython 示例代码](https://github.com/BPI STEAM/BPI BIT Samples) [MicroPython 中文社区](https://forum.banana pi.org.cn/c/bpi bit/micropython) ### Arduino [Arduino 玩家指南](https://github.com/BPI STEAM/BPI BIT Arduino) ## 硬件设计 ### 引脚占用 ![](../assets/getting_started/hardware/extern.png) ### 外观资料 ![](../assets/getting_started/hardware/bot.png) ![](../assets/getting_started/hardware/top.png) ### 硬件资料 [BPI WEBDUINO BIT V1_2](https://github.com/BPI STEAM/BPI BIT Hardware/tree/master/docs/BPI WEBDUINO BIT V1_2.pdf) [BPI WEBDUINO BIT V1_4](https://github.com/BPI STEAM/BPI BIT Hardware/tree/master/docs/BPI WEBDUINO BIT V1_4.pdf) [Buzzer SS S050020Z 120](https://github.com/BPI STEAM/BPI BIT Hardware/tree/master/docs/Buzzer SS S050020Z 120.pdf) [CH340DS1 ch](https://github.com/BPI STEAM/BPI BIT Hardware/tree/master/docs/CH340DS1 ch.pdf) [CH340DS1 en](https://github.com/BPI STEAM/BPI BIT Hardware/tree/master/docs/CH340DS1 en.pdf) [esp32_hardware_design_guidelines_en](https://github.com/BPI STEAM/BPI BIT Hardware/tree/master/docs/esp32_hardware_design_guidelines_en.pdf) [ESP32 datesheet_english](https://github.com/BPI STEAM/BPI BIT Hardware/tree/master/docs/ESP32 datesheet_english.pdf) [esp wroom 32_datasheet_cn](https://github.com/BPI STEAM/BPI BIT Hardware/tree/master/docs/esp wroom 32_datasheet_cn.pdf) [LightSensor PTSMD021 0805](https://github.com/BPI STEAM/BPI BIT Hardware/tree/master/docs/LightSensor PTSMD021 0805.pdf) [LM1117](https://github.com/BPI STEAM/BPI BIT Hardware/tree/master/docs/LM1117.pdf) [MPU 9250 Datasheet v1.1 ch](https://github.com/BPI STEAM/BPI BIT Hardware/tree/master/docs/MPU 9250%20Datasheet v1.1 ch.pdf) [MPU 9250 Datasheet v1.1 en](https://github.com/BPI STEAM/BPI BIT Hardware/tree/master/docs/MPU 9250%20Datasheet v1.1 en.pdf) [MPU 9250 Register Map v1.6](https://github.com/BPI STEAM/BPI BIT Hardware/tree/master/docs/MPU 9250%20Register%20Map v1.6.pdf) [NTC 0805 103F 3950F](https://github.com/BPI STEAM/BPI BIT Hardware/tree/master/docs/NTC 0805 103F 3950F.pdf) [SY7208](https://github.com/BPI STEAM/BPI BIT Hardware/tree/master/docs/SY7208.pdf) [WS2812B](https://github.com/BPI STEAM/BPI BIT Hardware/tree/master/docs/WS2812B.pdf) [DS 000189 ICM 20948 v1.3](https://github.com/BPI STEAM/BPI BIT Hardware/tree/master/docs/DS 000189 ICM 20948 v1.3.pdf) ## 相关网站 [官方中文社区](https://forum.banana pi.org.cn/c/bpi bit) [官方英文社区](http://forum.banana pi.org/c/bpi bit) [Webduino 国内版](https://webduino.com.cn/site/) [Webduino 国际版](https://webduino.io/)"},"/WebBit_dev/zh/index.html":{"title":"Welcome to BPI-STEAM documentation!","content":"# Welcome to BPI STEAM documentation! >欢迎来到 BPI STEAM 的开发指导，本项目托管于 [Github BPI STEAM](https://github.com/BPI STEAM)开源组织。 >此处文档并不会照顾到一般用户的理解，请先具备隔壁 [用户文档](https://bpi steam docs.readthedocs.io)的基础。 以下是我们所用的 BPI BIT 教育开发板,它是一款基于 ESP32 高性能芯片且兼容 micro:bit 设计的开源 STEAM 教育产品。 ![](assets/_static/facade.gif)"},"/WebBit_dev/zh/webduino_dev/develop.html":{"title":"了解拓展积木模板","content":"# 了解拓展积木模板 从先前的文档中得知什么是 Google Blockly 设计器，那我们就先从模仿一个通用的模板开始吧。 请先了解一下这个[webduino blockly template](https://bpi steam.com/webduino blockly template)示例项目，并下载获得。 ## 拓展积木的基本构成 先认识一下模板目录文件，如下一系列表格，稍后会详细介绍。 ### webduino blockly template 文件路径 介绍与用途 : : : : blockly 积木资源文件夹，内容下述 demes 积木示例、设计文件夹，内容下述 blockly.json 积木类型、依赖、实现的定义 itpk blockly.js 积木的代码生成函数实现 itpk.html 测试原始积木功能 API 页面 itpk.js 经典 JavaScript 接口实现 README.md 积木的使用说明文档 _config.yml 由 Github Page 创建，并提供外链 ### webduino blockly template\\\\blockly 文件路径 介绍与用途 : : : : msg 积木多语言资源文件夹，内容下述 blocks.js 由 积木设计器 自动生成的样式实现 javascript.js 由 积木设计器 自动生成的积木代码生成函数实现 toolbox.xml 由你提供左侧工具列积木样式设计 ### webduino blockly template\\\\blockly\\\\msg 文件路径 介绍与用途 : : : : blocks 积木内部的相关的语言文件，内容下述 en.js 定义工具列的 英文 文字变量 zh hans.js 定义工具列的 简体中文 文字变量 zh hant.js 定义工具列的 繁体中文 文字变量 ### webduino blockly template\\\\blockly\\\\msg\\\\blocks 文件路径 介绍与用途 : : : : en.js 定义积木内部的 英文 文字变量 zh hans.js 定义积木内部的 简体中文 文字变量 zh hant.js 定义积木内部的 繁体中文 文字变量 ### webduino blockly template\\\\demos 文件路径 介绍与用途 : : : : blockly.xml 积木的使用范例，可导入 webduino blockly library.xml 积木的设计库，可导回设计器中重新设计 这些基本的定义是便于修改模板积木过程中查阅其确切定义。 ## 拓展积木的使用方法 如果是托管在 Github 上的积木，可以根据[拓展积木的使用说明](../../../WebBit_doc\\zh\\webduino\\modules\\basic.html) 可知插件地址外链类似这样：https://bpi steam.com/webduino blockly template/blockly.json 的地址，又或者是这样 https://junhuanchen.github.io/webduino module itpk robot/blockly.json 的地址，请确保在访问的时候，使用 https 访问且内容类似下图的 JSON 效果。 ![](../assets/webduino_dev/images/blockly_json.png) ## 拓展积木的模板创建 请尝试使用该项目进行操作，如图点击绿色按钮（Use this template），这将 fork 到你的项目中，此时。 ![](../assets/webduino_dev/images/use_template.png) 将它配置到你的积木名称和描述，可以随意。 ![](../assets/webduino_dev/images/create_template.png) 类似这样的效果，注意上述所述的使用方法。 ![](../assets/webduino_dev/images/template_example.png) 上图的积木插件地址应为：https://junhuanchen.github.io/webduino blockly telecar/blockly.json ，而模板插件地址则是 https://bpi steam.com/webduino blockly template/blockly.json ，记得在 readme 里修改对应提供的地址，将插件托管到 Github 的方法请继续往下看。 ## 拓展积木的托管配置 一般来说，我们会将积木托管在 Github 上，这样就不需要自己额外提供一个网络空间了，所以当我们 fork 项目的时候，会发现创建的模板项目，无法直接使用类似上述的插件外链使用，所以这时候需要你设置 Github Pages 的 Source，如下描述，这是因为它需要转换为该链接，以个人的 Github 为例，如下图是没有设置的情况。 ![](../assets/webduino_dev/images/pages_source.png) 选择了 Source 的 master branch 分支。 ![](../assets/webduino_dev/images/pages_select.png) 此时将会产生 Github 的外链，这就是在 Github 上提供积木的地址，积木地址务必提供 https 访问，防止被跳转回 http 。 ![](../assets/webduino_dev/images/pages_result.png) 使用这个刚生成的地址 https://junhuanchen.github.io/webduino blockly template/blockly.json ，在积木载入中确认一遍。 ![](../assets/webduino_dev/images/pages_commit.png) >注意 fork 的 readme 的内容并没有改变，所以发布的时候，别忘了修改积木地址。 现在，你通过 fork 就已经学会了如何创建一个动态积木，那接下来就从修改一个示例模板开始写积木吧。 > 欲读懂内部工作机制，请学习[HTML5](https://www.runoob.com/html/html5 intro.html)和[ECMAScript 6](https://www.runoob.com/w3cnote/es6 concise tutorial.html)。"},"/WebBit_dev/zh/webduino_dev/blockly.html":{"title":"Blockly 是什么？","content":"# Blockly 是什么？ 所谓的 Blockly 积木编程实际上都是指[Google Blockly](https://developers.google.cn/blockly)的工具，开发者都应该先到这个网站去好好看过一遍，了解一下再进行开发。 可以在此体验[Try Blockly](https://developers.google.cn/blockly)的积木运行。 ![](../assets/webduino_dev/mechanism/blockly_to_code.png) 在这里就用一些 Webduino Blockly 的开发示例带领入门 Blockly 开发，这并不是教你如何开发 Webduino Blockly 网站，而是 Blockly 积木。 ##认识 Webduino Blockly Blockly 最佳实践语言是 JavaScript 环境，如今配合 HTML5 的飞速发展，不难想象它可以轻松的让人开发出成果，快速产生成就感。 Webduino Blockly 使用的是标准的 Blockly 环境，它所用的 Blockly 生成的是 JavaScript 代码，所以可以直接在浏览器容器上运行看到效果。 在这里[Webduino Blockly](https://bit.webduino.com.cn/blockly/?lang zh hans)直接导入开发的积木，不需要去部署服务器，也不需要去看如何修改服务器源码，它本身就已经提供了插件开发接口。 > 开发 Webduino Blockly 积木不需要像 Scratch3 通过修改服务器源码来添加自定义积木代码。 ## 体验 Webduino Blockly > 请先具备[HTML5](https://www.runoob.com/html/html tutorial.html)[JavaScript](https://www.runoob.com/js/js tutorial.html)的编程基础。 不妨先体验一下 Webduino Blockly ，这不同于平时用的教育版，可以作为开发环境所用。 可以在线试玩[在 BPI BIT 上显示实时图案](https://bit.webduino.com.cn/blockly/#qZzEn0JaL1)的基础示例，当然你也可以看到更多的示例，如下图。 ![](../assets/webduino_dev/mechanism/blockly_demo.png) 当进入上述示例网站后，点击右上角即可运行程序，此时你注意一下左侧的工具栏。 ![](../assets/webduino_dev/mechanism/blockly_list.png) 点此 JavaScript 的按钮，你就会看到关于 Blockly 代码的生成。 ![](../assets/webduino_dev/mechanism/blockly_code.png) 事实上，这就是 Blockly 的本质，积木只是代码的另一种表现形式。 同样的，作为开发者给到用户的也就是这样的一个体验效果，所见即所得，那么将如何做到这个效果呢？ ## 了解 Google Blockly 设计器 这是来自 Google 官方的 Blockly 积木在线设计器，用于设计积木接口外观，包括生成语言的接口。 [GOOGLE Blockly Developer Tools](https://blockly demo.appspot.com/static/demos/blockfactory/index.html)谷歌源 [Blockly Developer Tools](http://walkline.wang/blockly/blockfactory)国内源 [备用源](https://blockly.yelvlab.cn/google/blockly/demos/blockfactory/index.html?tdsourcetag s_pctim_aiomsg)可选 ![](../assets/webduino_dev/images/blockly_developer.png) 设计器使用方法参考以下两篇介绍文档，两篇参考资料可选。 [Blockly 创建自定义块 概述](https://itbilu.com/other/relate/H1huYbEWQ.html) [Blockly 创建自定义块 Blockly 开发者工具](https://itbilu.com/other/relate/r1IhFZV X.html) 可选参考资料。 [Blockly 来自Google的可视化编程工具](https://itbilu.com/other/relate/4JL8NjUP7.html) [Blockly 的配置](https://itbilu.com/other/relate/Ek5ePdjdX.html) ## Webduino Blockly 开发流程 所以我们要如何开发的流程应该尽可能满足如下形式： 1. 我想做什么功能？ 2. 这功能的积木应该长怎样? 3. 如何将设计的积木运行起来？ 4. 如何实现积木的功能？ 5. 怎样测试我设计积木？ 6. 别人要如何复现？ 基于类似如上的流程，开始制作属于你的积木吧！"},"/WebBit_dev/zh/webduino_dev/index.html":{"title":"Webduino Blockly 开发指导","content":"# Webduino Blockly 开发指导 下面引用一则小故事，阐述一下积木编程的起因。 这是一张关于知识与经验的示意图。 ![](../assets/webduino_dev/images/know_exper.png) 小孩子都好学，喜欢模仿，从出生就不断接受知识，然后根据自己的想法去拼凑，连成一个整体。 当接触到散乱的积木时，就好像下图这样。 ![](../assets/webduino_dev/images/start.png) 将编程的代码以积木的方式显现出来，能让我们将头脑中的信息组块，按照有意义的方式形成一个逻辑性、概念性的视野，帮助小孩更好地应用知识进行创作，让其呈现成这样。 ![](../assets/webduino_dev/images/result.png) 当这个新知识经过理解、练习后，它就会形成一个新组块，存入我们的长期记忆，参与到下一次的组块化中。 准确来说，我们需要的是一个编程概念，一个关于事物与逻辑的组织概念，知道怎么去将各种事物拼接组装成我们想要的事物，积木编程应该引导人们去学会这个概念。"},"/WebBit_dev/zh/webduino_dev/modify/add_lang.html":{"title":"添加积木语言","content":"# 添加积木语言 最后积木制作出来后，为了与国际化接轨，我们还需要为积木添加多语言，但这一步需要修改 blocks.js 设计器生成代码，连接多语言变量的定义，所以请确保该积木已经相对稳定后再添加多语言功能。 我们拿内部简体中文的定义来举例子，例如 blockly/msg/zh hans.js 文件中的内容。 ```javascript MSG.catItpk '茉莉 机器人'; ``` 这实际上就对应着 toolbox.xml 的首行 `<category id \"catItpk\">` 也就是工具栏的多语言，如下图。 ![](../../assets/webduino_dev/modify/images/multilingual_toolbox.png) 接着改积木的多语言需要绑定到设计器代码中，例如 blockly/msg/blocks/zh hans.js 中提供的变量。 ```javascript Blockly.Msg.itpk_clear \"清理回答\"; Blockly.Msg.itpk_answer \" 茉莉 的回答\"; Blockly.Msg.itpk_ask \"问 茉莉 \"; ``` 但这些变量还需要添加到 blockly/blocks.js 替换字符串常量，如下代码。 ```javascript Blockly.Blocks['itpk_clear'] { init: function() { this.appendDummyInput() .appendField(Blockly.Msg.itpk_clear); this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(315); this.setTooltip(\"\"); this.setHelpUrl(\"\"); } }; Blockly.Blocks['itpk_answer'] { init: function() { this.appendDummyInput() .appendField(Blockly.Msg.itpk_answer); this.setOutput(true, null); this.setColour(315); this.setTooltip(\"\"); this.setHelpUrl(\"\"); } }; Blockly.Blocks['itpk_ask'] { init: function() { this.appendValueInput(\"question\") .setCheck(\"String\") .appendField(Blockly.Msg.itpk_ask); this.appendStatementInput(\"callback\") .setCheck(null); this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(315); this.setTooltip(\"\"); this.setHelpUrl(\"\"); } }; Blockly.Blocks['itpk_ask_ip'] { init: function() { this.appendDummyInput() .appendField(\"问 茉莉 查本机网络 IP \"); this.appendStatementInput(\"callback\") .setCheck(null); this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(160); this.setTooltip(\"\"); this.setHelpUrl(\"\"); } }; ``` 可以将 itpk_ask 和 itpk_ask_ip 的定义代码做对比，实际上就是将 `.appendField(\"字符串\");` ，替换成字符串变量 `.appendField(Blockly.Msg.字符串);` ，修改后出来的效果如下图。（可以看到 itpk_ask_ip 并没有被汉化，还处于简体中文的字符串常量） ![](../../assets/webduino_dev/modify/images/multilingual_blockly.png)"},"/WebBit_dev/zh/webduino_dev/modify/function_test.html":{"title":"积木功能测试","content":"# 积木功能测试 当我们知道了如何添加自己的功能代码，就要脱离这个 Blockly 生产环境来测试我们的代码了，在开发环境中，分本地和在线测试运行代码，需要注意的是，本地测试的代码具备一定的特殊性，比如没办法依赖 Webduino 中提供的其他功能，例如无法使用 webduino.module 这个模块变量。 ## 本地测试积木功能 所以在本地写经典代码时，一般需要单独测试和移植，例如下面的茉莉机器人 API 的测试代码 `itpk.html` 。 ```javascript <!DOCTYPE html> <html> <head> <meta charset \"utf 8\"> <title>茉莉机器人 API 测试</title> <script src \"https://code.jquery.com/jquery 3.3.1.min.js\"></script> </head> <body> <script> AskItpk function (question) { $.post(\"http://i.itpk.cn/api.php\", { 'question': question }, function (data) { console.log(\"数据：\" + data); }); } AskItpk('东莞天气如何？'); </script> </body> </html> ``` > 代码无高低，能用就行。 通过这样的方式再转换改写成 `itpk.js` 的模块结构代码，看如下代码。 ```javascript +(function (factory) { if (typeof exports 'undefined') { factory(webduino {}); } else { module.exports factory; } }(function (scope) { 'use strict'; const url \"https://i.itpk.cn/api.php\"; var answer \"\"; function RobotItpk() { Module.call(this); } RobotItpk.ask function (question) { $.post(url, { 'question': question }, function (respond) { // console.log(data); answer respond; }); } RobotItpk.clear function () { answer \"\"; } RobotItpk.answer function () { return answer.replace(\"[cqname]\", \"moli\"); } RobotItpk.quick_ask function (question, callback) { $.post(url, { 'question': question }, function (respond) { answer respond callback(); }); } scope.module.RobotItpk RobotItpk; })); function unit_test() { webduino.module.RobotItpk.ask('东莞天气如何？'); setTimeout(function(){ console.log(webduino.module.RobotItpk.answer()); webduino.module.RobotItpk.ask('高雄天气如何？'); setTimeout(\"console.log(webduino.module.RobotItpk.answer())\", 1000); }, 1000); } // unit_test(); ``` 但你也可以直接使用 AMD JS 代码的方式，规范的模块化整合到积木环境中，这就需要你具备一定的现代 JS 代码模块规范的基础，可以先了解 [webpack demo](https://github.com/BPI STEAM/webpack demo) 或配合这个示例项目 [webpack develop example](https://github.com/BPI STEAM/webpack develop example) 来操作，这将有利于你写出规范的专业代码，就像下面这样的代码直接编译运行在浏览器，这将高度符合 Webduino Blockly 的运行环境。 ```javascript (function (root, factory) { if (typeof define 'function' && define.amd) { // AMD define(['jquery'], factory); } else if (typeof exports 'object') { // Node, CommonJS etc module.exports factory(require('jquery')); } else { // Browser global variable (root is window) root.returnExports factory(root.jQuery); } }(this, function ($) { 'use strict'; const url \"https://i.itpk.cn/api.php\"; var answer \"\"; var proto; var RobotItpk function () { }; RobotItpk.prototype proto Object.create({ constructor: { value: RobotItpk } }); proto.ask function (question) { $.post(url, { 'question': question }, function (respond) { console.log(respond); answer respond; }); } proto.clear function () { answer \"\"; } proto.answer function () { return answer.replace(\"[cqname]\", \"moli\"); } proto.quick_ask function (question, callback) { $.post(url, { 'question': question }, function (respond) { console.log(respond); answer respond callback(); }); } window.RobotItpk RobotItpk; })); var ts new window.RobotItpk(); ts.ask(\"nihao\"); setTimeout(function () { document.write('<h1>' + ts.answer() + '</h1>'); }, 1000); ``` ## 在线测试积木功能 我们可以在积木的时候里面进行代码的查看，如下图操作。 ![](../../assets/webduino_dev/modify/images/webduino_into_js_bin.png) 如你所见，可以在这里进行代码的运行以及调试。 ![](../../assets/webduino_dev/modify/images/into_js_bin.png) [JS bin](https://bin.webduino.com.cn/?html,css,js,output) 是一款在线编写浏览器 JS 工具，可以在这里进行你的调试于测试，比如我们可以这样做，将 itpk blockly.js 或 itpk.js 文件代码放入下图所述位置，即可自动运行输出。 ![](../../assets/webduino_dev/modify/images/js_bin_run.png) > 上图需要你点开 Console 控制台输出 debug 信息，并且粘贴 itpk.js 代码后拉到低下取消 unit_test() 的注释，从而运行单元测试，默认修改代码自动运行。"},"/WebBit_dev/zh/webduino_dev/modify/view_blockly.html":{"title":"查看范例积木","content":"# 查看范例积木 进入积木设计器，可以使用国内源 [Blockly Developer Tools](http://walkline.wang/blockly/blockfactory/) 如下图。 ![](../../assets/webduino_dev/modify/images/blockly_tools.png) 使用该模板项目 [webduino blockly template](https://github.com/BPI STEAM/webduino blockly template) ，并将它的代码通过 download 或 clone 得到它。 ![](../../assets/webduino_dev/modify/images/demos_library.png) 将文件里的 demo/library.xml 导回积木设计器，参考已有积木，重新设计出属于你的积木。 ![](../../assets/webduino_dev/modify/images/select_library.png) 可以看到有如下积木类型。 ![](../../assets/webduino_dev/modify/images/blockly_list.png) 让我们点开一个 itpk_answer 看看都是如何定义的。 ![](../../assets/webduino_dev/modify/images/itpk_answer.png) 可以看到，左侧是积木编辑工具，右侧则是生成的结果： 积木外观样式预览（Preview） 积木外观定义代码（Block Definition） 代码生成函数桩（Generator stub） ![](../../assets/webduino_dev/modify/images/blockly_result.png) 现在知道有这些东西就行，回头就会用上，至少知道这些代码都是使用该工具生成的。 > 欲读懂内部工作机制，请学习[HTML5](https://www.runoob.com/html/html5 intro.html)和[ECMAScript 6](https://www.runoob.com/w3cnote/es6 concise tutorial.html)。"},"/WebBit_dev/zh/webduino_dev/modify/add_function.html":{"title":"添加对应功能","content":"# 添加对应功能 现在积木已经生成，但是我们要如何为如下代码添加对应的功能呢？ ```javascript scope.itpk_answer function () { return \"webduino.module.RobotItpk.answer()\"; } ``` 我们继续看它的生成代码，这个实际上就是生成（返回）一段调用 blockly/itpk blockly.js 函数的 `webduino.module.RobotItpk.answer()` 代码，所以我们需要在 blockly/itpk blockly.js 中提供这个函数的实现，也就是如下代码。 ```javascript RobotItpk.answer function () { return answer.replace(\"[cqname]\", \"moli\"); } ``` 我们可以在单元测试（unit_test）中得知它的用法。 ```javascript function unit_test() { webduino.module.RobotItpk.ask('东莞天气如何？'); setTimeout(function(){ console.log(webduino.module.RobotItpk.answer()); webduino.module.RobotItpk.ask('高雄天气如何？'); setTimeout(\"console.log(webduino.module.RobotItpk.answer())\", 1000); }, 1000); } ``` 但是为什么可以链接起来？这需要看 blockly.json 的定义。 ```javascript { \"types\": [ \"itpk_ask_ip\", \"itpk_ask\", \"itpk_answer\", \"itpk_clear\" ], \"category\": \"itpk\", \"scripts\": [ \"https://cdn.jsdelivr.net/gh/yarrem/stringFormat.js/format.js\", \"itpk blockly.js\", \"blockly/blocks.js\", \"blockly/javascript.js\" ], \"dependencies\": [ \"itpk.js\" ], \"msg\": \"blockly/msg\", \"blocksMsg\": \"blockly/msg/blocks\", \"toolbox\": \"blockly/toolbox.xml\" } ``` 关于依赖的 javascript 代码的使用情况，我们需要将 Blockly 分成两个场景，第一是积木生成代码阶段的，第二是生成代码的时候运行依赖，也就是 `scripts` 和 `dependencies` 两列，如你所见的是 `scripts` 包含的是 Blockly 积木相关联的实现代码，而 `dependencies` 则是代码运行的时候依赖的 javascript 代码，例如 `itpk.js` 代码可以在运行代码的时候实现。"},"/WebBit_dev/zh/webduino_dev/modify/code_test.html":{"title":"代码生成测试","content":"# 代码生成测试 我们已经能够将自己设计的积木导入积木工具了，但还没有配合积木生成的代码，比如像下面这样，左边是积木，右边是代码。 ![](../../assets/webduino_dev/modify/images/blockly_gen.png) 我们需要知道积木生成代码的在 blockly/javascript.js 中有这样的 Generator Stubs 的代码。 ```javascript Blockly.JavaScript['itpk_ask_ip'] function(block) { var statements_callback Blockly.JavaScript.statementToCode(block, 'callback'); // TODO: Assemble JavaScript into code variable. var code '...;\\n'; return code; }; ``` 在 Webduino Blockly 中点击 JavaScript 就会这样显示出来，如下图所示。 ![](../../assets/webduino_dev/modify/images/blockly_code.png) 可以看到，它实际上就对应 `var code '...;\\n';` 的返回值，所以我们只需要修改这部分内容。 比如说，将其修改成 `var code 'console.log(\"hello\");\\n';` 这就意味着，当你拖出这个代码将会得到 `console.log(\"hello\");\\n` 代码，让我们来试试修改 blockly/javascript.js 。 ```javascript Blockly.JavaScript['itpk_ask_ip'] function(block) { var statements_callback Blockly.JavaScript.statementToCode(block, 'callback'); // TODO: Assemble JavaScript into code variable. var code 'console.log(\"hello\");\\n'; return code; }; ``` 此时效果图如下，提交后重新载入积木即可看到效果。 ![](../../assets/webduino_dev/modify/images/blockly_add_code.png) 此时你会注意到，明明我们的积木中有 控制台显示 茉莉 的回答 ，但是代码中并没有，那该如何显示出来？看下面代码的 `console.log(statements_callback);` 的内容，然后继续添加。 ```javascript Blockly.JavaScript['itpk_ask_ip'] function(block) { var statements_callback Blockly.JavaScript.statementToCode(block, 'callback'); // TODO: Assemble JavaScript into code variable. console.log(statements_callback); var code 'console.log(\"hello\");\\n'; return code; }; ``` 这时候就意味着 F12 的开发者调试工具的控制台，可以看到如下效果，也就是你所包含的代码内容，掌握了这个方法后，就可以调试积木代码生成的情况了。 ![](../../assets/webduino_dev/modify/images/blockly_console.png) 当你查看代码的时候，它将会生成 控制台显示 茉莉 的回答 的效果，但这个做法只是了解一下现象，并不推荐在这里修改，因为设计器会重新生成代码，所以要减少该部分代码，全部采用外部函数调用的方法，那么我们如果想要轻松的添加自己的积木代码，请参考 itpk blockly.js 是怎么写的。 举个例子，看 `itpk_answer` 的积木定义，它调用了 `itpk_answer();` 函数。 ```javascript Blockly.JavaScript['itpk_answer'] function(block) { // TODO: Assemble JavaScript into code variable. var code itpk_answer(); // TODO: Change ORDER_NONE to the correct strength. return [code, Blockly.JavaScript.ORDER_NONE]; }; ``` 而这个函数就被实现在 itpk blockly.js 中，也就是如下代码。 ```javascript scope.itpk_answer function () { return \"webduino.module.RobotItpk.answer()\"; } ``` 所以在得到设计器的代码后，只需要将 `var code '...;\\n';` 修改成 `var code itpk_answer();` ，极大的减少了设计器的代码变动。 我们继续看另一个例子。 ```javascript Blockly.JavaScript['itpk_ask'] function(block) { var value_question Blockly.JavaScript.valueToCode(block, 'question', Blockly.JavaScript.ORDER_ATOMIC); var statements_callback Blockly.JavaScript.statementToCode(block, 'callback'); // TODO: Assemble JavaScript into code variable. var code '{0};\\n'.format(itpk_quick_ask(value_question, statements_callback)); return code; }; ``` 它就是 `itpk_ask` 积木的例子，只需要注意到这行代码。 ```javascript var code '{0};\\n'.format(itpk_quick_ask(value_question, statements_callback)); ``` 其他都是设计器自动生成的，解释一下 `itpk_quick_ask` 的实现过程。 ```javascript scope.itpk_quick_ask function (question, callback) { return \"webduino.module.RobotItpk.quick_ask({0}, function(){\\n {1}})\".format(question, callback); } ``` 在 blockly/itpk blockly.js 我们看到类似 `\"{0} {1}\".format(1, 2)` 的操作，这个操作是将代码进行格式化，可以帮助生成代码的格式化输入，提供字符串的封装方法，而不是 \"1\" + \" \" + \"2\" 的方式，例如下述代码。 ```javascript scope.itpk_quick_ask function (question, callback) { return \"webduino.module.RobotItpk.quick_ask(\" + question + \", function(){\\n \" + callback + \"})\"; } ``` 不建议写出以上字符串拼装代码，因为积木设计大量充斥这种字符串相互包含的关系，Code 会显得非常 Ugly ，所以使用这样的方式去开发你的积木对应的代码吧。"},"/WebBit_dev/zh/webduino_dev/modify/examples.html":{"title":"积木使用示例","content":"# 积木使用示例 > 分享示例前，请务必先载入积木后再导入示例。 最后要如何将你的积木插件分享给其他人，除了给积木插件地址，还需要处理一下自己的 readme 帮助文件，以及在里面提供一些使用案例，如下图可以导出你的示例代码。 ![](../../assets/webduino_dev/modify/images/output_usage_demo.png) 示例文件一般推荐保存积木目录下的 demos/blockly.xml ，除了这样做还可以在线分享链接，如下图指示。 ![](../../assets/webduino_dev/modify/images/output_link.png) 但是，但凡内部案例涉及到的外部积木插件，都必须要提前导入，否则将显示一个积木黑块表示不可用。"},"/WebBit_dev/zh/webduino_dev/modify/add_block.html":{"title":"添加新的积木","content":"# 添加新的积木 先前我们制作了一个积木块，我们需要将它添加到我们自己的积木里，先看一下我们想要添加的积木的效果。 ![](../../assets/webduino_dev/modify/images/blockly_itpk_ask_ip.png) 进入 Block Exporter 可以批量选取积木并导出对应代码。 ![](../../assets/webduino_dev/modify/images/blockly_exporter.png) 获取这两段定义内容，然后将它添加到创建的模板积木中，注意结合前一章的目录下的文件描述。 进入 blockly/blocks.js ，在后面添加 Block Definitions 的代码。 ```javascript Blockly.Blocks['itpk_ask_ip'] { init: function() { this.appendDummyInput() .appendField(\"问 茉莉 查本机网络 IP \"); this.appendStatementInput(\"callback\") .setCheck(null); this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(160); this.setTooltip(\"\"); this.setHelpUrl(\"\"); } }; ``` 进入 blockly/javascript.js 也同样添加 Generator Stubs 的代码。 ```javascript Blockly.JavaScript['itpk_ask_ip'] function(block) { var statements_callback Blockly.JavaScript.statementToCode(block, 'callback'); // TODO: Assemble JavaScript into code variable. var code '...;\\n'; return code; }; ``` 如果不清楚如何操作的可以看这个提交 [添加积木的定义](https://github.com/junhuanchen/webduino blockly template/commit/8f556c70a033d4e8186439dbf348d10aa29fece0) 。 ![](../../assets/webduino_dev/modify/images/add_blockly.png) 当你添加完了积木的定义，不代表积木可以使用，还需要在 blockly/toolbox.xml 中添加你积木的工具栏位置，否则将无法显示到左侧来，例如下图的效果。 ![](../../assets/webduino_dev/modify/images/blockly_left_tool.png) 那么我们应该如何做呢？先是进入 Workspace Factory 可以模拟设计的积木大致的使用方法，与其他积木进行对接的尝试，还可以导出（Export）积木工具列 toolbox.xml 文件供你参考。 ![](../../assets/webduino_dev/modify/images/blockly_factory.png) 然后拿我们设计的积木出来。 ![](../../assets/webduino_dev/modify/images/view_toolbox.png) 此时通过下图的方式得到 toolbox.xml 文件，然后添加到我们原本的 blockly/toolbox.xml 文件当中。 ![](../../assets/webduino_dev/modify/images/export_toolbox.png) 下载打开它得到 xml 文件代码。 ![](../../assets/webduino_dev/modify/images/open_toolbox.png) ```xml <xml xmlns \"http://www.w3.org/1999/xhtml\" id \"toolbox\" style \"display: none;\"> <block type \"itpk_ask_ip\"> <statement name \"callback\"> <block type \"text_print\"> <value name \"TEXT\"> <block type \"itpk_answer\"></block> </value> </block> </statement> </block> </xml> ``` 实际上就可以看出积木的对应效果，例如 `<block>` 标签对应的就是积木块， `<statement>` 标签对应的就是结合的积木块，所以我们可以在工具栏看到如下效果。 ![](../../assets/webduino_dev/modify/images/toolbox_result.png) 现在将其添加到我们的原本的模板积木当中，与其他存在的积木块作出对比。 以下是原内容： ```xml <category id \"catItpk\"> <block type \"itpk_ask\"> <value name \"question\"> <block type \"text\"> <field name \"TEXT\">今天东莞天气如何？</field> </block> </value> </block> <block type \"console\"> <value name \"console\"> <block type \"itpk_answer\"></block> </value> </block> <block type \"itpk_clear\"> </block> <block type \"itpk_ask\"> <value name \"question\"> <block type \"text\"> <field name \"TEXT\">查 IP </field> </block> </value> \t<statement name \"callback\"> \t<block type \"console\"> \t<value name \"console\"> \t\t<block type \"itpk_answer\"></block> \t</value> \t</block> \t</statement> </block> </category> ``` 在后面添加新内容，变成如下代码。 ```xml <category id \"catItpk\"> <block type \"itpk_ask\"> <value name \"question\"> <block type \"text\"> <field name \"TEXT\">今天东莞天气如何？</field> </block> </value> </block> <block type \"console\"> <value name \"console\"> <block type \"itpk_answer\"></block> </value> </block> <block type \"itpk_clear\"> </block> <block type \"itpk_ask\"> <value name \"question\"> <block type \"text\"> <field name \"TEXT\">查 IP </field> </block> </value> \t<statement name \"callback\"> \t<block type \"console\"> \t<value name \"console\"> \t\t<block type \"itpk_answer\"></block> \t</value> \t</block> \t</statement> </block> <block type \"itpk_ask_ip\"> <statement name \"callback\"> <block type \"console\"> <value name \"console\"> <block type \"itpk_answer\"></block> </value> </block> </statement> </block> </category> ``` 现在，你已经将自己设计的积木添加进去了，此时你还需要最后一步，就可以载入积木看到效果。 在 blockly.json 中添加你的积木类型（types），因为它是一个全新的积木所以需要添加进去，否则不会被载入到动态积木中。 查看 blockly.json 的内容，然后在 types 列中添加 `\"itpk_ask_ip\",` ```json { \"types\": [ \"itpk_ask_ip\", \"itpk_ask\", \"itpk_answer\", \"itpk_clear\" ], \"category\": \"itpk\", \"scripts\": [ \"https://cdn.jsdelivr.net/gh/yarrem/stringFormat.js/format.js\", \"itpk blockly.js\", \"blockly/blocks.js\", \"blockly/javascript.js\" ], \"dependencies\": [ \"itpk.js\" ], \"msg\": \"blockly/msg\", \"blocksMsg\": \"blockly/msg/blocks\", \"toolbox\": \"blockly/toolbox.xml\" } ``` > 以下的操作均在浏览器无痕模式下进行。（等你足够了解后，可以先移除积木后刷新再重新载入积木）。 现在你可以提交它，然后等一会提交成功后，可以载入 `https://junhuanchen.github.io/webduino blockly template/blockly.json` 积木查看效果了。 ![](../../assets/webduino_dev/modify/images/new_toolbox.png)"},"/WebBit_dev/zh/webduino_dev/modify/design_block.html":{"title":"设计新的积木","content":"# 设计新的积木 如果我们想做一个新的功能积木，可以建立在已有的基础上，比如参考一个已经存在的积木，将其修改成我们想要的样子，再封装成其他功能，拿查询本机 IP 的积木来举例，如果要在 itpk_ask 的基础上修改的话，那么积木应该长怎样呢？ ![](../../assets/webduino_dev/modify/images/itpk_ask.png) 我们可以参考 itpk_ask 的积木设计，修改它直接变成我们想要的祥子，拖动一个无参数的积木连接块，如下图。 ![](../../assets/webduino_dev/modify/images/get_input_dummy.png) 拖拽出来，放到和其他 Input 一样的地图，并且复制一下字符串对应过来，如下图。 ![](../../assets/webduino_dev/modify/images/input_contrast.png) 经过对比后可以发现 dummy input 不能再结合，所以看到的末尾是无法衔接其他模块的，此时我们将它设计成查 IP 的积木，如下图修改。（移除 value input 并编辑 text itpk_ask 积木块） ![](../../assets/webduino_dev/modify/images/itpk_get_ip.png) 我们最后来改个名字并保存一下新的积木块，免得弄丢了，如下图。 ![](../../assets/webduino_dev/modify/images/save_itpk_get_ip.png) 现在积木就设计完成了，但我们需要看，它对应的样式代码是怎样的才能放入我们的 Webduino Blockly 当中，所以看 Block Definition 的代码。 ```javascript Blockly.Blocks['itpk_ask_ip'] { init: function() { this.appendDummyInput() .appendField(\"问 茉莉 查本机网络 IP \"); this.appendStatementInput(\"callback\") .setCheck(null); this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(160); this.setTooltip(\"\"); this.setHelpUrl(\"\"); } }; ``` 以上就是你所见到的积木它的定义代码，可以理解为是这段代码描述了积木的样子，也就是说，你也可以不通过 Blockly 设计器来修改积木外观，以及它对应的需要用户实现的桩代码： ```javascript Blockly.JavaScript['itpk_ask_ip'] function(block) { var statements_callback Blockly.JavaScript.statementToCode(block, 'callback'); // TODO: Assemble JavaScript into code variable. var code '...;\\n'; return code; }; ``` 这个函数可以为积木提供背后生成的代码环境，例如将 `var code 'var test 123;\\n';` 这样就表示，这个积木块拖拽出来将提供 `var test 123;\\n` 的代码，也就是所谓的积木生成代码，积木块对应着代码，接下来我们就要将其导入我们的原本的积木当中。"},"/WebBit_dev/zh/webduino_dev/mechanism.html":{"title":"附文：两类积木机制与设计思路","content":"# 附文：两类积木机制与设计思路 本文会在此讲点积木编程的哲学，如果你不喜欢，可以跳过该章节，然后从实际出发，如我们现在所看到的积木有两种体系，一种是 Scratch 体系，另一种则是 Blockly 体系，下面单独介绍这两种积木设计。 ## Scratch 积木体系 Scratch 是麻省理工学院的“终身幼儿园团队”（Lifelong Kindergarten Group）开发的图形化编程工具，主要面对青少年开放。 现在大多都在谈 2019 年后正式发布的 Scratch3 版本了，如果你对开发它有兴趣可以看看这个的项目[添加 Scratch3 自定义积木](https://github.com/junhuanchen/scratch3 eim mpfshell)，本文暂不对此深入阐述。 在线试试[Codelab Scratch3](https://scratch3.codelab.club)编程吧，这由我们的开源合作伙伴提供。 ![](../assets/webduino_dev/mechanism/mechanism/scratch3.png) ## Blockly 积木体系 2012 年 6 月，Google 发布了完全可视化的编程语言 Google Blockly，类似 MIT 的儿童编程语言 Scratch ， 你可以通过类似玩乐高玩具的方式用一块块图形对象构建出应用程序。每个图形对象都是代码块，你可以将它们拼接起来，创造出简单功能，然后将一个个简单功能 组合起来，构建出一个程序。整个过程只需要鼠标的拖曳，不需要键盘敲击。 ![](../assets/webduino_dev/mechanism/mechanism/blockly.png) ## 说说 Scratch 与 Blockly 的机制区别 虽然我们在用 Blockly 来开发积木的，但我们也应当学习 Scratch 的设计理念和运行机制，这将有利于我们更好的开发适合教育的编程积木。 首先 Scratch 已经拥有了一个自己专属的运行环境（虚拟机），在这个环境上，运行自己所定义的积木，早在 2.0 时期使用的是 Adobe 的 Flash AIR 环境，现在还可以看到它的影子，但随着 3.0 的推出，已经全面改用 JavaScript(React) 了，也就是拥有了良好的浏览器跨平台性。 这点和 Webduino Blockly 是基本一致的，都是基于 JavaScript 的环境，但也存在很大的区别，比如说 Scratch3 并不鼓励直接使用代码编程，本质上还是积木调用接口编程。（但 Scratch3 也有 Blockly 接口）。 对 Scratch3 来说，所谓的积木只是某一类功能的调用接口，可以理解为某一类插槽，在定义的时候，就是为了将积木绑定到某一个函数、模块上，直接将其功能调起，所以 Scratch3 的积木设计大多都是单例设计，意味着，一个积木对应一个功能。 而 Blockly 并非如此设计，举例来说 Webduino Blockly 是一种将 Blockly 积木运行在 JavaScript 的环境上的网站，它将执行由 Blockly 的积木将生成对应的 JavaScript 代码。 这意味着，Blockly 积木块本身只是代码的映射，并非是某一个可以调用的功能，这个区别你应该可以体验出来。 ## 不同的运行机制会导致什么现象呢？ 首先 Scratch3 可以直接点击积木运行查看效果，而 Blockly 需要点击运行才能查看效果，因为需要所有积木生成代码后才能运行查看整体效果，但技术是会发展变革的，并非 Blockly 做不到，而是它的哲学就是 **The web based visual programming editor** 也就是只做一件事：“可视化编辑，生成代码”。 ### 积木的设计理念 直接运行积木的设计为开发者带来的理念就是，开发者设计的每一个积木都是期望可以直接运行的，也就跳过了定义和配置的环节，每一次都是全新的开始，这对于程序来说，积木就是单例，不可抽象，所点即所得。 从程序设计的角度上讲，这并不能成就一个大型程序，只能作为一般的小程序来体验，但 Scratch3 本就是一个面向少儿编程的工具，不需要对它有过多的要求。 而 Blockly 的设计理念并非如此，设计思路复杂且巧妙，主要强调的是 积木 就是 代码，只不过是在研究代码的组织形式，所谓的拼接积木，实际上就是在组织不同的代码块，如果我们把每一段功能代码当作是一份积木，那么产生的结果就是 Blockly 将会拆分积木中的代码，因为它可以尽可能的抽象积木块供大家自由组合。 ### 积木的教育结果 经过 Scratch3 和 Blockly 的机制，从编程教育这个角度来看， Scratch3 的设计显得有些狭隘了，因为它并不鼓励你学会代码编程，反观 Blockly ，它本来就是代码的另一种表现形式，如果你学会了组织 Blockly 积木，实际上也就学会了如何组织代码，转移到写代码这件事，实际上就很自然而然的了。 与其说谁更好，倒不如相互学习，Scratch3 作为一款编程教育产品将是非常棒的教具，而 Blockly 则并非是一个教育玩具，双方都有各自的优势和可取之处，发展将会越来越好。 我们知道编程不是积木，但积木可以映射出一种现象，这种现象也许是你在任何语言编程（甚至是生活）中都会遇到的问题，那就是如何组织许多小部件形成一件完整的作品。 最后，编程也好，积木也罢，都是指引我们学习事物本质的工具，而非停留在表面现象，只会使用，而不知其原理。"},"/WebBit_dev/zh/no_translate.html":{"title":"no_translate_title","content":" title: no_translate_title class: md_page <div id \"visit_from\"></div> <div id \"no_translate_hint\">no_translate_hint</div> <div> <span id \"visit_hint\">visit_hint</span> <a id \"translate_src\"></a> </div> <div> <script> function getQueryVariable(variable) { var query window.location.search.substring(1); var vars query.split(\"&\"); for (var i 0;i<vars.length;i++) { var pair vars[i].split(\" \"); if(pair[0] variable){return pair[1];} } return(false); } var ref getQueryVariable(\"ref\"); var from getQueryVariable(\"from\"); var link document.getElementById(\"translate_src\"); var fromDis document.getElementById(\"visit_from\"); link.href ref; link.text ref; fromDis.innerHTML from; </script> </div>"}}