{"/Bit_S2_doc/zh/CircuitPython/flash_tinyuf2.html":{"title":"烧录tinyUF2固件的方法","content":"# 烧录tinyUF2固件的方法 > 所有对flash的操作不可逆，注意提前备份代码等重要文件。 ## 下载tinyUF2固件 1. 进入[BPI Bit S2 CircuitPython 下载](https://circuitpython.org/board/bpi_bit_s2/)页面。 2. 在页面底部找到`Install, Repair, or Update UF2 Bootloader`栏目，点击最下方的`DOWNLOAD BOOTLOADER ZIP`按钮下载压缩包。 3. 在本地解压压缩包，`combined.bin`文件是我们需要的固件。 ## 将开发板置于bootloader模式 1. 通过USB连接开发板与电脑。 2. 按住`BOOT`按键，此时开发板背面红灯会保持熄灭状态。 3. 按一次`RST`按键。 4. 松开`BOOT`按键，此时开发板背面红灯会保持点亮状态。 ## 在浏览器中烧录固件 > 支持Chrome，Edge浏览器，内核版本需高于89。 1. 打开[ESP Web Flasher](https://nabucasa.github.io/esp web flasher/)页面。 2. 点击`Connect`按钮，将弹出一个选项栏，选择开发板所在的串口。 ![](../assets/images/picow_s3_tinyuf2_download_1.png) ![](../assets/images/picow_s3_tinyuf2_download_2.png) 3. 正常连接后，点击`Erase`按钮擦除开发板的flash内容，这个过程不可逆。 ![](../assets/images/picow_s3_tinyuf2_download_3.jpg) 4. 点击`Choose a file...`按钮，在弹出的文件选择窗口中跳转到`combined.bin`文件所在的目录，选择此文件并点击确认。 5. 点击`Program`按钮即可开始烧录固件，大约等待五分钟即可完成。 6. 完成后，手动按一次`Reset`按键，成功烧录的标志是第一颗彩灯为长亮绿灯，且在电脑系统中将看到一个名为`BITS2BOOT`的USB存储磁盘，如果没有得到此结果，可以重试前五步，或尝试下一个烧录方法。 ## esptool本地烧录固件 1. 打开[Python官网](https://www.python.org/) 。 对于Windows 系统来说，最便捷的安装包下载方法就是在官网首页点击如下图所示的图标进行下载。 ![](../assets/images/Micropython_operating_env_1.png) 其他操作系统或是其他发行版本则可以在 Downloads 选项栏中进行选择。 建议使用python 3.7以上的版本。 2. 开始安装时一定要记得勾选Add Python 3.x to PATH，这样可以免除再手动添加进PATH。 ![](../assets/images/Micropython_operating_env_2.png) 按照安装提示逐步操作即可顺利完成安装 。 3. 以Windows PowerShell的具体操作步骤为例，使用以下命令安装esptool： ```shell pip install esptool ``` 如果未来有需要，则可以使用以下命令升级esptool： ```shell pip install U esptool ``` 4. 通过命令或其他方法在PowerShell中进入固件所在的目录。 5. 可以在Windows文件夹窗口中以按住shift键再单击右键的方式在此文件夹中打开PowerShell窗口。 6. 此时需要设置开发板为bootloader模式，详见上文。 7. 通过以下命令清除flash，需要修改COM接口为对应的接口，此处为COM22。 ```shell python m esptool chip esp32s3 port COM22 baud 460800 erase_flash ``` 8. 通过以下命令烧录`combined.bin`固件，需要修改COM接口为对应的接口，此处为COM22。 ```shell python m esptool chip esp32s3 port COM22 baud 460800 write_flash z 0x0 combined.bin ``` 9. 完成后，手动按一次`Reset`按键，成功烧录的标志是彩灯为长绿灯，如果没有得到此结果，可以重试前两步命令。"},"/Bit_S2_doc/zh/CircuitPython/Basic.html":{"title":"基础功能使用","content":"# 基础功能使用 ## REPL简单使用 ### Hello World! 1. 确保已在Mu编辑器中正确连接开发板，参考[配置使用环境(Mu编辑器)](config_mu editor.html)。 2. 在CircuitPython REPL窗口中通常会出现如下信息，`>>>`符号的出现即代表我们可以开始在其后输入命令与其交互了。 ``` ]0;🐍Wi Fi: off Done 8.0.0 beta.0 49 g14fc4a079\\Auto reload is on. Simply save files over USB to run them or enter REPL to disable. Press any key to enter the REPL. Use CTRL D to reload. ]0;🐍Wi Fi: off Done 8.0.0 beta.0 49 g14fc4a079\\]0;�Wi Fi: off REPL 8.0.0 beta.0 49 g14fc4a079\\ Adafruit CircuitPython 8.0.0 beta.0 49 g14fc4a079 on 2022 09 20; BPI Bit S2 with ESP32S3 >>> ``` 3. 在`>>>`符号右侧开始输入命令，例如：`print(\"Hello World！\")`。 > 注意使用英文输入法，中文字符无法被REPL识别。 ```py >>> print(\"Hello World!\") Hello World! >>> ``` ### REPL快捷键 1. 复制 `ctrl + shift + c`。 2. 粘贴 `ctrl + shift + v`。 使用鼠标左键在REPL中拖选需要复制的命令，键盘按下复制快捷键，再按下粘贴快捷键即可复制粘贴命令。 3. 软复位 `ctrl + d`。 4. 中断 `ctrl + c`, 中断当前正在执行的程序，但不会重启复位。 ### 查看内置模块 1. 在REPL中输入 `help(\"modules\")` 将列出当前CircuitPython开发板内所有模块。 2. 导入模块后可再使用`help()`函数查看该模块内部可用的函数名或变量名，例如查看`board`模块，即可看到开发板所有可用的引脚与外设功能。 ```py >>> import board >>> help(board) object <module 'board'> is of type module __name__ board board_id bpi_bit_s2 IO0 board.IO0 A0 board.IO0 D0 board.IO0 DAC1 board.IO0 BUZZER board.IO0 IO1 board.IO1 A1 board.IO1 D1 board.IO1 IO2 board.IO2 A2 board.IO2 D2 board.IO2 IO3 board.IO3 A3 board.IO3 D3 board.IO3 IO4 board.IO4 A4 board.IO4 D4 board.IO4 IO5 board.IO5 A5 board.IO5 D5 board.IO5 IO6 board.IO6 A6 board.IO6 D6 board.IO6 IO7 board.IO7 A7 board.IO7 D7 board.IO7 IO8 board.IO8 A8 board.IO8 D8 board.IO8 IO9 board.IO9 A9 board.IO9 D9 board.IO9 IO10 board.IO10 A10 board.IO10 D10 board.IO10 IO11 board.IO11 A11 board.IO11 D11 board.IO11 IO12 board.IO12 D12 board.IO12 IO13 board.IO13 SCK board.IO13 D13 board.IO13 IO14 board.IO14 MISO board.IO14 D14 board.IO14 IO15 board.IO15 MOSI board.IO15 D15 board.IO15 IO16 board.IO16 CS board.IO16 D16 board.IO16 SCL board.SCL IO19 board.SCL SDA board.SDA IO20 board.SDA BOOT0 board.BOOT0 LED board.BOOT0 BUTTON_A board.BUTTON_A BUTTON_B board.BUTTON_B LUM1 board.LUM1 LUM2 board.LUM2 TEMPERATURE board.TEMPERATURE NEOPIXEL board.NEOPIXEL TX board.TX RX board.RX I2C <function> SPI <function> UART <function> >>> ``` ## 使一颗WS2812彩灯闪烁 1. 在Mu编辑器中点击**Load**按钮，选择CircuitPython开发板上的 code.py 文件，点击 **打开**，即可开始编辑 code.py 。 2. 在编辑器中输入如下代码： ```python import time import board import neopixel pixels neopixel.NeoPixel(board.NEOPIXEL, 25, brightness 0.1) while 1: pixels[0] (255,0,0) pixels.show() time.sleep(0.5) pixels[0] (0,255,0) pixels.show() time.sleep(0.5) pixels[0] (0,0,255) pixels.show() time.sleep(0.5) pixels[0] (255,255,255) pixels.show() time.sleep(0.5) ``` 3. 点击**Save**按钮，编辑的内容将保存到CircuitPython开发板，代码无误的情况下，开发板上的第一颗彩色LED将循环闪烁 红绿蓝白。将开发板复位或重新上电，程序将重新开始运行。 4. 在REPL中使用中断快捷键即可停止程序的运行。 5. 代码也可直接复制粘贴到REPL中运行。 > 后续所有示例都可如此编辑code.py文件或复制粘贴到REPL中运行。但在code.py文件中的程序代码执行完毕后，开发板会恢复未运行时的状态，不会保留状态，但在REPL中执行则会保留状态。 ## 使用25颗WS2812彩灯 1. 在上一节**使一颗WS2812彩灯闪烁**的代码基础上，使用for循环即可依次点亮25颗WS2812彩灯。 ```python import time import board import neopixel pixels neopixel.NeoPixel(board.NEOPIXEL, 25, brightness 0.1) while 1: for i in range(25): pixels[i] (255,0,0) pixels.show() time.sleep(0.1) for i in range(25): pixels[i] (0,255,0) pixels.show() time.sleep(0.1) for i in range(25): pixels[i] (0,0,255) pixels.show() time.sleep(0.1) for i in range(25): pixels[i] (255,255,255) pixels.show() time.sleep(0.1) ``` 2. 若想同时控制所有彩灯的颜色，则在for循环结束后再使用`pixels.show()`将数据发送给WS2812彩灯。 ```python import time import board import neopixel pixels neopixel.NeoPixel(board.NEOPIXEL, 25, brightness 0.1) while 1: for i in range(25): pixels[i] (255,0,0) pixels.show() time.sleep(0.5) for i in range(25): pixels[i] (0,255,0) pixels.show() time.sleep(0.5) for i in range(25): pixels[i] (0,0,255) pixels.show() time.sleep(0.5) for i in range(25): pixels[i] (255,255,255) pixels.show() time.sleep(0.5) ``` 1. WS2812彩灯的通信协议采用单线归零码的通讯方式，即一条信号线即可控制串联在一起的所有灯珠。可以将每一颗灯珠看作一个 8bit RGB 像素点，像素点在上电复位以后，DIN端（数据接收端）接受从控制器传输过来的数据，**首先送过来的24bit数据被第一个像素点提取后，送到像素点内部的数据锁存器，剩余的数据经过内部整形处理电路整形放大后通过DO端（数据发送端）开始转发输出给下一个级联的像素点，每经过一个像素点的传输，信号减少24bit。** WS2812彩灯采用自动整形转发技术，使得像素点的级联个数不受限制，仅受限于信号传输速度的要求。 ## 使引脚输出高低电平，控制LED 1. `board.LED`控制着Bit S2上的一颗单色LED发光二极管，高电平点亮，低电平熄灭，在REPL中输入以下代码： ```py import board import digitalio ledpin digitalio.DigitalInOut(board.LED) ledpin.direction digitalio.Direction.OUTPUT ledpin.value True ``` 2. 或者这么做： ```py import board import digitalio ledpin digitalio.DigitalInOut(board.LED) ledpin.switch_to_output(value True) # value 1 ``` 3. 让LED间隔0.5秒闪烁： ```py import board import digitalio import time ledpin digitalio.DigitalInOut(board.LED) while True: ledpin.switch_to_output(value 1) time.sleep(0.5) ledpin.switch_to_output(value 0) time.sleep(0.5) ``` 4. 在REPL中使用中断快捷键即可停止程序的运行。 5. 在REPL中输入`import board;help(board)`即可列出所有可控制的引脚。`board.GP25` 与 `board.LED`完全相同。"},"/Bit_S2_doc/zh/CircuitPython/supported_by_circuitpython.html":{"title":"已得到CircuitPython官方支持","content":"# 已得到CircuitPython官方支持 1. 已得到adafruit/circuitpython GitHub存储库支持。 https://github.com/adafruit/circuitpython/pull/6899 分支已合并。 2. 已得到adafruit/tinyuf2 GitHub存储库支持。 https://github.com/adafruit/tinyuf2/pull/196 分支已合并。 3. 已得到adafruit/circuitpython org GitHub存储库支持。 https://github.com/adafruit/circuitpython org/pull/1049 分支已合并。 4. circuitpython.org 网页已可下载circuitpython固件与tinyuf2固件。 https://circuitpython.org/board/bpi_bit_s2/"},"/Bit_S2_doc/zh/CircuitPython/update_circuitpython.html":{"title":"更新CircuitPython固件的方法","content":"# 更新CircuitPython固件的方法 > 本方法适用于已具备tinyUF2固件的开发板，如果开发板的flash被擦除或出现无法进入UF2模式的故障，则需先参考[烧录tinyUF2固件的方法](flash_tinyuf2.html)。 1. 进入[BPI PicoW S3 CircuitPython 下载](https://circuitpython.org/board/bpi_picow_s3/)页面。 2. 点击DOWNLOAD UF2 NOW 按钮即可下载最新释放的`.uf2`固件。 3. 通过USB连接开发板与电脑，如果已经安装过CircuitPython固件，在此电脑文件管理页面将出现一个名为`CIRCUITPY`的磁盘，此为CircuitPython模式下的磁盘，需要使其变更为UF2模式下的磁盘，以下为具体操作步骤。 1. 快速按一次`RST`按键。 2. 第一颗彩灯亮紫色时迅速按一次`BOOT`按键。 4. UF2模式下的磁盘名称为`BITS2BOOT`，将第1步下载的`.uf2`固件复制到此磁盘中，过程中彩灯会闪烁橙灯，请勿在此过程中断开连接或对开发板进行任何操作。 5. 完成CircuitPython固件更新后会自动复位，在此电脑文件管理页面将重新出现一个`CIRCUITPY`磁盘，通过REPL可以查看具体的固件版本。"},"/Bit_S2_doc/zh/CircuitPython/config_mu-editor.html":{"title":"配置使用环境(Mu编辑器)","content":"# 配置使用环境(Mu编辑器) ## 下载安装Mu编辑器 1. 进入[**Mu编辑器官网**](https://codewith.mu/)，点击 **Download** 按钮进入新页面。 ![](../assets/images/Download_mu_1.png) 2. 选择你的电脑当前使用的操作系统，点击对应操作系统的 **Download** 按钮开始下载安装包。 ![](../assets/images/Download_mu_2.png) 3. 点击对应操作系统的 **Instuctions** 按钮即可查看详细的安装步骤，根据指引安装即可。 ## 建立Mu编辑器与开发板的连接 1. 启动Mu编辑器，将模式更改为CircuitPython，如果您已正确连接CircuitPython开发板，将提示您是否直接切换到该模式。 ![](../assets/images/Download_mu_3.png) ![](../assets/images/Download_mu_4.png) 2. 点击**Serrial**按钮，然后按任意键即可进入CircuitPython REPL。 ![](../assets/images/Download_mu_5.png)"},"/Bit_S2_doc/zh/Unboxing/Introduction.html":{"title":"【 开发板介绍 】","content":"# 【 开发板介绍 】 BPI Bit S2 开发板 是 BPI Bit 的后继型号，继承了大部分硬件功能。 IO与micro:bit兼容，可以使用大部分micro:bit的周边配件。 支持 Webduino, Arduino, MicroPython & CircuitPython 编程环境 ，适合应用于STEAM教育领域。 ## 关键特性 * ESP32 S2 * 25颗全彩LED灯 * 1个温度传感器 * 1个蜂鸣器 * 2个光敏传感器 * 正面两个背面一个可编程按键 * Type C USB接口 * 外形尺寸 5x5cm * 金手指IO定义与micro:bit完全兼容 ## 硬件 ### 示意图 ![](../assets/images/bpi_bit_v2_interface.jpg) ### 硬件规格 Features Specs MCU ESP32 S2FN4R2，Xtensa® 32 bit LX7 Single Core Processer Frequency 240MHz MAX operating temperature 40℃~+85℃ ROM 128 KB SRAM 320 KB FLASH ROM 4 MB PSRAM 2 MB WIFI IEEE 802.11 b/g/n ，2.4Ghz GPIO 19 available GPIO pins have been introduced Peripheral functions ADC,TOUCH,PWM,SPI,I2C,I2S,Pulse counter, RMT,TWAI® Controller,SD/MMC,LCD_CAMERA External crystal 40Mhz Buzzer 8.5x8.5mm buzzer LED 25 WS2812 rgb LED, single line GPIO control; 1 monochrome LED, controlled by GPIO0 Photosensitive sensor 2 photosensitive sensor Thermistor sensor 1 thermistor sensor IO 19 pins Goldfinger IO,19 pins contacts on the back Key 2 programmable keys,1 BOOT key,1 Reset key USB USB Type C interface，full speed USB OTG,USB ACM Operating voltage 3.3V Power USB Type C input 5V，or Goldfinger IO input 3.3V power supply Size 5 * 5 cm ### 板载外设GPIO分配及信号类型 板载外设 GPIO分配 信号类型 : :: :: : 光敏传感器(L) GPIO 12 Analog Input 光敏传感器(R) GPIO 13 Analog Input 按键 A GPIO 38 Digital Input 按键 B GPIO 33 Digital Input 按键 BOOT GPIO 0 Digital Input 温度传感器 GPIO 14 Analog Input 蜂鸣器 GPIO 17 PWM(Digital Output) RGB_LED GPIO 18 Digital Output ### 5*5 全彩LED灯顺序 BPI Bit S2 有25颗 WS2812 全彩LED灯, 单GPIO控制. 每颗LED的三原色像素都可以实现 8bit 256级亮度显示，及实现16777216色全彩显示，扫描频率不低于400Hz/s。 : :: :: :: :: : 20 15 10 5 0 21 16 11 6 1 22 17 12 7 2 23 18 13 8 3 24 19 14 9 4 ### 金手指引脚定义 ![](../assets/images/bpi_bit_v2_goldfinger.jpg) ### SPI与I2C预设引脚 Function Pin Name GPIO Num SPI_SCK P13 GPIO36 SPI_MISO P14 GPIO37 SPI_MOSI P15 GPIO35 SPI_CS P16 GPIO34 I2C_SCL P19 GPIO16 I2C_SDA P20 GPIO15 ### 供电 BPI Bit S2支持两种供电方式： 1. Type C USB：使用USB线供电，连接电脑USB接口或其他5V USB充电器即可为开发板供电。 2. 金手指：开发板底部金手指包含电源接口，同时具有输入和输出功能，使用3.3V供电，正极接3V3，负极接GND。 ## 资料与资源 [GitHub: BPI BPI Bit S2 开发板原理图PDF](https://github.com/BPI STEAM/BPI BIT Lite Doc/blob/main/sch/BPI BIT Lite V0.2.pdf)"},"/Bit_S2_doc/zh/Arduino/Basic.html":{"title":"板载资源的使用","content":"# 板载资源的使用 本章主要是通过一些示例项目，阐述 BPI Bit S2 的外设的基本使用方法，通过下面的项目，您可以进行修改完成您的自己的项目。 > 上传代码时需要将 BPI Bit S2 开发板置于bootloader模式。 确保有一根type c数据线，一端连接到PC，拿起开发板，保持上面无任何连线或外围硬件，按住Boot按钮，将type c数据线与开发板连接，松开Boot按钮，在 Tools > Ports中选择新出现的端口。 点击 Upload 即可将代码编译并上传到开发板中。 ## 项目一 WS2812 BPI Bit S2 使用25颗WS2812彩灯。 本项目是点亮 BPI Bit S2 的RGB彩灯的实验。 ### 所需元件 BPI Bit S2 主板 X 1 ![](../assets/images/Bit_S2_500x.png) >注意：该项目不需要连接其他传感器。 ### 输入代码 打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。 （这个程序需要Adafruit_NeoPixel库，需要在[GitHub](https://github.com/adafruit/Adafruit_NeoPixel)下载，解压到Arduino\\ Library 文件夹下）代码如下: <details> <summary>展开查看</summary> <pre><code> // NeoPixel Ring simple sketch (c) 2013 Shae Erisson // Released under the GPLv3 license to match the rest of the // Adafruit NeoPixel library #include <Adafruit_NeoPixel.h> #ifdef __AVR__ #include <avr/power.h> // Required for 16 MHz Adafruit Trinket #endif // Which pin on the Arduino is connected to the NeoPixels? #define PIN 18 // On Trinket or Gemma, suggest changing this to 1 // How many NeoPixels are attached to the Arduino? #define NUMPIXELS 25 // Popular NeoPixel ring size // When setting up the NeoPixel library, we tell it how many pixels, // and which pin to use to send signals. Note that for older NeoPixel // strips you might need to change the third parameter see the // strandtest example for more information on possible values. Adafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800); #define DELAYVAL 500 // Time (in milliseconds) to pause between pixels void setup() { // These lines are specifically to support the Adafruit Trinket 5V 16 MHz. // Any other board, you can remove this part (but no harm leaving it): #if defined(__AVR_ATtiny85__) && (F_CPU 16000000) clock_prescale_set(clock_div_1); #endif // END of Trinket specific code. pixels.begin(); // INITIALIZE NeoPixel strip object (REQUIRED) } void loop() { pixels.clear(); // Set all pixel colors to 'off' // The first NeoPixel in a strand is #0, second is 1, all the way up // to the count of pixels minus one. for(int i 0; i < NUMPIXELS; i++) { // For each pixel... // pixels.Color() takes RGB values, from 0,0,0 up to 255,255,255 // Here we're using a moderately bright green color: pixels.setPixelColor(i, pixels.Color(25, 25, 25)); pixels.show(); // Send the updated pixel colors to the hardware. delay(DELAYVAL); // Pause before next pass through loop } } </code></pre> </details> 输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后 IDE 会把代码发送给 BPI Bit S2 主板。复位后WS2812灯会开始亮绿灯， >注意：如果需要其他颜色，可以修改代码中的RGB值。 ### 代码分析 本项目使用 BPI Bit S2 集成的WS2812灯，默认GPIO是18。 ``` #define PIN 18 ``` 设置GPIO引脚号 ``` #define NUMPIXELS 25 ``` 设置灯的个数，如果您想连接更多WS2812 彩灯，可以换一个IO，并修改灯的数量。 ## 项目二 触摸传感器 BPI Bit S2 提供了多达 11 个可用的电容式传感器 GPIO，能够探测由手指或其他物品直接接触或接近而产生的电容差异。这种低噪声特性和电路的高灵敏度设计适用于较小的触摸板，可以直接用于触摸开关。本项目阐述了如何通过Arduino 代码获取 BPI Bit S2 的触摸传感器状态，并打印状态。 ### 所需元件 BPI Bit S2 主板 X 1 ![](../assets/images/Bit_S2_500x.png) >注意：该项目不需要连接其他传感器。 ### 输入代码 打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。 代码如下: <details> <summary>展开查看</summary> <pre><code> void setup() { Serial.begin(115200); delay(1000); // give me time to bring up serial monitor Serial.println(\"BPI Bit S2 Touch Test\"); } void loop(){ Serial.println(touchRead(T2)); // get value using T0 >D9 delay(100); } </code></pre> </details> 输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后 IDE 会把代码发送给 BPI Bit S2 主板。打开 Arduino IDE 串口监视器，并用手触摸 GPIO2（T2 对应的是GPIO2），可以看到会打印出的数据突然变小，如下图所示： ![](../assets/images/Lesson8 1.png) ### 代码分析 获取触摸传感器的 GPIO 状态，只需要调用 touchRead 函数，函数原型如下： ``` uint16_t touchRead(uint8_t pin) ``` 返回“0”表示没有触摸，“1”表示触摸。其中 pin 是 T0~T9，对应到 BPI Bit S2的引脚如下表所示： ![](../assets/images/bpi_bit_v2_goldfinger.jpg) <table> <tr> </tr> <tr> <td>触摸传感器序号 </td> <td>对应的 ESP32 硬件 </td> <td>BPI Bit S2</td> </tr> <tr> <td>T1</td> <td>GPIO1</td> <td>P1</td> </tr> <tr> <td>T2 </td> <td>GPIO2 </td> <td>P2</td> </tr> <tr> <td>T3 </td> <td>GPIO3</td> <td>P3</td> </tr> <tr> <td>T4 </td> <td>GPIO4</td> <td>P4</td> </tr> <tr> <td>T5 </td> <td>GPIO5</td> <td>P5</td> </tr> <tr> <td>T6 </td> <td>GPIO6</td> <td>P6</td> </tr> <tr> <td>T7 </td> <td>GPIO7</td> <td>P7</td> </tr> <tr> <td>T8 </td> <td>GPIO8</td> <td>P8</td> </tr> <tr> <td>T9 </td> <td>GPIO9</td> <td>P9</td> </tr> <tr> <td>T10</td> <td>GPIO10</td> <td>P10</td> </tr> <tr> <td>T11</td> <td>GPIO11</td> <td>P11</td> </tr> </table> ## 项目三 串口实验 在最开始的章节中，我们上传了一个 Blink 闪烁程序来测试板子上的 LED 状态灯。现在，我们使用 UART 串口，每秒打印一次计时数据。 ### 所需元件 BPI Bit S2 主板 X 1 ![](../assets/images/Bit_S2_500x.png) ### 硬件连接 此项目不需要其他传感器，所以只需要把BPI Bit S2用USB连到电脑就能用。 ### 输入代码 打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。 代码如下: <details> <summary>展开查看</summary> <pre><code> void setup() { Serial.begin(115200); //设置串口通信波特率 } void loop() { static unsigned long i 0; //定义变量i Serial.println(i++); //i加一后输出i delay(1000); //延时1秒 } </code></pre> </details> 输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后 IDE 会把代码发送给 BPI Bit S2 主板。上传完成之后，你需要按一下复位键，这样代码就能正常运行了 ### 实验现象 完成之前步骤的上传后，打开 Arduino IDE 自带的串口监视器，可以看到如下的打印信息： ![](../assets/images/Lesson1 1.png) ## 项目四 PWM(呼吸灯) 呼吸灯，即让 BPI Bit S2 通过 PWM 驱动 LED 灯，实现 LED 的亮度渐变，看起来就像是在呼吸一样。关于 PWM 的解释，请阅览知识扩展部分。 ### 所需元件 BPI Bit S2 主板 X 1 ![](../assets/images/Bit_S2_500x.png) LED X 1 (建议串联一个电阻限流) ![](../assets/images/led.png) ### 硬件连接 将LED连接到BPI Bit S2的GPIO17就可以了，长的那个脚接GPIO17，短的接到GND ### 输入代码 打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。 代码如下: <details> <summary>展开查看</summary> <pre><code> #define LED_CHANNEL_0 0 //设置通道0 #define LED_TIMER_13_BIT 13 //设置13位定时器 #define LED_BASE_FREQ 5000 //设置定时器频率位5000Hz #define LED_PIN 13 //设置LED灯 int brightness 0; // LED亮度 int fadeAmount 1; // LED数量 //设置led灯的亮度 void ledcAnalogWrite(uint32_t value, uint32_t valueMax 255) { //计算占空比 uint32_t duty (LED_BASE_FREQ / valueMax) * min(value, valueMax); //设置占空比 ledcWrite(LED_CHANNEL_0, duty); } void setup() { ledcSetup(LED_CHANNEL_0, LED_BASE_FREQ, LED_TIMER_13_BIT); ledcAttachPin(LED_PIN, LED_CHANNEL_0); } void loop() { ledcAnalogWrite(brightness); brightness + fadeAmount; if (brightness < 0 brightness > 255) { fadeAmount fadeAmount; } delay(30); } </code></pre> </details> 输入完成后，点击“编译”按钮检查代码是否有错误。确定没有错误后可以开始上传了，点击“上传”按钮 。IDE 会把代码发送给 BPI Bit S2 主板。上传完成后您就可以看见Type C旁边的LED 灯开始“呼吸”了！ 现在让我们来回顾一下代码和硬件，看看它是如何工作。 ### 知识学习 什么是 PWM 控制信号？ PWM（pulse width modulation）脉冲宽度调制，MCU（微控制器）通过对开关器件的通断进行控制，使输出端得到一系列幅值相等的脉冲，用这些脉冲来代替正弦波或所需的波形。如下图所示： ![](../assets/images/Lesson2 1.jpg) 其中，tON 是高电平持续时间，tPWM 是 PWM 波的周期，tPWM tON 是低电平持续时间，占空比是指高电平持续时间占整个周期的比例，即 D ton/tPWM 。 ### 代码分析 BPI Bit S2 的 PWM 比普通的 Arduino UNO 高级的多，设置上不能简单的使用analogWrite 函数来驱动 PWM，而是需要设置 timer 函数，以及相关的频率参数等才能工作。 ``` #define LEDC_CHANNEL_0 0 ``` 定义了定时器使用的通道，BPI Bit S2 总共有 16 个通道，这里用的是通道 0。 ``` #define LEDC_TIMER_13_BIT 13 ``` 定义了定时器为 13 位定时器，即定时器最大计数为 2 的 13 次方。 ``` #define LEDC_BASE_FREQ 5000 ``` 这是设置定时器的频率，单位是 Hz。接下来的 brightness 和 fadeAmount 参数分别表示 PWM 的占空比和每次变化的数值。 ``` void ledcAnalogWrite(uint32_t value, uint32_t valueMax 255) ``` 这个函数是计算 PWM 占空比和设置 PWM 占空比，类似 Arduino 的 analogWrite 函数，可以看到，传递参数的最大值是 255，这是为了和 analogWrite 兼容。 ``` ledcSetup(LEDC_CHANNEL_0, LEDC_BASE_FREQ, LEDC_TIMER_13_BIT); \t ledcAttachPin(LED_PIN, LEDC_CHANNEL_0); ``` 这两个函数是 BPI Bit S2 定时器设置函数，函数原型及原理这里不讲述，如果您感兴趣可以看看底层源码（源码地址：C:\\Users\\“your PC”\\AppData\\Local\\Arduino15\\packages\\esp32\\ hardware\\ adafruit_metro_esp32s2 \\0.0.3\\libraries\\ESP32\\），这里只需要知道怎么用这些函数来设置相关的 timer 就可以了。 关于什么是 PWM 信号，在前面已经阐述过了，这里不再说明。 >注意：BPI Bit S2 的任何引脚都可以配置成 PWM 输出，您可以尝试着修改代码，完成您的项目。 ## 项目五 ADC ADC（模数转换器即 A/D 转换器），是指将模拟信号转变成数字信号。BPI Bit S2 的ADC 是13位的，最大输出值为 8191，而 Arduino UNO 是 10 位的，最大输出值是 1023，因此，在精度上比Arduino UNO 要高，而且转换速率快，且在使用上兼容 Arduino analogRead 函数，直接读取即可。 ### 所需元件 模拟角度传感器 X 1 ![](../assets/images/Lesson3 1.png) 面包板 X 1 ![](../assets/images/Lesson3 2.png) BPI Bit S2 主板 X 1 ![](../assets/images/Bit_S2_500x.png) ### 硬件连接 把 电位计插接到 BPI Bit S2 主板上，然后将模拟角度传感器插接到 IO2（实验中用的是IO2）。 元件连接好后，使用 USB 线连接 BPI Bit S2 和电脑。 ### 输入代码 打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。代码如下: <details> <summary>展开查看</summary> <pre><code> void setup() { // put your setup code here, to run once: Serial.begin(115200); } void loop() { // put your main code here, to run repeatedly: Serial.println(analogRead(2)); delay(100); } </code></pre> </details> 输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后IDE 会把代码发送给 BPI Bit S2 主板。上传完成后，打开 Arduino IDE 的串口监视器，旋转模拟角度传感器，可以看到串口监视器中的数值变化，如下图所示： ![](../assets/images/Lesson3 3.png) ### 代码分析 由于BPI Bit S2 的 ADC 在使用上完全兼容 Arduino，因此这里不再对analogRead 函数进行过多的讲解。 注意：如果您对 Arduino 的基本函数不是特别熟悉，您可以[点击链接](https://www.arduino.cc/en/Tutorial/BuiltInExamples)进行学习。 ## 项目六 I2C BPI Bit S2 的 I2C 可以配置到任意 I/O 口，您可以通过传递相关参数进行配置。为了方便使用，我们已经将 I2C 进行了默认配置，在使用上完全兼容 Arduino，默认配置引脚可以在第一章简介中查看到。本项目是基于 I2C 默认配置，驱动 OLED 显示屏。 所需元件 I2C OLED 12864 显示屏 X 1 ![](../assets/images/Lesson4 1.png) 面包板 X 1 ![](../assets/images/Lesson3 2.png) BPI Bit S2 主板 X 1 ![](../assets/images/Bit_S2_500x.png) ### 硬件连接 把BPI Bit S2 主板插到面包板上，然后将 OLED显示屏插接到 I2C 接口。（SDA是33，SCL是34）元件连接好后，使用 USB 线连接 BPI Bit S2 和电脑。 ### 输入代码 打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。代码如下: <details> <summary>展开查看</summary> <pre><code> #include <Wire.h> int UG2864Address 0x3C;//OLED UG2864器件7位地址 prog_char F8X16[][16] PROGMEM { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,// 0 0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00,//!1 0x00,0x10,0x0C,0x06,0x10,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//\"2 0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00,//#3 0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00,//$4 0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00,//%5 0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10,//&6 0x10,0x16,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//'7 0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00,//(8 0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00,//)9 0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00,//*10 0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00,//+11 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00,0x00,0x00,//,12 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,// 13 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00,//.14 0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00,///15 0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00,//016 0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//117 0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00,//218 0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00,//319 0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00,//420 0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00,//521 0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00,//622 0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00,//723 0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00,//824 0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00,//925 0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,//:26 0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x60,0x00,0x00,0x00,0x00,//;27 0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00,//<28 0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,// 29 0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00,//>30 0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00,//?31 0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00,//@32 0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20,//A33 0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00,//B34 0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00,//C35 0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00,//D36 0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00,//E37 0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00,//F38 0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00,//G39 0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20,//H40 0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//I41 0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00,//J42 0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00,//K43 0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00,//L44 0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00,//M45 0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00,//N46 0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00,//O47 0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00,//P48 0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00,//Q49 0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20,//R50 0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00,//S51 0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//T52 0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//U53 0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00,//V54 0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00,//W55 0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20,//X56 0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//Y57 0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00,//Z58 0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00,//[59 0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00,//\\60 0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00,//]61 0x00,0x00,0x04,0x02,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//^62 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,//_63 0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//`64 0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20,//a65 0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00,//b66 0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00,//c67 0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20,//d68 0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00,//e69 0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//f70 0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00,//g71 0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//h72 0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//i73 0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,//j74 0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00,//k75 0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//l76 0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F,//m77 0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//n78 0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//o79 0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00,//p80 0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80,//q81 0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00,//r82 0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00,//s83 0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00,//t84 0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20,//u85 0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00,//v86 0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00,//w87 0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00,//x88 0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00,//y89 0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00,//z90 0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40,//{91 0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,//92 0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00,//}93 0x00,0x06,0x01,0x01,0x02,0x02,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//~94 }; char ch_buf[17] {0}; int RES 6;//Gadgeteer PIN6 int DC 7;//Gadgeteer PIN3 void Writec(unsigned char COM) { Wire.beginTransmission(UG2864Address); Wire.write(0x00); Wire.write(COM); Wire.endTransmission(); } void Writed(unsigned char DATA) { Wire.beginTransmission(UG2864Address); Wire.write(0x40); Wire.write(DATA); Wire.endTransmission(); } void SSD1306() { Writec(0XAE);//display off Writec(0X00);//set lower column address Writec(0X10);//set higher column address Writec(0X40);//set display start line Writec(0XB0);//set page address Writec(0X81);//set contract control Writec(0XCF);// VCC Generated by Internal DC/DC Circuit Writec(0XA0);//set segment remap column address 127 is mapped to SEG0 Writec(0XA6);//normal / reverse normal display Writec(0XA8);//multiplex ratio Writec(0X3F);//1/64 Writec(0XC0);//Com scan direction remapped mode. Scan from COM[N 1] to COM0 Writec(0XD3);//set display offset Writec(0X00); Writec(0XD5);//set osc division Writec(0X80); Writec(0XD9);//set pre charge period Writec(0X11); Writec(0XDa);//set COM pins Writec(0X12); Writec(0X8d);/*set charge pump enable*/ Writec(0X14); Writec(0Xdb);//Set VcomH Writec(0X20); Writec(0XAF);//display ON } void fill(unsigned char dat) { unsigned char i,j; Writec(0x00);//set lower column address Writec(0x10);//set higher column address Writec(0xB0);//set page address for(j 0;j<8;j++) { Writec(0xB0+j);//set page address Writec(0x00);//set lower column address Writec(0x10);//set higher column address for(i 0;i<128;i++) { Writed(dat); } } } void show_string(unsigned char x,unsigned char y,char *s) { unsigned char i,j,lower,higher; char *t; t s; lower y%16; higher y/16; if((x>3) (y>120)) return; Writec(0xB0+x*2);//set page address Writec(lower);//set lower column address Writec(0x10+higher);//set higher column address for(j 0;*s! '\\0';j++) { for(i 0;i<8;i++){ ch_buf[i] pgm_read_word(&F8X16[*s 32][i]); } for(i 0;i<8;i++) Writed(ch_buf[i]); s++; } Writec(0xB0+x*2+1);//set page address Writec(lower);//set lower column address Writec(0x10+higher);//set higher column address s t; for(j 0;*s! '\\0';j++) { for(i 0;i<8;i++){ ch_buf[i] pgm_read_word(&F8X16[*s 32][i+8]); } for(i 0;i<8;i++) Writed(ch_buf[i]); s++; } } void oled_init(void) { pinMode(RES,OUTPUT);//RES pinMode(DC,OUTPUT);//D/C# digitalWrite(DC,LOW); Wire.begin(); digitalWrite(RES,HIGH); delay(100); digitalWrite(RES,LOW); delay(100); digitalWrite(RES,HIGH); delay(100); SSD1306(); fill(0x00); } void setup() { oled_init(); } void loop() { fill(0x00); show_string(0,12,\"BananaPi\"); show_string(2,12,\"banana pi.org\"); while(1); } </code></pre> </details> 输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后 IDE \t会把代码发送给 BPI Bit S2 主板。上传完成后，OLED 显示屏会显示“BananaPi banana pi.org”字样。 ### 代码分析 本项目的代码相对于前面的项目较多，主要是基于 I2C 通信对 OLED 显示屏底层寄存器的直接驱动。 ``` void Writec(unsigned char COM) ``` 设置寄存器函数，通过 I2C 对 OLED 显示屏设置，I2C 使用方法完全兼容 Arduino。 ``` void Writed(unsigned char DATA) ``` 写数据函数，I2C 使用方法完全兼容 Arduino。 >注意：BPI Bit S2 的 I2C 与 Arduino 完全兼容，主要是调用 Wire 库文件使用。 ## 项目七 SPI 在很多传感器中，都使用 SPI 通信，因为 SPI 通信速率相对于 I2C 更快，没有地址冲突的弊端。SPI，是 一种高速的、全双工、同步的通信总线，而 BPI Bit S2 的 SPI 可以配置到所有 I/O，您可以阅览底层 代码进行使用（初学者不建议使用）。为了更好的使用体验，BPI Bit S2 默认情况下配置了IO35、IO36、IO37 为 SPI 口，在使用上则完全兼容 Arduino。 本项目使用 BPI Bit S2，通过 SPI 读取 BME280 温湿度传感器的数据，示例中使用的是BME280 库文件，关于 SPI 驱动您可以阅览 BEM280 库文件，[点击链接](https://github.com/DFRobot/DFRobot_BME280)下载 BME280 库文件。 ### 所需元件 BME280 温湿度传感器 X 1 ![](../assets/images/Lesson5 1.png) >注意：BME280 传感器本身支持 I2C 和 SPI 通信，这里我们采用 SPI 通信。 面包板 X 1 ![](../assets/images/Lesson3 2.png) BPI Bit S2 主板 X 1 ![](../assets/images/Bit_S2_500x.png) ### 输入代码 打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。 （这个程序需要DFRobot_BME280库，需要在[GitHub](https://github.com/DFRobot/DFRobot_BME280)下载，解压到Arduino\\ Library 文件夹下 ）代码如下： <details> <summary>展开查看</summary> <pre><code> /*! * read_data_spi.ino * * Download this demo to test read data from bme280, connect sensor through spi interface * Connect cs pin to io 2 * Data will print on your serial monitor * * Copyright [DFRobot](http://www.dfrobot.com), 2016 * Copyright GNU Lesser General Public License * * version V1.0 * date 12/03/2019 */ #include \"DFRobot_BME280.h\" #include \"Wire.h\" typedef DFRobot_BME280_SPI BME; // ******** use abbreviations instead of full names ******** # define PIN_CS 2 BME bme(&SPI, PIN_CS); // select TwoWire peripheral and set cs pin id #define SEA_LEVEL_PRESSURE 1015.0f // show last sensor operate status void printLastOperateStatus(BME::eStatus_t eStatus) { switch(eStatus) { case BME::eStatusOK: Serial.println(\"everything ok\"); break; case BME::eStatusErr: Serial.println(\"unknow error\"); break; case BME::eStatusErrDeviceNotDetected: Serial.println(\"device not detected\"); break; case BME::eStatusErrParameter: Serial.println(\"parameter error\"); break; default: Serial.println(\"unknow status\"); break; } } void setup() { Serial.begin(115200); bme.reset(); Serial.println(\"bme read data test\"); while(bme.begin() ! BME::eStatusOK) { Serial.println(\"bme begin faild\"); printLastOperateStatus(bme.lastOperateStatus); delay(2000); } Serial.println(\"bme begin success\"); delay(100); } void loop() { float temp bme.getTemperature(); uint32_t press bme.getPressure(); float alti bme.calAltitude(SEA_LEVEL_PRESSURE, press); float humi bme.getHumidity(); Serial.println(); Serial.println(\" start print \"); Serial.print(\"temperature (unit Celsius): \"); Serial.println(temp); Serial.print(\"pressure (unit pa): \"); Serial.println(press); Serial.print(\"altitude (unit meter): \"); Serial.println(alti); Serial.print(\"humidity (unit percent): \"); Serial.println(humi); Serial.println(\" end print \"); delay(1000); } </code></pre> </details> 输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后 IDE 会把代码发送给 BPI Bit S2 主板。打开 Arduino 串口监视器，可以看到打印信息如下： ![](../assets/images/Lesson5 2.png) ### 代码分析 本项目采用的是 BME280 库文件，在 Item 5.ino 文件中并没有对 SPI 底层进行操作，不过，BPI Bit S2 ESP32 S3 的 SPI 使用完全兼容 Arduino。"},"/Bit_S2_doc/zh/Arduino/Environment.html":{"title":"环境搭建","content":"# 环境搭建 > 参考[arduino esp32 DOC Getting Started » Installing](https://docs.espressif.com/projects/arduino esp32/en/latest/installing.html) ## 使用Arduino IDE安装支持 这是直接从 Arduino IDE 安装 Arduino ESP32 的方法。 > 从 Arduino IDE 版本 1.6.4 开始，Arduino 允许使用 Boards Manager（开发板管理器）安装第三方平台包。有适用于 Windows、macOS 和 Linux 的软件包。 Arduino IDE 下载地址：https://www.arduino.cc/en/software > Arduino IDE 2.0与Arduino IDE 1.8.x的UI有些许差异，本文基于1.8.13版本编写，但不影响使用2.0版本的用户参考。 要使用 Boards Managaer（开发板管理器）安装esp32平台包，请执行以下步骤： 安装当前上游 Arduino IDE 1.8 或更高版本。 启动 Arduino 并打开 File（文件）> Preferences（首选项）窗口，找到Additional Board Manager URLs（附加开发板管理器网址）。 ![](../assets/images/install_guide_preferences.png) 稳定版链接： ``` https://raw.githubusercontent.com/espressif/arduino esp32/gh pages/package_esp32_index.json ``` 开发版链接： ``` https://raw.githubusercontent.com/espressif/arduino esp32/gh pages/package_esp32_dev_index.json ``` 在Additional Board Manager URLs后面输入上述发布链接之一。您可以添加多个 URL，一行一个。 ![](../assets/images/install_guide_boards_manager_url.png) 从菜单打开 Tools（工具） > Board（开发板）> Board Manager（开发板管理器） 搜索并安装esp32平台。 ![](../assets/images/install_guide_boards_manager_esp32.png) 重启arduino IDE之后可以看到在开发板选项中多了ESP32 Arduino选项。 选择 `ESP32S2 Native USB` 这个型号，再参照下图所示的内容进行配置一遍即可，配置不当是无法使用的，请一定要参照下图所示的内容进行配置！ ![](../assets/images/Board_chose.png)"},"/Bit_S2_doc/zh/index.html":{"title":"【 BPI-Bit-S2 开发板 】","content":"# 【 BPI Bit S2 开发板 】 ## 介绍 ![](assets/images/BPI Bit S2_banner.jpg) BPI Bit S2 开发板 是 BPI Bit 的后继型号，继承了大部分硬件功能。 IO与micro:bit兼容，可以使用大部分micro:bit的周边配件。 支持 Webduino, Arduino, MicroPython & CircuitPython 编程环境 ，适合应用于STEAM教育领域。 在 [开箱 Bit S2 开发板](Unboxing/Introduction.html) 页面查看详情。 ## 使用 CircuitPython 编程 > 推荐通过CircuitPython快速上手BPI Bit S2 开发板。 ![](assets/images/CircuitPython_Repo_header_logo.jpg) CircuitPython是MicroPython的一个教育友好型的开源衍生产品，由Adafruit Industries支持与开发。 在易用性上，它在MicroPython的基础上更进一步。 使用CircuitPython固件的开发板连接PC时，PC将会立即得到一个USB存储磁盘，将python脚本文件复制进此磁盘即可让程序在此开发板上运行。 这就做到了让用户开箱即用，因为绝大多数现代个人操作系统和家用PC都是支持USB存储磁盘的。 当然为了能使用REPL，至少还是需要安装一个串口通信软件，或是支持这个功能的文本编辑器，例如Mu编辑器。 CircuitPython 社区提供极其丰富的外设驱动库，API文档，教程。即使没有编程基础，没有硬件基础，从零开始也可快速上手。 CircuitPython不支持定时器，硬件中断等一些特定用于微控制器的库，也不支持多线程的_thread 库，仅提供编写并发代码的 asyncio 库。 在CircuitPython所支持的微控制器和其Blinka所支持的单板计算机(SBCs)中，代码具有很好的可移植性，这得益于它在统一API上的努力。 ## 使用 MicroPython 编程 ![](assets/images/Mircopython.png) MicroPython是Python 3编程语言的精益高效实现，包括 Python 标准库的一小部分，并且经过优化，可在微控制器和有限的硬件资源中运行。 由 Damien P. George 于 2013年 众筹开源。 它与使用C程序开发微控制器最明显的差异性，就是验证代码时无需漫长的编译。 使用串口通信软件，通过REPL(read eval print loop)输入命令来控制微控制器，和Python的REPL一样。 也可使用一些工具将 python 脚本文件上传到微控制器内运行。 它对Python 3 的实现，包括了支持多线程的 _thread 库，编写并发代码的 asyncio 库。 它尽可能与普通Python兼容，允许您轻松地将代码从桌面端移植到微控制器。 同时它还具备一些特定用于微控制器的库，以便充分利用微控制器芯片内的硬件功能，例如定时器，硬件中断，WiFi等，这取决于具体的硬件。 在具备上述特性的同时，它的硬件开销很少，最低只需 256k 的代码空间和 16k 的 RAM 即可运行。 如果你了解Python，很大程度上你就已经了解MicroPython了。 在另一方面，你深入地学习MicroPython，也能提升你对Python的理解。 ## 使用 Arduino 编程 ![](assets/images/Arduino_logo_1200x350.png) Arduino 是一个开源嵌入式软硬件开发平台，用来供用户制作可交互式的嵌入式项目。 Arduino 集成开发环境（IDE）是此平台的软件核心，使用C/C++编程语言开发项目。 Arduino 最大的特性就是提供统一的API来开发所有它所支持的微控制器，具有非常良好的代码可移植性和可复用性。 此外它简化了搭建开发环境的过程，所有它所支持的微控制器的开发环境都可一键安装配置。 它还提供简单的一键式机制来编译和上传程序到微控制器中运行。 Arduino IDE中还集成了很多例程，辅有大量的注释，能帮助用户快速上手。 Arduino 社区中积累的大量的优秀开源项目可供参考与学习，还有相当多的芯片制造商提供的驱动库与API。 ## 使用 Webduino 编程 > BPI Bit S2 出厂已安装 Webduino 固件。 ![](assets/images/Webduino_logo_1200x350.jpg) [webduino在线积木编程平台](https://webbit.webduino.io/blockly/?demo default) [ webduino积木编程平台 Windows安装版](https://ota.webduino.io/WebBitInstaller/WebBitSetup.exe) [webduino在线教学手册](https://webbit.webduino.io/tutorials/doc/zh cn/education/index.html) ## 资料与资源 [官方WIKI](https://wiki.banana pi.org/BPI Bit S2_STEAM_%E6%95%99%E8%82%B2%E5%BC%80%E5%8F%91%E6%9D%BF) [GitHub: BPI BPI Bit S2 开发板原理图PDF](https://github.com/BPI STEAM/BPI BIT Lite Doc/blob/main/sch/BPI BIT Lite V0.2.pdf) ## 样品购买 [官方速卖通](https://www.aliexpress.us/item/3256804809903732.html) [官方淘宝](https://item.taobao.com/item.htm?spm a213gs.success.result.1.d1187a86CepiGC&id 693462857865) OEM&OEM 定制服务 ： sales@banana pi.com"},"/Bit_S2_doc/zh/no_translate.html":{"title":"no_translate_title","content":" title: no_translate_title class: md_page <div id \"visit_from\"></div> <div id \"no_translate_hint\">no_translate_hint</div> <div> <span id \"visit_hint\">visit_hint</span> <a id \"translate_src\"></a> </div> <div> <script> function getQueryVariable(variable) { var query window.location.search.substring(1); var vars query.split(\"&\"); for (var i 0;i<vars.length;i++) { var pair vars[i].split(\" \"); if(pair[0] variable){return pair[1];} } return(false); } var ref getQueryVariable(\"ref\"); var from getQueryVariable(\"from\"); var link document.getElementById(\"translate_src\"); var fromDis document.getElementById(\"visit_from\"); link.href ref; link.text ref; fromDis.innerHTML from; </script> </div>"}}