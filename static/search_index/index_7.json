{"/Leaf_S3_doc/en/MicroPython/Firmware.html":{"title":"Micropython firmware download and burning","content":"# Micropython firmware download and burning The firmware supporting ESP32S3 chip can be found on [MicroPython official website](https://micropython.org/) https://micropython.org/download/ESP32_GENERIC_S3/ After clicking the link to enter the page, you can see several firmware download addresses below, select a file with a .bin suffix and download it locally. ![](../assets/images/Micropython_operating_env_6.jpg) Pay attention to the date marked in the firmware name, the closer to the current time, the newer the function. You can use two tools to burn the firmware, Espressif's official FLASH download tool or esptool, you can choose one of the two. ## Set firmware download mode There are two methods of operation: 1. Connect to the computer via USB, press and hold the BOOT button, then press the RESET button and release it, and finally release the BOOT button. 2. Press and hold the BOOT button when the power supply is disconnected, then connect to the computer via USB, and finally release the BOOT button. It can be seen from this that the chip selects the startup mode when reset or re powered through the GPIO0 controlled by the BOOT key. Confirm the COM interface in the device manager. The serial number of the COM interface in the firmware download mode and the normal mode is usually different. ## Windows FLASH download tool Download and unzip: [FLASH download tool download address](https://www.espressif.com/zh hans/support/download/other tools) Open the software and select the chip model as ESP32S3, and set the download mode to usb: ![](../assets/images/Micropython_operating_env_7.png) At this point, you need to set the development board to firmware download mode. Under the condition that the chip is in the firmware download mode, modify the COM interface to the corresponding interface in the FLASH download tool window, here is COM22. Add MicroPython firmware, set the flash start address to `0x0` for ESP32 S3 chip. ![](../assets/images/Micropython_operating_env_8.png) First click the ERASE button to clear the data on the flash, and then click START to burn the firmware to the flash. After the programming is completed, press the RESET button once to make the development board enter the normal use mode. ## esptool Take the specific operation steps of Windows PowerShell as an example. Install esptool with the following command: ```shell pip install esptool ``` If needed in the future, you can upgrade esptool with the following command: ```shell pip install U esptool ``` Go into the directory where the firmware is located in PowerShell via a command or other method. A PowerShell window can be opened in this folder by holding down the shift key and right clicking in the Windows folder window. At this time, you need to set the development board to firmware download mode, see above for details. To clear the flash through the following commands, you need to modify the COM interface to the corresponding interface, here is COM1. ```shell python m esptool chip esp32s3 port COM1 erase_flash ``` To burn the firmware through the following commands, you need to modify the firmware file name corresponding to the current file name to be burned. ```shell python m esptool chip esp32s3 port COM1 baud 460800 before usb_reset after no_reset write_flash 0x0 GENERIC_S3_SPIRAM 20220618 v1.19.1.bin ``` If it is burned through USB, press the RESET button once to reset after completion, so that the development board enters the normal use mode. If programming via UART, it will reset automatically after completion."},"/Leaf_S3_doc/en/MicroPython/Basic.html":{"title":"Basic use case","content":"# Basic use case >[GitHub BPI Leaf S3 routines](https://github.com/BPI STEAM/BPI Leaf S3 Doc/tree/main/Example/MicroPython zh/02.Use_Peripherals) ## Light up the onboard LED lamp bead After completing [MicroPython runtime environment settings](Environment.html), you can try programming immediately. Create a new main.py script file and enter the following code in it: ```py from machine import Pin from neopixel import NeoPixel import time pin_48 Pin(48) np NeoPixel(pin_48, 1, bpp 3, timing 1) while True: np[0] (25,25,25) np. write() time. sleep_ms(250) np[0] (0,0,0) np. write() time. sleep_ms(250) ``` Save the file to the MicroPython device, click the \"Run\" button to make the onboard colored LED flash. Modify the data in the tuple on the right side of `np[0] (25,25,25)` to change the color, which corresponds to the brightness levels of R, G, and B respectively. The setting range is 0 255, and the recommended range is 0 25. When the brightness is too high, please do not look directly at it for a long time! [neopixel — control of WS2812 / NeoPixel LEDs — MicroPython documentation](https://docs.micropython.org/en/latest/library/neopixel.html) ## Make the lights cycle through nine colors ```py from machine import Pin from neopixel import NeoPixel import time pin_48 Pin(48, Pin.OUT) np NeoPixel(pin_48, 1, bpp 3, timing 1) RED (255, 0, 0) ORANGE (255, 100, 0) YELLOW (255, 255, 0) GREEN (0, 255, 0) CYAN (0, 255, 255) BLUE (0, 0, 255) PURPLE (180, 0, 255) WHITE (255, 255, 255) OFF (0, 0, 0) color_list [RED,ORANGE,YELLOW,GREEN,CYAN,BLUE,PURPLE,WHITE,OFF] brightness 0.1 while True: for i in color_list: color (round(i[0]*brightness),round(i[1]*brightness),round(i[2]*brightness)) np[0] color np. write() time. sleep(1) ``` ## Full color LED lamp beads cycle display rainbow colors Based on the previous section, we can go one step further and write a loop to automatically change the color of the lamp bead. ```py from machine import Pin from neopixel import NeoPixel import time def rainbow(num 1,level 25,delay 100): def write_all(num,delay,red,green,blue): for j in range (num): np[j] (red,green,blue) np. write() time. sleep_ms(delay) red,green,blue level,0,0 rainbow_step_list2 [(0,1,0),( 1,0,0),(0,0,1),(0, 1,0),(1,0,0),(0,0, 1)] for step in rainbow_step_list2: for i in range (level): red+ step[0] green+ step[1] blue+ step[2] write_all(num,delay,red,green,blue) np NeoPixel(Pin(48, Pin.OUT), 1,bpp 3, timing 1) while True: rainbow(num 1,level 25,delay 10) ``` This routine can be applied to ws2812 light strips of any length. Modify the first parameter in `NeoPixel(Pin(48, Pin.OUT), 1,bpp 3, timing 1)` to any GPIO pin that you want to connect the light strips in series. Modify the num parameter in `rainbow(num 1,level 25,delay 100)` to be the number of corresponding lamp beads on the light strip. Of course, we can also use for loop or while loop to make the color change pattern we want according to our own ideas. ## Design button interrupt program to control colored lights BPI Leaf S3 has two buttons, BOOT and RST, RST controls the hardware reset of the chip, and BOOT is connected to GPIO0, the circuit is shown in the figure below. ![](../assets/images/bpi leaf s3_boot_sch.png) It can be seen that when the development board is powered on and working normally, when the BOOT button is not pressed, GPIO0 is connected to 3.3v with a resistor in series, and it is at a high potential at this time. When the BOOT button is pressed, GPIO0 will be directly grounded, and at this time it is a low potential. The ESP32 S3 chip can determine whether the button is pressed by detecting the potential of this GPIO pin. [MicroPython GPIO interrupt program machine.Pin.irq documentation](https://docs.micropython.org/en/latest/library/machine.Pin.html#machine.Pin.irq) In the program, by detecting the trigger mode of the GPIO interrupt, you can design a set of interrupt program that records the number of times the button is pressed, and control the color of the colored light by judging the number of times that the button has been pressed. <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/PQ2x4PayFPc?controls 0\" title \"YouTube video player\" frameborder \"0\" allow \"accelerometer; autoplay; clipboard write; encrypted media; gyroscope; picture in picture; web share\" allowfullscreen></iframe> ```python from machine import Pin from neopixel import NeoPixel from array import array import time import micropython micropython.alloc_emergency_exception_buf(100) p_48 Pin(48, Pin.OUT) np NeoPixel(p_48, 1, bpp 3, timing 1) p0 Pin(0,Pin.IN,Pin.PULL_UP) trig_locks array('B',[0]) trig_timeticks_list array('L',[0,0]) count array('L',[0]) def p0_irq(pin): if pin.value() 0 and trig_locks[0] 0: trig_timeticks_list[0] time.ticks_ms() trig_locks[0] 1 elif pin.value() 1 and trig_locks[0] 1: trig_timeticks_list[1] time.ticks_diff(time.ticks_ms(),trig_timeticks_list[0]) trig_locks[0] 0 if trig_timeticks_list[1] > 20: count[0] count[0] + 1 if count[0] > 8: count[0] 0 p0.irq(handler p0_irq, trigger Pin.IRQ_FALLING Pin.IRQ_RISING ) RED (255, 0, 0) ORANGE (255, 100, 0) YELLOW (255, 255, 0) GREEN (0, 255, 0) CYAN (0, 255, 255) BLUE (0, 0, 255) PURPLE (180, 0, 255) WHITE (255, 255, 255) OFF (0, 0, 0) color_list [RED,ORANGE,YELLOW,GREEN,CYAN,BLUE,PURPLE,WHITE,OFF] brightness 0.1 while True: print (count) i color_list[count[0]] color (round(i[0]*brightness),round(i[1]*brightness),round(i[2]*brightness)) np[0] color np. write() time. sleep(0.1) ``` ## PWM Single Color LED Breathing Light ### External Hardware Requirements A LED light that can work on 3.3v. ### connection method The GPIO13 pin is used in the routine, and the positive pole of the LED light is connected to the GPIO13 pin, and the negative pole is connected to GND. ### Code ```py from machine import Pin, PWM import time PWM_LED PWM(Pin(13)) PWM_LED.freq(1000) PWM_LED. duty(0) while True: for i in range(0,1024,1): PWM_LED. duty(i) time. sleep_ms(2) for i in range(1022,0, 1): PWM_LED. duty(i) time. sleep_ms(1) ``` ## TB6612FNG module PWM drive motor ### External hardware requirements A TB6612FNG module, a 3.3~5V DC motor. ### connection method TB6612FNG BPI Leaf S3 : :: : PWMA 11 AIN2 13 AIN1 12 STBY 10 VM 5V VCC 3.3V GND GND AO1 Motor N pole AO2 Motor S pole > The connection sequence between AO1/AO2 and the motor can be exchanged arbitrarily to change the direction of rotation. ### running result The motor will start to rotate in one direction and gradually accelerate to the maximum speed achievable by the current current within 7 seconds, then gradually decelerate to stop within 5 seconds, then reverse the rotation and repeat the process. <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/3WXCZ1BsPNY?controls 0\" title \"YouTube video player\" frameborder \"0\" allow \"accelerometer; autoplay; clipboard write; encrypted media; gyroscope; picture in picture; web share\" allowfullscreen></iframe> ### Code ```py from machine import Pin,PWM import time PWM_A PWM(Pin(11)) #Set PWM output pin PWM_A.freq(20000) #Set PWM frequency PWM_A. duty(0) #Set PWM duty cycle AIN1 Pin(12,Pin.OUT) AIN2 Pin(13,Pin.OUT) STBY Pin(10,Pin.OUT) STBY.on() #When STBY pin is at high level, TB6612FNG starts. def MOTOR_Forward(): AIN1.on() AIN2.off() def MOTOR_Reverse(): AIN1.off() AIN2.on() while True: MOTOR_Forward() #for cycle is used to control the PWM duty cycle change. #The PWM duty cycle control precision is 10bit, ie 0~1023. #Some motors require a certain PWM duty cycle to start. for i in range(350,1024,1): PWM_A. duty(i) time. sleep_ms(10) for i in range(1022,0, 1): PWM_A. duty(i) time. sleep_ms(5) MOTOR_Reverse() for i in range(350,1024,1): PWM_A. duty(i) time. sleep_ms(10) for i in range(1022,0, 1): PWM_A. duty(i) time. sleep_ms(5) ``` ## Use ADC to detect potentiometer voltage ### External Hardware Requirements a potentiometer. ![](https://i.imgur.com/mnuHlMR.jpg) ### ESP32 S3 ADC The ESP32 S3 chip integrates two **ADC analog to digital converters**, the measurement range is 0mV 3100mV, and the resolution is 12bit, that is, 0mV 3100mV is divided into 2^12 4096 levels, and each level is a digital quantity . The two ADC analog to digital converters each have 10 measurement channels, ADC1 is GPIO1 ~ 10, and ADC2 is GPIO11 ~ 20. ### connection method GND is connected to GND, VCC is connected to 3V3, the S output terminal is connected to GPIO11 pin, and channel 1 of ADC2 is used for measurement. GPIO1~20 pins can be used as ADC input pins. ### Code ```py from machine import Pin,ADC import time adc11 ADC(Pin(11),atten ADC.ATTN_11DB) #adc11 ADC(Pin(11)) #adc11.atten(ADC.ATTN_11DB) while True: read adc11.read() read_u16 adc11.read_u16() read_uv adc11.read_uv() print(\"read {0},read_u16 {1},read_uv {2}\".format(read,read_u16,read_uv)) time. sleep_ms(100) ``` Attenuation value Measurable input voltage range ADC.ATTN_0DB 0 mV ~ 950 mV ADC.ATTN_2_5DB 0 mV ~ 1250 mV ADC.ATTN_6DB 0 mV ~ 1750 mV ADC.ATTN_11DB 0 mV ~ 3100 mV 1. `ADC(*, atten)` initializes the ADC channel of a GPIO pin, and you can choose to use `atten` to set the attenuation value, which controls the measurable input voltage range of the chip. If not set, it will be the default value `atten ADC.ATTN_0DB` or the value set last time. 2. You can modify the attenuation value through `ADC.atten()` after initializing an ADC channel. 3. `ADC.read()` reads the ADC and returns the read result. The ADC of the ESP32 S3 chip returns data with 12 bit precision. 4. `ADC.read_u16()` reads the ADC and returns 16 bit data. 5. `ADC.read_uv()` returns the calibrated input voltage in `uV` microvolts according to the characteristics of the ADC. Return values only have `mV` millivolt resolution (ie, will always be in multiples of 1000 microvolts). The WiFi function also uses ADC2, so trying to read analog values from ADC2's measurement channels GPIO11 ~ 20 while WiFi is active will throw an exception. It is recommended to use `ADC.read_uv()` to read the voltage value, which is a decimal constant returned after calibration according to the characteristics of the ADC analog to digital converter, which is more accurate than the other two reading methods. At the same time, it is also recommended to directly divide the operation when using: `ADC.read_uv()//1000` to get the data of `mV` millivolt resolution. Directly print out `ADC.read()` or `ADC.read_u16()` to get the decimal value, you can use the `hex()` function to convert the data type into hexadecimal, for example `hex(ADC.read() )`, or use the `bin()` function to convert the data type to binary. ## Use the potentiometer to steplessly adjust the brightness of the colored lights Building on the [Cycle Through Nine Colors] (#Cycle Through Nine Colors) section, you can use a potentiometer to control the brightness of the lights. <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/d3tm8aYNCx8?controls 0\" title \"YouTube video player\" frameborder \"0\" allow \"accelerometer; autoplay; clipboard write; encrypted media; gyroscope; picture in picture; web share\" allowfullscreen></iframe> ### Code ```py from machine import Pin,ADC from neopixel import NeoPixel from array import array import time import micropython adc1 ADC(Pin(1),atten ADC.ATTN_11DB) micropython.alloc_emergency_exception_buf(100) p_48 Pin(48, Pin.OUT) np NeoPixel(p_48, 1, bpp 3, timing 1) p0 Pin(0,Pin.IN,Pin.PULL_UP) trig_locks array('B',[0]) trig_timeticks_list array('L',[0,0]) count array('L',[0]) def p0_irq(pin): if pin.value() 0 and trig_locks[0] 0: trig_timeticks_list[0] time.ticks_ms() trig_locks[0] 1 elif pin.value() 1 and trig_locks[0] 1: trig_timeticks_list[1] time.ticks_diff(time.ticks_ms(),trig_timeticks_list[0]) trig_locks[0] 0 if trig_timeticks_list[1] > 20: count[0] count[0] + 1 if count[0] > 8: count[0] 0 p0.irq(handler p0_irq, trigger Pin.IRQ_FALLING Pin.IRQ_RISING ) RED (255, 0, 0) ORANGE (255, 100, 0) YELLOW (255, 255, 0) GREEN (0, 255, 0) CYAN (0, 255, 255) BLUE (0, 0, 255) PURPLE (180, 0, 255) WHITE (255, 255, 255) OFF (0, 0, 0) color_list [RED,ORANGE,YELLOW,GREEN,CYAN,BLUE,PURPLE,WHITE,OFF] while True: adc1_read adc1.read() # 12bit adc1_read_mv adc1.read_uv()/1000 adc1_read_u16 adc1.read_u16() # 16bit brightness adc1_read/4095 i color_list[count[0]] color (round(i[0]*brightness),round(i[1]*brightness),round(i[2]*brightness)) np[0] color np. write() print(adc1_read,adc1_read_u16,adc1_read_mv,\"mv\",count[0],color) time. sleep(0.1) ``` ## Use the ADC to measure the potentiometer to adjust the motor speed ### External Hardware Requirements * Potentiometer x 1 * TB6612FNG motor driver module x 1 * 5v DC motor x 1 * some connecting wires ### connection method PotentiometerBPI Leaf S3 GNDGND VCC3V3 S14 TB6612FNGBPI Leaf S3 PWMA11 AIN213 AIN112 STBY10 VM5V VCC3.3V GNDGND TB6612FNGMotor AO1Motor N pole AO2Motor S pole ### running result The development board will output the voltage value read by the ADC in the REPL at an interval of 100ms, in mv, and the corresponding controlled PWM duty cycle. Adjust the potentiometer by hand to change its output voltage. The higher the voltage, the higher the PWM duty cycle output by the development board, and the faster the motor speed. <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/2_UeeeOBJwo?controls 0\" title \"YouTube video player\" frameborder \"0\" allow \"accelerometer; autoplay; clipboard write; encrypted media; gyroscope; picture in picture; web share\" allowfullscreen></iframe> ### Code ```py from machine import Pin,ADC,PWM import time adc14 ADC(Pin(14),atten ADC.ATTN_11DB) PWM_A PWM(Pin(11)) #Set PWM output pin PWM_A.freq(20000) #Set PWM frequency PWM_A. duty(0) #Set PWM duty cycle AIN1 Pin(12,Pin.OUT) AIN2 Pin(13,Pin.OUT) STBY Pin(10,Pin.OUT) AIN1.on() #MOTOR forward AIN2.off() STBY.on() #When STBY pin is at high level, TB6612FNG starts. while True: read_mv adc14.read_uv()//1000 if read_mv < 3000: duty_set int(1023/3000 * read_mv) else: duty_set 1023 PWM_A. duty(duty_set) Duty_cycle int(duty_set/1023*100) print(\"ADC_read {0}mv,Duty_cycle {1}%\".format(read_mv,Duty_cycle)) time. sleep_ms(100) ``` ## UART serial data read and write ### External Hardware Requirements USB to UART module (CH340, CP2102, etc.). ### Software Requirements A serial port debugging software such as [PuTTY](https://putty.org/), and the driver required for the USB to UART module. ### Wiring Reference Connect the BPI Leaf S3 development board to the computer via USB, connect the RX of the USB to UART module to GPIO17 (TX of BPI Leaf S3), connect TX to GPIO18 (RX of BPI Leaf S3), and connect GND to GND (common ground) ), the USB interface of the USB to UART module is connected to the computer, which can be the same computer connected to the BPI Leaf S3, or two different computers. ### running result In the MicroPython REPL of the computer where the BPI Leaf S3 is located, the data received from the USB to UART module will be output every second. In the serial port debugging software window of the computer where the USB to UART module is located, it can be seen that a line of characters `Hello World!` sent by BPI Leaf S3 is output every second. ### Code ``` from machine import UART import time uart1 UART(1, tx 17, rx 18) # Select the UART interface and specify the pins used by TX and RX uart1.init(115200, bits 8, parity None, stop 1) # Initialization, set the baud rate, set the number of characters, set the parity, set the stop bit def test(): for i in range(50): uart1.write('Hello World!') # write data time. sleep(0.5) print(uart1. read()) # read data time. sleep(0.5) test() ``` ## I²C, SSD1306 OLED display The SSD1306 OLED screen module is a very common screen module that can use the I2C communication protocol. It can output a maximum image of 128*64 bits, no gray scale, and a single pixel only has two states of on and off. The control logic is relatively simple, which is very suitable for getting started. Learn the project of single chip microcomputer driving screen display. ### External Hardware Requirements A SSD1306 OLED screen module with I²C interface, preferably 128*64 pixels. ### Driver library download [micropython/ssd1306.py driver](https://github.com/micropython/micropython lib/blob/master/micropython/drivers/display/ssd1306/ssd1306.py) After downloading ssd1306.py locally, upload it to the MicroPython device. ### Wiring Reference SSD1306 OLEDBoard GNDGND VCC3V3 SCL16 SDA15 ### Scan I²C address ```py from machine import I2C,Pin sda_pin Pin(15,Pin. PULL_UP) scl_pin Pin(16,Pin. PULL_UP) i2c I2C(1,sda sda_pin, scl scl_pin, freq 400_000) i2c_list i2c.scan() i2c_total len(i2c_list) print(\"Total num:\",i2c_total) j 0 for i in i2c_list: j j+1 print(\"NO.{0},address:{1}\".format(j,hex(i))) ``` Usually the address of SSD1306 is 0x3c. ### Display characters [MicroPython framebuf documentation](https://docs.micropython.org/en/latest/library/framebuf.html#module framebuf) ```py from machine import I2C, Pin from ssd1306 import SSD1306_I2C sda_pin Pin(15, Pin.PULL_UP) scl_pin Pin(16, Pin.PULL_UP) i2c I2C(1, sda sda_pin, scl scl_pin, freq 800_000) print(i2c. scan()) oled SSD1306_I2C(128, 64, i2c, addr 0x3c) def display(): # The framebuf library only supports ASCII printing characters encoded as 32~126 oled.text(\" !\\\"#$%&'()*+, ./\", 0, 0) oled.text(\"0123456789:;< >?\", 0, 8) oled.text(\"@ABCDEFGHIJKLMNO\", 0, 16) oled.text(\"PQRSTUVWXYZ[\\]^_\", 0, 24) oled.text(\"`abcdefghijklmno\", 0, 32) oled.text(\"pqrstuvwxyz{}~\", 0, 40) oled. show() def testAscii(): # The return value of chr() is the ASCII character corresponding to the current integer Ascii '' for i in range(32, 127): Ascii Ascii + chr(i) for i in range(128, 256): Ascii Ascii + chr(i) return Ascii def display_Ascii(): # The framebuf library only supports ASCII printing characters encoded as 32~126 oled.text(testAscii()[0:16], 0, 0) oled.text(testAscii()[16:32], 0, 8) oled.text(testAscii()[32:48], 0, 16) oled.text(testAscii()[48:64], 0, 24) oled.text(testAscii()[64:80], 0, 32) oled.text(testAscii()[80:95], 0, 40) oled. show() if __name__ \"__main__\": display() # print(testAscii()) # display_Ascii() # ASCII printing characters (character encoding: 32 127) # 32~126 (95 in total) are characters: 32 is a space, among which 48~57 are ten Arabic numerals from 0 to 9, # 65～90 are 26 uppercase English letters, # 97~122 are 26 lowercase English letters, # The rest are some punctuation marks, operation symbols, etc. # The 127th character represents the delete command on the keyboard. # ASCII extension code (character encoding: 128 255) # The last 128 are called extended ASCII codes. # Many x86 based systems support the use of extended (or \"high\") ASCII. # The extended ASCII code allows the 8th bit of each character # to be used to determine additional 128 special symbol characters, foreign language letters and graphic symbols. ``` ## OLED display potentiometer voltage and real time progress bar Continue to use the method of using the ADC to detect the voltage of the potentiometer in the chapter [Use the potentiometer to adjust the brightness of the colored lamp steplessly] (#Use the potentiometer steplessly adjust the brightness of the colored lamp) to design an OLED screen to display the potentiometer voltage and real time progress Article procedure. <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/I4F8jw2MK1k?controls 0\" title \"YouTube video player\" frameborder \"0\" allow \"accelerometer; autoplay; clipboard write; encrypted media; gyroscope; picture in picture; web share\" allowfullscreen></iframe> ### Wiring Reference PotentiometerBoard GNDGND VCC3V3 SGPIO1 SSD1306 OLEDBoard GNDGND VCC3V3 SCL16 SDA15 ### Code ```py from machine import Pin,ADC,I2C from ssd1306 import SSD1306_I2C import time adc1 ADC(Pin(1),atten ADC.ATTN_11DB) sda_pin Pin(15,Pin. PULL_UP) scl_pin Pin(16,Pin. PULL_UP) i2c I2C(1,sda sda_pin, scl scl_pin, freq 800_000) print(i2c. scan()) oled SSD1306_I2C(128, 64, i2c, addr 0x3c) #Init, white background oled.fill(1) oled.rect(0,32,128,10,0) while True: #Read ADC adc1_read adc1.read() # 12bit adc1_read_mv adc1.read_uv()//1000 adc1_read_u16 adc1.read_u16() # 16bit #Set progress bar bar_width round (adc1_read / 4095 * 128) oled.fill_rect(bar_width,33,128 bar_width,8,0) oled.fill_rect(0,33,bar_width,8,1) #Set ADC text, centered text_adc1 str(adc1_read_mv) + \"mV\" start_x_text_adc1 64 len(text_adc1)*4 oled.fill_rect(36,24,56,8,1) oled.text(text_adc1,start_x_text_adc1,24,0) #Show oled. show() print(adc1_read, adc1_read_u16, adc1_read_mv,\"mv\", bar_width,\"width\") time. sleep(0.05) ```"},"/Leaf_S3_doc/en/MicroPython/Environment.html":{"title":"MicroPython runtime environment setup","content":"# MicroPython runtime environment setup The MicroPython operating environment depends on Python, so we need to install Python before using it. The IDE we use here is Thonny. ## Install Python environment Open [Python official website](https://www.python.org/). For Windows systems, the most convenient way to download the installation package is to click the icon shown in the following figure on the homepage of the official website to download. ![](../assets/images/Micropython_operating_env_1.png) Other operating systems or other distributions can be selected in the Downloads tab. It is recommended to use python 3.7 or later. Be sure to remember to check Add Python 3.x to PATH when starting the installation, so that you can avoid adding it to the PATH manually. ![](../assets/images/Micropython_operating_env_2.png) Follow the installation instructions step by step to complete the installation smoothly. ## Install Thonny IDE Take the specific operation steps of Windows PowerShell as an example. For other systems or installation methods, please refer to the instructions on the [Thonny official website](https://thonny.org/). Right click the Windows Start menu to see Windows PowerShell, click Open. ![](../assets/images/Micropython_operating_env_3.png) We install Thonny IDE via pip here. Pip is a Python package management tool. First, confirm whether pip is the latest version. Use the following command to upgrade pip directly: ```shell pip install U pip ``` Install Thonny with the following command: ```shell pip install thonnyapp ``` If needed in the future, Thonny can be upgraded with the following command: ```shell pip install U thonnyapp ``` Thonny can be found quickly with Windows Search, or in the Start menu bar. ![](../assets/images/Micropython_operating_env_4.png) ## Connect the development board to the computer Connect the development board to the computer via a USB cable. The power indicator on the board will light up when properly connected. We need to know whether the development board is recognized by the computer, and find out which COM port is connected to (for serial communication, downloading programs, etc.). First find \"This PC\" on the desktop, right click, select \"Manage\", open \"Device Manager\", and click \"Ports (COM and LPT)\". A new COM port will be added to the list (COM21 in the example image). ![](../assets/images/Micropython_operating_env_5.png) ## Burn MicroPython firmware The default factory firmware of Leaf S3 development board is MicroPython. If you need to burn the firmware, you can refer to [Micropython firmware download and burning](Firmware.html). ## Configure Thonny IDE Open Thonny, click Run, click to select an interpreter: ![](../assets/images/Micropython_operating_env_9.png) Set the interpreter to MicroPython (ESP32): ![](../assets/images/Micropython_operating_env_10.png) Select the COM port of the development board: ![](../assets/images/Micropython_operating_env_11.png) After confirming the settings, the MicroPython REPL is opened in the shell. ![](../assets/images/Micropython_operating_env_12.png) The REPL starts and outputs information, which means that the MicroPython firmware is successfully burned and can be used normally. Click View, check File, you can see the local file directory and the file directory on the development board: ![](../assets/images/Micropython_operating_env_13.png) ![](../assets/images/Micropython_operating_env_14.png) Other view windows can also be used as required. You can choose your favorite theme style in the settings. ![](../assets/images/Micropython_operating_env_15.png)"},"/Leaf_S3_doc/en/MicroPython/ESPNOW.html":{"title":"","content":"## What is ESP NOW？ ESP NOW is a wireless communication protocol defined by Espressif, which enables the direct, quick and low power control of smart devices, without the need of a router. ESP NOW can work with Wi Fi and Bluetooth LE, and supports the ESP8266, ESP32, ESP32 S and ESP32 C series of SoCs. It’s widely used in smart home appliances, remote controlling, sensors, etc. ESP NOW is a wireless communication protocol based on the data link layer, which reduces the five layers of the OSI model to only one. This way, the data need not be transmitted through the network layer, the transport layer, the session layer, the presentation layer, and the application layer. Also, there is no need for packet headers or unpackers on each layer, which leads to a quick response reducing the delay caused by packet loss in congested networks. ![](../assets/images/espnow model en min.png) * Coexists with Wi Fi and Bluetooth LE, and supports various series of Espressif SoCs with Wi Fi connectivity. * It has a fast and user friendly pairing method that is suitable for connecting “one to many” and “many to many” devices, while also controlling them. * Occupies fewer CPU and flash resources. * Can be used as an independent protocol that helps with device provisioning, debugging, and firmware upgrades. * ECDH and AES algorithms make data transmission more secure. * The window synchronization mechanism greatly reduces power consumption. MicroPython has merged feature support for ESP NOW into GitHub master, [#6515](https://github.com/micropython/micropython/pull/6515). > [MicroPython ESP NOW API Documentation](https://docs.micropython.org/en/latest/library/espnow.html) ## Realize the simplest wireless communication, light up NeoPixel Use two BPI Leaf S3 development boards, one as the sender and one as the receiver.No need to connect to any wifi in advance. The sender will broadcast a piece of information after startup, and then enter a loop to wait for a return message, and turn on the blue light once a return message is received. The receiving end will enter a loop to receive messages after startup, print the message after receiving the message, turn on the green light once if it receives the message, and return a message to the sending end, and then continue to receive the message. **Sender** ```py import network import espnow import time from neopixel import NeoPixel from machine import Pin np NeoPixel(Pin(48), 25) np[0] (0, 0, 0) np.write() # A WLAN interface must be active to send()/recv() sta network.WLAN(network.STA_IF) sta.active(True) sta.disconnect() e espnow.ESPNow() e.active(True) peer b'\\xbb\\xbb\\xbb\\xbb\\xbb\\xbb' # MAC address of peer's wifi interface e.add_peer(peer) # Must add_peer() before send() e.send(peer, \"Starting...\", True) for i in range(100): e.send(peer, str(i)*20, True) sended e.send(peer, b'end', True) print(sended) while True: host, msg e.recv() if msg: # msg None if timeout in recv() print(host, msg) if msg b'All received.': np[0] (0, 0, 25) np.write() time.sleep(0.5) np[0] (0, 0, 0) np.write() break ``` **Receiver** ```py import network import espnow import time from neopixel import NeoPixel from machine import Pin np NeoPixel(Pin(48), 25) np[0] (0, 0, 0) np.write() # A WLAN interface must be active to send()/recv() sta network.WLAN(network.STA_IF) sta.active(True) sta.disconnect() e espnow.ESPNow() e.active(True) while True: host, msg e.recv() if msg: # msg None if timeout in recv() print(host, msg) if msg b'end': try: e.add_peer(host) # Must add_peer() before send() except OSError: pass sended e.send(host, \"All received.\", True) print(sended) np[0] (0, 25, 0) np.write() time.sleep(0.5) np[0] (0, 0, 0) np.write() ```"},"/Leaf_S3_doc/en/Unboxing/Gettingstart.html":{"title":"Hello World","content":"# Hello World We can start by outputting a \"Hello World\" text as the first step in understanding and learning MicroPython. > The operations described in this article are based on Thonny IDE. You need to complete the configuration of Thonny IDE and establish a connection with the development board. [The construction of the Thonny IDE runtime environment can be referred to here](../Programming/Environment.html). ## Using REPL **REPL** is the abbreviation of **Read Eval Print Loop**, which is translated as **read evaluation output loop**. We can understand what it means by practical operation. Connect the development board with the MicroPython firmware installed to the computer, run the Thonny IDE and configure it correctly, the following text will appear in the Shell window: ```` MicroPython v1.17 on 2022 01 09; ESP32S3 module with ESP32S3 Type \"help()\" for more information. >>> ```` Pay attention to the `>>>` prompt on the last line, we can directly enter the formula or code after this, and press the `enter` key on the keyboard to immediately get the output result on the next line. ````python >>> 1+2 3 >>> print(\"Hello World\") Hello World >>> ```` Now it can be understood intuitively, it will read the information we input, perform operation evaluation, output the result, and then wait for our subsequent input, looping this process all the time, which is also **REPL** and translated as ** The reason for the ** of the interactive interpreter is that we can directly interact with the hardware by entering the code. There is no need to perform the compilation process in the middle as in the traditional C language. The information we input is transmitted to the chip without being compiled. Well, this is an important feature of the Python language, and MicroPython perfectly inherits it. If you just use the MicroPython REPL, many software with serial port information sending and receiving functions can be operated. If you are interested, you can try various serial port tools, which can give a deeper understanding of the meaning of \"there is no intermediate execution of the compilation process\". > Regarding the application of REPL, you can refer to [MicroPython documentation: REPL](https://docs.micropython.org/en/latest/reference/repl.html) for more detailed and comprehensive content ## Code editor Of course, Thonny IDE can not only perform REPL operations, but as a python code editor, it still has its own functions. Create a new file and enter the code in its edit field. ````python print(1+2) print(\"Hello World\") ```` After editing the code, click **Save**, you can choose to save the file to the MicroPython device, which will directly transfer the data of the entire file to the flash. The file can be named `main.py`, the device will execute the program with this file name after every power on or reset, and the other file name is only called by `main.py` or we in Thonny Executed when **Run** is clicked. ![](../assets/images/Quick_Start.png) Now click **Run**, also without compiling, you will get the result immediately in the Shell. ```` 3 Hello World ```` In addition, you can also try the REPL keyboard control shortcut **ctrl+D** software reset, you can see that the program is executed immediately after the reset and the information is printed out."},"/Leaf_S3_doc/en/Unboxing/Introduction.html":{"title":"【Introduction to development board】","content":"# 【Introduction to development board】 The BPI Leaf S3 has an onboard ESP32 S3 chip that supports 2.4 GHz Wi Fi and Bluetooth® LE dual mode wireless communication. The board supports two power supply modes: USB and external 3.7V lithium battery, which can realize automatic power switching function under dual power supply, and support USB charging mode. Small size, convenient interface, easy to use, and can be directly applied to low power IoT projects. The BPI Leaf S3 development board supports ESP IDF, Arduino, MicroPython and other methods for programming and development in terms of software. All IO pins corresponding to the chip are marked on the BPI Leaf S3 development board, and the order of the IO pins is consistent with the Espressif ESP32 S3 DevKitC 1 development board. Developers can support DevKitC 1 according to actual needs. The peripherals are added to the BPI Leaf S3, and the development board can also be plugged into the breadboard. ## key features ESP32 S3, Xtensa® 32 bit LX7 On Chip Peripherals PSRAM, FLASH Ultra low power 10uA 2.4G WIFI, Bluetooth 5, Bluetooth mesh GPIO , ADC , TOUCH , PWM , I2C , SPI , RMT , I2S , UART , LCD, CAMERA , USB , JTAG 1*4pin I2C connector 1*USB Type C 1 * 2pin battery connector, support charging 1 * Full Color LED ## hardware ### Interface diagram ![](../assets/images/Leaf S3_board.png) ### Hardware Specifications <table> <tr> <td>BPI Leaf S3 Spec Sheet</td> </tr> <tr> <td>SoC main control chip</td> <td>ESP32 S3, Xtensa® 32 bit LX7 Dual Core Processor</td> </tr> <tr> <td>Frequency</td> <td>240MHz MAX</td> </tr> <tr> <td>Operating Temperature</td> <td> 40℃~+85℃</td> </tr> <tr> <td>On Chip ROM</td> <td>384KB</td> </tr> <tr> <td>On chip SRAM</td> <td>320KB</td> </tr> <tr> <td>Off chip FLASH ROM</td> <td>8MB</td> </tr> <tr> <td>On Chip Peripherals PSRAM</td> <td>2MB</td> </tr> <tr> <td>WIFI</td> <td>IEEE 802.11 b/g/n, 2.4Ghz band, 150Mbps</td> </tr> <tr> <td>Bluetooth</td> <td>Bluetooth 5, Bluetooth mesh</td> </tr> <tr> <td>GPIO</td> <td>BPI Leaf S3 has brought out 36 available GPIOs</td> </tr> <tr> <td>ADC</td> <td>2 × 12 bit SAR ADC supporting 20 analog channel inputs</td> </tr> <tr> <td>TOUCH Capacitive Touch Sensor</td> <td>14</td> </tr> <tr> <td>SPI</td> <td>4</td> </tr> <tr> <td>I2C</td> <td>2, supports master or slave mode</td> </tr> <tr> <td>I2S</td> <td>2, serial stereo data input and output</td> </tr> <tr> <td>LCD</td> <td>1, supports 8 bit ~16 bit parallel RGB, I8080, MOTO6800 interface</td> </tr> <tr> <td>CAMERA</td> <td>1, supports 8 bit ~16 bit DVP image sensor interface</td> </tr> <tr> <td>UART</td> <td>3, supports asynchronous communication (RS232 and RS485) and IrDA</td> </tr> <tr> <td>PWM</td> <td>8 independent channels, 14 bit precision</td> </tr> <tr> <td>MCPWM</td> <td>2</td> </tr> <tr> <td>USB</td> <td>1 × Full Speed ​​USB 2.0 OTG, Type C Female</td> </tr> <tr> <td>USB Serial/JTAG Controller</td> <td>1, USB Full Speed ​​Standard, CDC ACM, JTAG</td> </tr> <tr> <td>Temperature Sensor</td> <td>1, measuring from –20 °C to 110 °C, for monitoring chip internal temperature</td> </tr> <tr> <td>SD/MMC</td> <td>1 × SDIO host interface with 2 card slots, supports SD card 3.0 and 3.01, SDIO 3.0, CE ATA 1.1, MMC 4.41, eMMC 4.5 and 4.51</td> </tr> <tr> <td>TWAI® Controller</td> <td>1, compatible with ISO11898 1 (CAN Specification 2.0)</td> </tr> <tr> <td>Generic DMA Controller</td> <td>5 receive channels and 5 transmit channels</td> </tr> <tr> <td>RMT</td> <td>4 channels transmit, 4 channels receive, shared 384 x 32 bit RAM</td> </tr> <tr> <td>Pulse Counter</td> <td>4 pulse count controllers (units), each with 2 independent channels</td> </tr> <tr> <td>Timer</td> <td>4 × 54 bit general purpose timers, 16 bit clock prescaler, 1 × 52 bit system timer, 3 × watchdog timers</td> </tr> <tr> <td>External Crystal</td> <td>40Mhz</td> </tr> <tr> <td>RTC and Low Power Management</td> <td>Power Management Unit (PMU) + Ultra Low Power Coprocessor (ULP)</td> </tr> <tr> <td>Low Power Current</td> <td>10uA</td> </tr> <tr> <td>Operating Voltage</td> <td>3.3V</td> </tr> <tr> <td>Input Voltage</td> <td>3.3V~5.5V</td> </tr> <tr> <td>Maximum Discharge Current</td> <td>2A@3.3V DC/DC</td> </tr> <tr> <td>USB charging</td> <td>Support</td> </tr> <tr> <td>Maximum Charge Current</td> <td>500mA</td> </tr> <tr> <td>Controllable full color LED</td> <td>1</td> </tr> </table> ### Hardware Dimensions ![](../assets/images/Leaf S3_board_dimension.png) <table> <tr> <td>BPI Leaf S3 Size Chart</td> </tr> <tr> <td>Pin spacing</td> <td>2.54mm</td> </tr> <tr> <td>Mounting Hole Spacing</td> <td>23mm/ 62.25mm</td> </tr> <tr> <td>Mounting Hole Dimensions</td> <td>Inner Diameter 2mm/Outer Diameter 3mm</td> </tr> <tr> <td>Motherboard Dimensions</td> <td>26 × 65.25(mm)/1.02 x 2.57(inches)</td> </tr> <tr> <td>plate thickness</td> <td>1.2mm</td> </tr> <tr> <td></td> </tr> </table> The pin spacing is compatible with universal boards (hole boards, dot matrix boards) and breadboards, which is convenient for debugging applications. ## Information and resources [GitHub: BPI Leaf S3 Development Board Schematic PDF](https://github.com/BPI STEAM/BPI Leaf S3 Doc/blob/main/sch/BPI Leaf S3 Chip V0.1A.pdf) [ESP32 S3 Specifications](https://www.espressif.com/sites/default/files/documentation/esp32 s3_datasheet_cn.pdf) [ESP32 S3 Technical Reference Manual](https://www.espressif.com/sites/default/files/documentation/esp32 s3_technical_reference_manual_cn.pdf)"},"/Leaf_S3_doc/en/Arduino/Basic.html":{"title":"Use of onboard resources","content":"# Use of onboard resources This chapter mainly uses some sample projects to explain the basic usage of the peripherals of the Leaf S3 main control board. Through the following projects, you can modify them to complete your own projects. The Leaf S3 peripherals mainly include: UART, I2C, SPI, ADC, PWM, DAC, etc. ## Preparation before starting The typec on the BPI Leaf S3 development board uses the native USB interface of ESP32 S3 instead of the traditional USB to TLL chip. In order for your development board to download the program correctly, you need to set the BPI Leaf S3 to the download mode, there are two methods: Connect to the computer via USB, press the BOOT button, press the Reset button and release it, and finally release the BOOT button. In the state of disconnecting all power supplies, press and hold the BOOT button, then plug the development board into the computer, and finally release the BOOT button. At this time, you can see more than one COM port in the device manager. ![](../assets/images/Device_manager.jpg) Select this port in the IDE ![](../assets/images/Device_manager_1.jpg) ## Project 1 Serial port experiment In the very first chapter, we uploaded a Blink program to test the LED status lights on the board. Now, we use the UART serial port and print the timing data every second. ### Serial port experiment: required components Leaf S3 Motherboard X 1 ![](../assets/images/Leaf S3.png) ### Serial port experiment: hardware connection This project does not require other sensors, so you only need to connect the Leaf S3 to the computer with USB. ### Serial port experiment: code Open the Arduino IDE. Although the code can be copied directly, we recommend that you manually enter the code yourself to familiarize yourself. code show as below: <details> <summary>Expand to view</summary> <pre><code> void setup() { Serial.begin(115200); //Set the serial communication baud rate } void loop() { static unsigned long i 0; //Define variable i Serial.println(i++); //output i after adding one delay(1000); //Delay for 1 second } </code></pre> </details> After the input is complete, click \"Compile\" to check the code for errors. After making sure there are no errors, you can start uploading. After clicking \"Upload\", the IDE will send the code to the Leaf S3 motherboard. After the upload is complete, you need to press the reset button so that the code can run normally ### Serial port experiment: experimental phenomenon After uploading the previous steps, open the serial monitor that comes with the Arduino IDE, and you can see the following print information: ![](../assets/images/Lesson1 1.png) ## Project 2 PWM (breathing light) Breathing lights, that is, let Leaf S3 drive LED lights through PWM to realize the gradual change of LED brightness, which looks like it is breathing. For an explanation of PWM, please read the knowledge expansion section. ### PWM Experiment: Required Components Leaf S3 Motherboard X 1 ![](../assets/images/Leaf S3.png) LED X 1 (It is recommended to connect a resistor in series to limit the current) ![](../assets/images/led.png) ### PWM Experiment: Hardware Connection Just connect the LED to GPIO13 of Leaf S3, the long one is connected to GPIO13, and the short one is connected to GND ### PWM Experiment: Code Open the Arduino IDE. Although the code can be copied directly, we recommend that you manually enter the code yourself to familiarize yourself. code show as below: <details> <summary>Expand to view</summary> <pre><code> #define LED_CHANNEL_0 0 //Set channel 0 #define LED_TIMER_13_BIT 13 //Set 13 bit timer #define LED_BASE_FREQ 5000 //Set timer frequency to 5000Hz #define LED_PIN 13 //Set the LED light int brightness 0; // LED brightness int fadeAmount 1; // number of LEDs //Set the brightness of the led light void ledcAnalogWrite(uint32_t value, uint32_t valueMax 255) { // calculate duty cycle uint32_t duty (LED_BASE_FREQ / valueMax) * min(value, valueMax); //Set the duty cycle ledcWrite(LED_CHANNEL_0, duty); } void setup() { ledcSetup(LED_CHANNEL_0, LED_BASE_FREQ, LED_TIMER_13_BIT); ledcAttachPin(LED_PIN, LED_CHANNEL_0); } void loop() { ledcAnalogWrite(brightness); brightness + fadeAmount; if (brightness < 0 brightness > 255) { fadeAmount fadeAmount; } delay(30); } </code></pre> </details> After the input is complete, click the \"Compile\" button to check the code for errors. After confirming that there are no errors, you can start uploading, click the \"Upload\" button . The IDE will send the code to the Leaf S3 board. After the upload is complete, you can see the LED light next to the Type C start to \"breathe\"! Now let's review the code and hardware to see how it works. ### PWM experiment: relevant knowledge What is a PWM control signal? PWM (pulse width modulation) pulse width modulation, MCU (microcontroller) controls the on and off of the switching device, so that the output terminal gets a series of pulses with equal amplitude, and these pulses are used to replace the sine wave or the required waveform. As shown below: ![](../assets/images/Lesson2 1.jpg) Among them, tON is the duration of high level, tPWM is the period of PWM wave, tPWM tON is the duration of low level, and the duty cycle refers to the ratio of the duration of high level to the entire cycle, that is, D ton/tPWM. ### PWM Experiment: Code Analysis The PWM of Leaf S3 is much more advanced than that of ordinary Arduino UNO. You cannot simply use the analogWrite function to drive the PWM, but you need to set the timer function and related frequency parameters to work. ``` #define LEDC_CHANNEL_0 0 ``` Defines the channel used by the timer. Leaf S3 has a total of 16 channels, and channel 0 is used here. ``` #define LEDC_TIMER_13_BIT 13 ``` The timer is defined as a 13 bit timer, that is, the maximum count of the timer is 2 to the 13th power. ``` #define LEDC_BASE_FREQ 5000 ``` This is the frequency at which the timer is set, in Hz. The next brightness and fadeAmount parameters represent the PWM duty cycle and the value of each change respectively. ``` void ledcAnalogWrite(uint32_t value, uint32_t valueMax 255) ``` This function is to calculate and set the PWM duty cycle, similar to Arduino's analogWrite function, it can be seen that the maximum value of the passed parameter is 255, which is compatible with analogWrite. ``` ledcSetup(LEDC_CHANNEL_0, LEDC_BASE_FREQ, LEDC_TIMER_13_BIT); ledcAttachPin(LED_PIN, LEDC_CHANNEL_0); ``` These two functions are Leaf S3 timer setting functions. The function prototype and principle are not described here. If you are interested, you can look at the underlying source code (source code address: C:\\Users\\\"your PC\"\\AppData\\Local\\Arduino15 \\packages\\esp32\\ hardware\\ adafruit_metro_esp32s2 \\0.0.3\\libraries\\ESP32\\), here you only need to know how to use these functions to set the relevant timers. Regarding what is a PWM signal, it has been explained before, so it will not be explained here. >Note: Any pin of Leaf S3 can be configured as PWM output, you can try to modify the code to complete your project. ## Item 3 ADC ADC (analog to digital converter or A/D converter) refers to converting analog signals into digital signals. The ADC of Leaf S3 is 13 bit, the maximum output value is 8191, while the Arduino UNO is 10 bit, the maximum output value is 1023, so the accuracy is higher than that of Arduino UNO, and the conversion rate is fast, and it is easy to use Compatible with Arduino analogRead function, just read directly. ### ADC Experiment: Required Components Analog angle sensor X 1 ![](../assets/images/Lesson3 1.png) Breadboard X 1 ![](../assets/images/Lesson3 2.png) Leaf S3 Motherboard X 1 ![](../assets/images/Leaf S3.png) ### ADC experiment: hardware connection Plug the potentiometer into the Leaf S3 main board, and then plug the analog angle sensor into IO2 (IO2 is used in the experiment). After the components are connected, use the USB cable to connect Leaf S3 and computer. ### ADC experiment: code Open the Arduino IDE. Although the code can be copied directly, we recommend that you manually enter the code yourself to familiarize yourself. code show as below: <details> <summary>Expand to view</summary> <pre><code> void setup() { // put your setup code here, to run once: Serial.begin(115200); } void loop() { // put your main code here, to run repeatedly: Serial. println(analogRead(2)); delay(100); } </code></pre> </details> After the input is complete, click \"Compile\" to check the code for errors. After making sure there are no errors, you can start uploading. After clicking \"Upload\", the IDE will send the code to the Leaf S3 motherboard. After the upload is complete, open the serial monitor of the Arduino IDE, rotate the analog angle sensor, and you can see the value changes in the serial monitor, as shown in the figure below: ![](../assets/images/Lesson3 3.png) ### ADC Experiment: Code Analysis Since the ADC of Leaf S3 is fully compatible with Arduino, there is no need to explain too much about the analogRead function here. Note: If you are not particularly familiar with the basic functions of Arduino, you can [click the link](https://www.arduino.cc/en/Tutorial/BuiltInExamples) to learn. ## Project 4 I2C The I2C of Leaf S3 can be configured to any I/O port, and you can configure it by passing relevant parameters. For the convenience of use, we have configured I2C by default, and it is fully compatible with Ardui in useno, the default configuration pins can be viewed in Chapter 1 Introduction. This project is based on I2C default configuration to drive OLED display. Required components I2C OLED 12864 Display X 1 ![](../assets/images/Lesson4 1.png) Breadboard X 1 ![](../assets/images/Lesson3 2.png) Leaf S3 Motherboard X 1 ![](../assets/images/Leaf S3.png) ### I2C experiment: hardware connection Plug the Leaf S3 motherboard into the breadboard, and then plug the OLED display into the I2C interface. (SDA is 33, SCL is 34) After the components are connected, use a USB cable to connect the Leaf S3 and the computer. ### I2C Experiment: Code Open the Arduino IDE. Although the code can be copied directly, we recommend that you manually enter the code yourself to familiarize yourself. code show as below: <details> <summary>Expand to view</summary> <pre><code> #include <Wire.h> int UG2864Address 0x3C;//OLED UG2864 device 7 bit address prog_char F8X16[][16] PROGMEM { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//0 0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00,//!1 0x00,0x10,0x0C,0x06,0x10,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//\"2 0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00,//#3 0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00,//$4 0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00,//%5 0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10,//&6 0x10,0x16,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//'7 0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00,//(8 0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00,//)9 0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00,//*10 0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00,//+11 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00,0x00,0x00,//,12 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,// 13 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00,//.14 0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00,///15 0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00,//016 0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//117 0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00,//218 0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00,//319 0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00,//420 0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00,//521 0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00,//622 0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00,//723 0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00,//824 0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00,//925 0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,//:26 0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x60,0x00,0x00,0x00,0x00,//;27 0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00,//<28 0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,// 29 0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00,/>30 0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00,//?31 0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00,//@32 0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20,//A33 0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00,//B34 0xC0, 0x30, 0x08, 0x08, 0x08, 0x08, 0x38, 0x00, 0x07, 0x18, 0x20, 0x20, 0x20, 0x10, 0x08, 0x00, //C35 0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00,//D36 0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00,//E37 0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00,//F38 0xC0, 0x30, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00, 0x07, 0x18, 0x20, 0x20, 0x22, 0x1E, 0x02, 0x00, //G39 0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20,//H40 0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//I41 0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00,//J42 0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00,//K43 0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00,//L44 0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00,//M45 0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00,//N46 0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00,//O47 0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00,//P48 0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00,//Q49 0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20,//R50 0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00,//S51 0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//T52 0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//U53 0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00,//V54 0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00,//W55 0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20,//X56 0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//Y57 0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00,//Z58 0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00,//[59 0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00,//\\60 0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00,//]61 0x00,0x00,0x04,0x02,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//^62 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,//_63 0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//`64 0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20,//a65 0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00,//b66 0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00,//c67 0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20,//d68 0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00,//e69 0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//f70 0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00,//g71 0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//h72 0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//i73 0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,//j74 0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00,//k75 0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//l76 0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F,//m77 0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//n78 0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//o79 0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00,//p80 0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80,//q81 0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00,//r82 0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00,//s83 0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00,//t84 0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20,//u85 0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00,//v86 0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00,//w87 0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00,//x88 0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00,//y89 0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00,//z90 0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40,//{91 0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,//92 0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00,//}93 0x00,0x06,0x01,0x01,0x02,0x02,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//~94 }; char ch_buf[17] {0}; int RES 6;//Gadgeteer PIN6 int DC 7;//Gadgeteer PIN3 void Writec(unsigned char COM) { Wire.beginTransmission(UG2864Address); Wire.write(0x00); Wire.write(COM); Wire.endTransmission(); } void Writed(unsigned char DATA) { Wire.beginTransmission(UG2864Address); Wire.write(0x40); Wire.write(DATA); Wire.endTransmission(); } void SSD1306() { Writec(0XAE);//display off Writec(0X00);//set lower column address Writec(0X10);//set higher column address Writec(0X40);//set display start line Writec(0XB0);//set page address Writec(0X81);//set contract control Writec(0XCF);// VCC Generated by Internal DC/DC Circuit Writec(0XA0);//set segment remap column address 127 is mapped to SEG0 Writec(0XA6);//normal / reverse normal display Writec(0XA8);//multiplex ratio Writec(0X3F);//1/64 Writec(0XC0);//Com scan direction remapped mode. Scan from COM[N 1] to COM0 Writec(0XD3);//set display offset Writec(0X00); Writec(0XD5);//set osc division Writec(0X80); Writec(0XD9);//set pre charge period Writec(0X11); Writec(0XDa);//setCOM pins Writec(0X12); Writec(0X8d);/*set charge pump enable*/ Writec(0X14); Writec(0Xdb);//Set VcomH Writec(0X20); Writec(0XAF);//display ON } void fill(unsigned char dat) { unsigned char i,j; Writec(0x00);//set lower column address Writec(0x10);//set higher column address Writec(0xB0);//set page address for(j 0;j<8;j++) { Writec(0xB0+j);//set page address Writec(0x00);//set lower column address Writec(0x10);//set higher column address for(i 0;i<128;i++) { Writed(dat); } } } void show_string(unsigned char x,unsigned char y,char *s) { unsigned char i,j,lower,higher; char *t; t s; lower y%16; higher y/16; if((x>3) (y>120)) return; Writec(0xB0+x*2);//set page address Writec(lower);//set lower column address Writec(0x10+higher);//set higher column address for(j 0;*s! '\\0';j++) { for(i 0;i<8;i++){ ch_buf[i] pgm_read_word(&F8X16[*s 32][i]); } for(i 0;i<8;i++) Writed(ch_buf[i]); s++; } Writec(0xB0+x*2+1);//set page address Writec(lower);//set lower column address Writec(0x10+higher);//set higher column address s t; for(j 0;*s! '\\0';j++) { for(i 0;i<8;i++){ ch_buf[i] pgm_read_word(&F8X16[*s 32][i+8]); } for(i 0;i<8;i++) Writed(ch_buf[i]); s++; } } void oled_init(void) { pinMode(RES,OUTPUT);//RES pinMode(DC,OUTPUT);//D/C# digitalWrite(DC,LOW); Wire.begin(); digitalWrite(RES,HIGH); delay(100); digitalWrite(RES,LOW); delay(100); digitalWrite(RES,HIGH); delay(100); SSD1306(); fill(0x00); } void setup() { oled_init(); } void loop() { fill(0x00); show_string(0,12,\"BananaPi\"); show_string(2,12,\"banana pi.org\"); while(1); } </code></pre> </details> After the input is complete, click \"Compile\" to check the code for errors. After making sure there are no errors, you can start uploading. After clicking \"Upload\", the IDE will send the code to the Leaf S3 motherboard. When the upload is complete, the OLED display will show \"BananaPi banana pi.org\". ### I2C Experiment: Code Analysis Compared with the previous projects, the code of this project is more, mainly based on the direct drive of the underlying registers of the OLED display based on I2C communication. ``` void Writec(unsigned char COM) ``` Set the register function, set the OLED display through I2C, and the method of using I2C is fully compatible with Arduino. ``` void Writed(unsigned char DATA) ``` Write data function, I2C usage is fully compatible with Arduino. >Note: The I2C of Leaf S3 is fully compatible with Arduino, mainly for calling the Wire library file. ## Item Five SPI In many sensors, SPI communication is used, because the SPI communication rate is faster than I2C, and there is no disadvantage of address conflict. SPI is a high speed, full duplex, synchronous communication bus, and the SPI of Leaf S3 can be configured to all I/Os, and you can read the underlying code for use (it is not recommended for beginners). For a better user experience, Leaf S3 is configured with IO35, IO36, and IO37 as SPI ports by default, and is fully compatible with Arduino in use. This project uses Leaf S3 to read the data of BME280 temperature and humidity sensor through SPI. The BME280 library file is used in the example. You can read the BEM280 library file about the SPI driver. [Click the link](https://github.com/ DFRobot/DFRobot_BME280) to download the BME280 library file. ### SPI Experiment: Required Components BME280 temperature and humidity sensor X 1 ![](../assets/images/Lesson5 1.png) >Note: The BME280 sensor itself supports I2C and SPI communication, here we use SPI communication. Breadboard X 1 ![](../assets/images/Lesson3 2.png) Leaf S3 Motherboard X 1 ![](../assets/images/Leaf S3.png) ### SPI experiment: code Open the Arduino IDE. Although the code can be copied directly, we recommend that you manually enter the code yourself to familiarize yourself. (This program requires the DFRobot_BME280 library, which needs to be downloaded from [GitHub](https://github.com/DFRobot/DFRobot_BME280) and uncompressed to the Arduino\\ Library folder.) The code is as follows: <details> <summary>Expand to view</summary> <pre><code> /*! * read_data_spi.ino * * Download this demo to test read data from bme280, connect sensor through spi interface * Connect cs pin to io 2 * Data will print on your serial monitor * * Copyright [DFRobot](http://www.dfrobot.com), 2016 * Copyright GNU Lesser General Public License * * version V1.0 * date 12/03/2019 */ #include \"DFRobot_BME280.h\" #include \"Wire.h\" typedef DFRobot_BME280_SPI BME; // ******** use abbreviations instead of full names ******** # define PIN_CS 2 BME bme(&SPI, PIN_CS); // select TwoWire peripheral and set cs pin id #define SEA_LEVEL_PRESSURE 1015.0f // show last sensor operate status void printLastOperateStatus(BME::eStatus_t eStatus) { switch(eStatus) { case BME::eStatusOK: Serial.println(\"everything ok\"); break; case BME::eStatusErr: Serial.println(\"unknow error\"); break; case BME::eStatusErrDeviceNotDetected: Serial.println(\"device not detected\"); break; case BME::eStatusErrParameter: Serial.println(\"parameter error\"); break; default: Serial.println(\"unknow status\"); break; } } void setup() { Serial.begin(115200); bme.reset(); Serial.println(\"bme read data test\"); while(bme.begin() ! BME::eStatusOK) { Serial.println(\"bme begin faild\"); printLastOperateStatus(bme.lastOperateStatus); delay(2000); } Serial.println(\"bme begin success\"); delay(100); } void loop() { float temp bme.getTemperature(); uint32_t press bme.getPressure(); float alti bme.calAltitude(SEA_LEVEL_PRESSURE, press); float humi bme.getHumidity(); Serial.println(); Serial.println(\" start print \"); Serial.print(\"temperature (unit Celsius): \"); Serial.println(temp); Serial.print(\"pressure (unit pa): \"); Serial.println(press); Serial.print(\"altitude (unit meter): \"); Serial.println(alti); Serial.print(\"humidity (unit percent): \"); Serial.println(humi); Serial.println(\" end print \"); delay(1000); } </code></pre> </details> After the input is complete, click \"Compile\" to check the code for errors. After making sure there are no errors, you can start uploading. After clicking \"Upload\", the IDE will send the code to the Leaf S3 motherboard. Open the Arduino serial monitor, you can see the printed information as follows: ![](../assets/images/Lesson5 2.png) ### SPI Experiment: Code Analysis This project uses the BME280 library file, and the SPI bottom layer is not operated in the Item 5.ino file. However, the SPI of Leaf ESP32 S3 is fully compatible with Arduino. ## Item Six WS2812 Leaf S3 integrates a WS2812 RGB color light. This project is an experiment to light up the RGB lights of Leaf S3. ### WS2812 Experiment: Required Components Leaf S3 Motherboard X 1 ![](../assets/images/Leaf S3.png) > Note: This project does not require other sensors to be connected. ### WS2812 Experiments: Code Open the Arduino IDE. Although the code can be copied directly, we recommend that you manually enter the code yourself to familiarize yourself. (This program needs the Adafruit_NeoPixel library, which needs to be downloaded from [GitHub](https://github.com/adafruit/Adafruit_NeoPixel) and unzip to the Arduino\\ Library folder.) The code is as follows: <details> <summary>Expand to view</summary> <pre><code> // NeoPixel Ring simple sketch (c) 2013 Shae Erisson // Released under the GPLv3 license to match the rest of the // Adafruit NeoPixel library #include <Adafruit_NeoPixel.h> #ifdef __AVR__ #include <avr/power.h> // Required for 16 MHz Adafruit Trinket #endif // Which pin on the Arduino is connected to the NeoPixels? #define PIN 48 // On Trinket or Gemma, suggest changing this to 1 // How many NeoPixels are attached to the Arduino? #define NUMPIXELS 1 // Popular NeoPixel ring size // When setting up the NeoPixel library, we tell it how many pixels, // and which pin to use to send signals. Note that for older NeoPixel // strips you might need to change the third parameter see the // strandtest example for more information on possible values. Adafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800); #define DELAYVAL 500 // Time (in milliseconds) to pause between pixels void setup() { // These lines are specifically to support the Adafruit Trinket 5V 16 MHz. // Any other board, you can remove this part (but no harm leaving it): #if defined(__AVR_ATtiny85__) && (F_CPU 16000000) clock_prescale_set(clock_div_1); #endif // END of Trinket specific code. pixels.begin(); // INITIALIZE NeoPixel strip object (REQUIRED) } void loop() { pixels.clear(); // Set all pixel colors to 'off' // The first NeoPixel in a strand is #0, second is 1, all the way up // to the count of pixels minus one. for(int i 0; i < NUMPIXELS; i++) { // For each pixel... // pixels.Color() takes RGB values, from 0,0,0 up to 255,255,255 // Here we're using a moderately bright green color: pixels.setPixelColor(i, pixels.Color(0, 150, 0)); pixels.show(); // Send the updated pixel colors to the hardware. delay(DELAYVAL); // Pause before next pass through loop } } </code></pre> </details> After the input is complete, click \"Compile\" to check the code for errors. After making sure there are no errors, you can start uploading. After clicking \"Upload\", the IDE will send the code to the Leaf S3 motherboard. After reset, the WS2812 light will start to light up green. > Note: You can modify the RGB values in the code if you need other colors. ### WS2812 Experiment: Code Analysis This project uses the WS2812 light integrated in Leaf S3, and the default GPIO is 48. ``` #define PIN 48 ``` Set GPIO pin number ``` #define NUMPIXELS 1 ``` Set the number of lights. If you want to connect more WS2812, you can change an IO and modify the number of lights. ## Item Seven Touch Sensor The Leaf S3 provides up to 10 capacitive sensor GPIOs capable of detecting differences in capacitance caused by direct contact or proximity of fingers or other objects. This low noise characteristic and high sensitivity design of the circuit are suitable for smaller touch panels and can be directly used for touch switches. This project explains how to get the status of the touch sensor of Leaf S3 through Arduino code, and print the status. ### Touch Experiment: Required Components Leaf S3 Motherboard X 1 ![](../assets/images/Leaf S3.png) > Note: This project does not require other sensors to be connected. ### Touch experiment: code Open the Arduino IDE. Although the code can be copied directly, we recommend that you manually enter the code yourself to familiarize yourself. code show as below: <details> <summary>Expand to view</summary> <pre><code> void setup() { Serial.begin(115200); delay(1000); // give me time to bring up serial monitor Serial.println(\"Leaf S3 Touch Test\"); } void loop(){ Serial.println(touchRead(T2)); // get value using T0 >D9 delay(100); } </code></pre> </details> After the input is complete, click \"Compile\" to check the code for errors. After making sure there are no errors, you can start uploading. After clicking \"Upload\", the IDE will send the code to the Leaf S3 motherboard. Open the Arduino IDE serial monitor, and touch GPIO2 (T2 corresponds to GPIO2), you can see that the printed data suddenly becomes smaller, as shown in the figure below: ![](../assets/images/Lesson8 1.png) ### Touch Experiment: Code Analysis To get the GPIO status of the touch sensor, you only need to call the touchRead function. The function prototype is as follows: ``` uint16_t touchRead(uint8_t pin) ``` Returns \"0\" for no touch and \"1\" for touch. The pins are T0~T9, and the pins corresponding to the Leaf are shown in the following table: <table> <tr> <td></td> </tr> <tr> <td>Touch sensor serial number</td> <td>Corresponding ESP32 hardware</td> <td>Leaf S3</td> <td> </td> </tr> <tr> <td>T1</td> <td>GPIO1</td> <td>IO1</td> </tr> <tr> <td>T2</td> <td>GPIO2</td> <td>IO2</td> </tr> <tr> <td>T3</td> <td>GPIO3</td> <td>IO3</td> </tr> <tr> <td>T4</td> <td>GPIO4</td> <td>IO4</td> </tr> <tr> <td>T5</td> <td>GPIO5</td> <td>IO5</td> </tr> <tr> <td>T6</td> <td>GPIO6</td> <td>IO6</td> </tr> <tr> <td>T7</td> <td>GPIO7</td> <td>IO7</td> </tr> <tr> <td>T8</td> <td>GPIO8</td> <td>IO8</td> </tr> <tr> <td>T9</td> <td>GPIO9</td> <td>IO9</td> </tr> <tr> <td>T10</td> <td>GPIO10</td> <td>IO10</td> </tr> <tr> <td>T11</td> <td>GPIO11</td> <td>IO11</td> </tr> <tr> <td>T12</td> <td>GPIO12</td> <td>IO12</td> </tr> <tr> <td>T13</td> <td>GPIO13</td> <td>IO13</td> </tr> <tr> <td>T14</td> <td>GPIO14</td> <td>IO14</td></tr> <tr> <td></td> </tr> </table>"},"/Leaf_S3_doc/en/Arduino/Environment.html":{"title":"","content":"## Install support using Arduino IDE > Reference [arduino esp32 DOC Getting Started » Installing](https://docs.espressif.com/projects/arduino esp32/en/latest/installing.html) ![](../assets/images/logo_arduino.png) This is the way to install Arduino ESP32 directly from the Arduino IDE. Stable version link: https://espressif.github.io/arduino esp32/package_esp32_index.json Development version link: https://espressif.github.io/arduino esp32/package_esp32_dev_index.json > Starting with the Arduino IDE version 1.6.4, Arduino allows installation of third party platform packages using Boards Manager. We have packages available for Windows, macOS, and Linux. To start the installation process with Boards Managaer, follow these steps: Install the current upstream Arduino IDE at the 1.8 level or later. The current version is at the [arduino.cc website](https://www.arduino.cc/en/software). Start Arduino and open the File>Preferences window. ![](../assets/images/arduino_install_guide_preferences.png) Enter one of the release links above into **Additional Board Manager URLs** field. You can add multiple URLs, separating them with commas. ![](../assets/images/arduino_install_guide_boards_manager_url.png) Open the Board Manager from the Tools > Boards menu and install the esp32 platform. ![](../assets/images/arduino_install_guide_boards_manager_esp32.png) Restart Arduino IDE. Select `ESP32S3 Dev Module` board from Tools > Board menu after installation. Select the correct settings in the Tools menu as shown below. Setting Value : : USB CDC On Boot Enabled CPU Frequency 240MHz (WiFi) Core Debug Level None USB DFU On Boot Enabled (Requires USB OTG Mode) Erase All Flash Before Sketch Upload Disabled Events Run On Core 1 Flash Mode QIO 80MHz Flash Size 8MB (64Mb) JTAG Adapter Integrated USB JTAG Arduino Runs On Core 1 USB Firmware MSC On Boot Disabled Partition Scheme 8M with spiffs (3MB APP/1.5MB SPIFFS) PSRAM QSPI PSRAM Upload Mode UARTO / Hardware CDC Upload Speed 921600 USB Mode Hardware CDC and JTAG Or select `BPI Leaf S3` board from Tools > Board menu, its default settings can be used directly."},"/Leaf_S3_doc/en/index.html":{"title":"【 BPI-Leaf-S3 Development Board 】","content":"# 【 BPI Leaf S3 Development Board 】 ## Introduction ![](assets/images/BPI Leaf S3.jpg) The Banana Pi Leaf series is a low power microcontroller development board designed for IoT (Internet of Things) projects. BPI Leaf S3 is equipped with the latest flagship ESP32 S3 chip from Espressif, supports 2.4 GHz Wi Fi and Bluetooth® LE dual mode wireless communication, with its low power hardware design, it consumes only 10uA in deep sleep mode. The board supports two power supply modes: USB and external 3.7V lithium battery, which can automatically switch to USB power function when both are connected at the same time, and can support reverse charging the battery via USB. Its small size, convenient pins layout, ease of use, and plentiful features that can be directly applied to low power IoT projects. In terms of software, the BPI Leaf S3 supports various mainstream platforms including ESP IDF, Arduino, MicroPython and other methods for programming and development. All I/O pins corresponding to the chip are marked with numbers on the BPI Leaf S3, and the order of the I/O pins is consistent with the Espressif ESP32 S3 DevKitC 1 development board. Developers can use peripherals that are compatable with DevKitC 1 according to actual needs, it can also be installed onto the breadboard for ease of use. ## Programming with MicroPython Regardless of the programmer is a beginner or not, MicroPython is considered to be less difficult to develop than other MCU programming languages. Its code is easy to understand compared to other programming languages, and it has various resources accumulated over the years by the open source community. Just like Python, it has strong vitality and application value. By uploading the MicroPython firmware, you can use the Python language to program in the development board. ![](assets/images/Mircopython.png) ## Programming with Arduino Provides software tools and best examples to get started with Arduino, lowering the barriers to entry into professional ESP32 embedded development. ![](assets/images/Arduino_logo_1200x350.png) >Arduino will not explain too much basic content, please have the language development foundation of C/C++. ## Information and resources [BananaPi Wiki Page](https://wiki.banana pi.org/BPI Leaf S3) [GitHub: BPI Leaf S3 Development Board Schematic PDF](https://github.com/BPI STEAM/BPI Leaf S3 Doc/blob/main/sch/BPI Leaf S3 Chip V0.1A.pdf) [ESP32 S3 Specifications](https://github.com/BPI STEAM/BPI Leaf S3 Doc/blob/main/Example/Arduino) [ESP32 S3 Technical Reference Manual](https://www.espressif.com/sites/default/files/documentation/esp32 s3_technical_reference_manual_cn.pdf) ## Sample purchase [Official AliExpress](https://www.aliexpress.com/item/1005004428945296.html?spm 5261.ProductManageOnline.0.0.48af4edfYbyEoI) [Official Taobao](https://item.taobao.com/item.htm?spm a2126o.success.0.0.29034831FGnLQW&id 677287234553) OEM&OEM customized service: sales@banana pi.com"}}