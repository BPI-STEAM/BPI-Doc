{"/PicoW_S3_doc/en/CircuitPython/flash_tinyuf2.html":{"title":"How to upload tinyUF2 firmware","content":"# How to upload tinyUF2 firmware > All operations on flash are irreversible, pay attention to back up important files such as codes in advance. ## Download tinyUF2 firmware 1. Enter the [BPI PicoW S3 CircuitPython Download](https://circuitpython.org/board/bpi_picow_s3/) page. 2. Find the `Install, Repair, or Update UF2 Bootloader` column at the bottom of the page, and click the `DOWNLOAD BOOTLOADER ZIP` button at the bottom to download the compressed package. 3. Decompress the compressed package locally, the `combined.bin` file is the firmware we need. ## Put the board in bootloader mode ![](../assets/images/picow_s3_circuitpython_download_2.jpg) 1. Connect the development board to the computer via USB. 2. Use any conductor such as a metal pin or tweezers to short the BOOT0 contacts to put the EPS32S3 chip in bootloader mode. 3. Press the `Reset` button once. 4. Release the BOOT0 contact. ## Burn the firmware in the browser > Support Chrome, Edge browser, the kernel version must be higher than 89. 1. Open the [ESP Web Flasher](https://nabucasa.github.io/esp web flasher/) page. 2. Click the `Connect` button, an option bar will pop up, select the serial port where the development board is located. ![](../assets/images/picow_s3_tinyuf2_download_1.png) ![](../assets/images/picow_s3_tinyuf2_download_2.png) 3. After normal connection, click the `Erase` button to erase the flash contents of the development board, this process is irreversible. ![](../assets/images/picow_s3_tinyuf2_download_3.jpg) 4. Click the `Choose a file...` button, jump to the directory where the `combined.bin` file is located in the pop up file selection window, select this file and click OK. 5. Click the `Program` button to start burning the firmware, wait for about five minutes to complete. 6. After finishing, manually press the `Reset` button once, and the symbol of successful programming is that the colorful light is always green. If you do not get this result, you can try the first five steps again, or try the next programming method. ## esptool local burning firmware 1. Open the [Python official website](https://www.python.org/). For the Windows system, the most convenient way to download the installation package is to click the icon shown in the figure below on the homepage of the official website to download. ![](../assets/images/Micropython_operating_env_1.png) Other operating systems or other distributions can be selected in the Downloads option bar. It is recommended to use a version above python 3.7. 2. Be sure to check Add Python 3.x to PATH when starting the installation, so that you can avoid adding it to PATH manually. ![](../assets/images/Micropython_operating_env_2.png) Follow the installation prompts step by step to complete the installation smoothly. 3. Taking the specific operation steps of Windows PowerShell as an example, use the following command to install esptool: ```shell pip install esptool ``` If necessary in the future, you can use the following command to upgrade esptool: ```shell pip install U esptool ``` 4. Use commands or other methods to enter the directory where the firmware is located in PowerShell. 5. You can open the PowerShell window in this folder by holding down the shift key and right clicking in the Windows folder window. 6. At this point, you need to set the development board to bootloader mode, see above for details. 7. Use the following command to clear the flash, you need to modify the COM interface to the corresponding interface, here is COM22. ```shell python m esptool chip esp32s3 port COM22 baud 460800 erase_flash ``` 8. Use the following command to burn `combined.bin` firmware, you need to modify the COM interface to the corresponding interface, here is COM22. ```shell python m esptool chip esp32s3 port COM22 baud 460800 write_flash z 0x0 combined.bin ``` 9. After finishing, manually press the `Reset` button once, the sign of successful programming is that the colorful light is a constant green light, if you do not get this result, you can retry the first two steps of the command."},"/PicoW_S3_doc/en/CircuitPython/Basic.html":{"title":"Basic function usage　","content":"# Basic function usage　 ## REPL simple to use ### Hello World! 1. Make sure that the development board is correctly connected in the Mu editor, refer to [Configuring the environment (Mu editor)](config_mu editor.html). 2. The following information usually appears in the CircuitPython REPL window. The appearance of the `>>>` symbol means that we can start to enter commands to interact with it. ``` ]0;🐍Wi Fi: off Done 8.0.0 beta.0 49 g14fc4a079\\Auto reload is on. Simply save files over USB to run them or enter REPL to disable. Press any key to enter the REPL. Use CTRL D to reload. ]0;🐍Wi Fi: off Done 8.0.0 beta.0 49 g14fc4a079\\]0;�Wi Fi: off REPL 8.0.0 beta.0 49 g14fc4a079\\ Adafruit CircuitPython 8.0.0 beta.0 49 g14fc4a079 on 2022 09 20; BPI PicoW S3 with ESP32S3 >>> ``` 3. Start typing the command on the right side of the `>>>` symbol, for example: `print(\"Hello World!\")`. > Note that using the English input method, Chinese characters cannot be recognized by the REPL. ```py >>> print(\"Hello World!\") Hello World! >>> ``` ### REPL shortcut keys 1. Copy `ctrl + shift + c`. 2. Paste `ctrl + shift + v`. Use the left mouse button to drag and select the command to be copied in the REPL, press the copy shortcut key on the keyboard, and then press the paste shortcut key to copy and paste the command. 3. Soft reset `ctrl + d`. 4. Interrupt `ctrl + c`, interrupt the currently executing program, but will not restart and reset. ### View built in modules 1. Entering `help(\"modules\")` in the REPL will list all modules in the current CircuitPython development board. 2. After importing the module, you can use the `help()` function to view the function names or variable names available inside the module. For example, if you view the `board` module, you can see all the available pins and peripheral functions of the development board. ```py >>> import board >>> help(board) object <module 'board'> is of type module __name__ board board_id bpi_picow_s3 GP0 board.GP0 GP1 board.GP1 GP2 board.GP2 GP3 board.GP3 GP4 board.GP4 GP5 board.GP5 GP6 board.GP6 GP7 board.GP7 GP8 board.GP8 GP9 board.GP9 GP10 board.GP10 GP11 board.GP11 GP12 board.GP12 GP13 board.GP13 GP14 board.GP14 GP15 board.GP15 GP16 board.GP16 GP17 board.GP17 GP18 board.GP18 GP19 board.GP19 GP20 board.GP20 GP21 board.GP21 GP22 board.GP22 GP25 board.GP25 LED board.GP25 GP26 board.GP26 GP26_A0 board.GP26 A0 board.GP26 GP27 board.GP27 GP27_A1 board.GP27 A1 board.GP27 GP28 board.GP28 GP28_A2 board.GP28 A2 board.GP28 GP29 board.GP29 GP29_A3 board.GP29 A3 board.GP29 NEOPIXEL board.NEOPIXEL TX board.GP0 RX board.GP1 BOOT0 board.BOOT0 UART <function> >>> ``` ## Edit code.py to make the RGB LED blink 1. Click the Load button, select the code.py file on the CircuitPython development board, and click Open to start editing code.py . 2. Enter the following code in the editor: ```python import time import board import neopixel pixels neopixel.NeoPixel(board.NEOPIXEL, 1, brightness 0.1) while 1: pixels[0] (255,0,0) pixels.show() time.sleep(0.5) pixels[0] (0,255,0) pixels.show() time.sleep(0.5) pixels[0] (0,0,255) pixels.show() time.sleep(0.5) pixels[0] (255,255,255) pixels.show() time.sleep(0.5) ``` 3. Click the **Save** button, the edited content will be saved to the CircuitPython development board. If the code is correct, the color LED on the development board will flash red, green, blue and white in a cycle. Reset the development board or power it on again, and the program will start running again. 4. Use the interrupt shortcut key in the REPL to stop the program from running. 5. The code can also be directly copied and pasted into the REPL to run. > All subsequent examples can be edited in the code.py file or copied and pasted into the REPL to run. However, after the program code in the code.py file is executed, the development board will return to the state when it is not running, and the state will not be retained, but the state will be retained when executed in the REPL. ## Make pins output high or low level, control the LED 1. `board.LED` controls a single color LED on PicoW S3, high level is on, low level is off, enter the following code in the REPL: ```py import board import digitalio ledpin digitalio.DigitalInOut(board.LED) ledpin.direction digitalio.Direction.OUTPUT ledpin.value True ``` 1. Or: ```py import board import digitalio ledpin digitalio.DigitalInOut(board.LED) ledpin.switch_to_output(value True) # value 1 ``` 3. Make the LED blink every 0.5 seconds: ```py import board import digitalio import time ledpin digitalio.DigitalInOut(board.LED) while True: ledpin.switch_to_output(value 1) time.sleep(0.5) ledpin.switch_to_output(value 0) time.sleep(0.5) ``` 4. Use the KeyboardInterrupt(ctrl+c) in REPL to stop the running of the program. 5. Enter `import board;help(board)` in the REPL interface of the Mu editor to list all controllable pins. 6. `board.GP25` is exactly the same as `board.LED`. ## PWM output, control LED brightness 1. The brightness of the LED light can be controlled by controlling the PWM duty cycle. The control duty cycle is from 0% to 100%, using 16 bit precision, 0 to 65535 in decimal and 0 to FFFF in hexadecimal. Enter the following code in the REPL: ```py import board import pwmio ledpin pwmio.PWMOut(board.LED, frequency 25000, duty_cycle 0) ledpin.duty_cycle 32768 # mid point 0 65535 50 % duty cycle ``` 2. Just enter the last line of code again in the REPL to change the PWM duty cycle to bring the LED to maximum brightness:： ```py ledpin.duty_cycle 65535 ``` 3. Use `while` and `for` loops to make breathing lights: ```py import board import pwmio import time ledpin pwmio.PWMOut(board.LED, frequency 25000, duty_cycle 0) while True: for i in range(0, 65535, 1): ledpin.duty_cycle i for i in range(65535, 0, 1): ledpin.duty_cycle i ``` ## PWM controlled servo ![](../assets/images/MG90S Wiring Diagram.jpg) Take the MG90S servo as an example. For other servos, refer to their corresponding user manuals and modify the corresponding parameters in the following code. 1. The key parameters of MG90S servo: * Control angle, 0° ~ 180° * PWM duty time control, 500us ~ 2500us corresponds to 0° ~ 180° * Operating Voltage: 4.8V to 6V (5V typical) * Stall torque: 1.8 kg/cm (4.8V) * Maximum stall torque: 2.2 kg/cm (6V) * Operating speed is 0.1s/60° (4.8V) 2. The expression of the duty time required to find any rotation angle is: ``` Let y be the duty time and x be the rotation angle y (2500 500)/180*x+500 y (100*x+4500)/9 ``` 3. According to the parameters, it can be determined that the angle of the steering gear is controlled by the duration of the high level of the PWM wave. And since the control of the steering gear must be controlled by a periodic PWM waveform, the duration of one cycle must exceed the duty time required to control the steering gear to reach 180°, that is, if it exceeds 2500us, the PWM frequency should be lower than 400hz. 4. Set the PWM frequency to 200hz, then the cycle duration is 5000us, and the corresponding duty cycle for controlling the servo to rotate from 0° to 180° is 10% to 50%. 5. The PWM duty cycle control precision of CircuitPython is 16bit, 100% duty cycle is expressed as 1111 1111 1111 1111 in binary, FFFF in hexadecimal, and 65535 in decimal. 6. The expression for finding the duty cycle required for any rotation angle is: ``` Let y be the duty cycle and x the rotation angle y ((50 10)/180*x+10)/100*65535 y (4369*x+196605)/30 ``` 7. The wiring method of the servo and BPI PicoW S3: > The VBUS pin of BPI PicoW S3 can output +5V; except GP0, all GP pins can be used to output PWM, just need to modify the corresponding pin in the program. MG90SBPI PicoW S3 GND brownGND +5V redVBUS PWM orangeGP0 8. According to the above expressions and parameters, design a program that can arbitrarily control the rotation angle of this servo: ```py import board import pwmio import time servo_1 pwmio.PWMOut(board.GP0, frequency 200, duty_cycle 0)#200hz, one cycle 5000us def get_duty_cycle(x): return int((4369*x+196605)/30) servo_1.duty_cycle get_duty_cycle(90)# 90 degrees ``` 9. The PWM duty time of the output controlled by this program can be read out through a logic analyzer, which should be consistent with the calculated value. ![](../assets/images/MG90S_pulseveiw_2.png) ![](../assets/images/MG90S_pulseveiw_1.png) 10. Use a list to design a set of consecutive servo actions: ```py import board import pwmio import time servo_1 pwmio.PWMOut(board.GP0, frequency 200, duty_cycle 0)#200hz, one cycle 5000us def get_duty_cycle(x): return int((4369*x+196605)/30) action_list1 [0,45,90,135,180,0,180,45,135,90] while True: for i in action_list1: servo_1.duty_cycle get_duty_cycle(i) time.sleep(0.5) ``` ## ADC input, use a dual axis joystick ![](../assets/images/Dual axis_joystick.jpg) This is a common dual axis XY joystick module, which uses two potentiometers as its core components. Read their respective voltage values through the ADC analog/digital converter of the chip, and then convert the reading to its position on the XY coordinate axis. **Wiring reference** JoystickBPI PicoW S3 GNDGND +5V3V3 VRxGP27_A1 VRyGP26_A0 1. The ADC accuracy provided in CircuitPython is 16bit, that is, the hexadecimal expression of the maximum value is FFFF, the decimal expression is 65535, and the corresponding voltage range is 0mv ~ 3300mv. The actual ADC voltage range of the EPS32S3 chip used by BPI PicoW S3 is 0mv ~ 3100mv, so it can only measure 3100mv in actual application. 2. Basic ADC readings, read the values of the two potentiometers, and convert them to voltage values. > Note that the xy axis is reversed in the code, and the dual axis joystick module can be used after rotating it counterclockwise by 90°. This method can make the ADC reading increase when the joystick moves up the y axis, and vice versa, which conforms to the law of the common rectangular coordinate system. ```python import board,analogio,time x_axis_pin analogio.AnalogIn(board.A0) y_axis_pin analogio.AnalogIn(board.A1) while True: x_axis x_axis_pin.value y_axis y_axis_pin.value # print((x_axis,y_axis)) x_value x_axis / 65535 * 3300 y_value y_axis / 65535 * 3300 print(\"{0}mv,{1}mv\".format(x_value,y_value)) time.sleep(0.1) ``` 3. In the Mu editor, click the `Plotter` icon to display the plotter, which can display the value output by REPL as a time related line graph in real time. ![](../assets/images/circuitpython_plotter.png) 4. The following program can realize the function of calibrating the coordinate zero point. In the first five seconds of running, please stop the joystick and wait for the zero point value to be obtained. ```python import board,analogio,time x_axis_pin analogio.AnalogIn(board.A0) y_axis_pin analogio.AnalogIn(board.A1) def get_zero(times 500, sleep 0.01): x_total 0 y_total 0 for i in range (times): x_axis x_axis_pin.value y_axis y_axis_pin.value x_total + x_axis y_total + y_axis time.sleep(sleep) x_zero x_total // times y_zero y_total // times return (x_zero,y_zero) zero get_zero(times 500, sleep 0.01) print(zero) while True: x_axis x_axis_pin.value zero[0] y_axis y_axis_pin.value zero[1] print((x_axis,y_axis)) time.sleep(0.1) ``` 5. The following program gets the joystick direction, which is the most common application for dual axis joysticks. ```python import board,analogio,time x_axis_pin analogio.AnalogIn(board.A0) y_axis_pin analogio.AnalogIn(board.A1) direction_list [\"East\",\"Southeast\",\"South\",\"Southwest\",\"West\",\"Northwest\",\"North\",\"Northeast\",\"Centre\"] def get_zero(times 500, sleep 0.01): x_total 0 y_total 0 for i in range (times): x_axis x_axis_pin.value y_axis y_axis_pin.value x_total + x_axis y_total + y_axis time.sleep(sleep) x_zero x_total // times y_zero y_total // times return (x_zero,y_zero) def get_direction(zero (32767,32767)): x_axis x_axis_pin.value zero[0] y_axis y_axis_pin.value zero[1] if x_axis > 10000 and 10000 < y_axis < 10000: return direction_list[0] elif x_axis > 10000 and y_axis < 10000: return direction_list[1] elif 10000 < x_axis < 10000 and y_axis < 10000: return direction_list[2] elif x_axis < 10000 and y_axis < 10000: return direction_list[3] elif x_axis < 10000 and 10000 < y_axis < 10000: return direction_list[4] elif x_axis < 10000 and y_axis > 10000: return direction_list[5] elif 10000 < x_axis < 10000 and y_axis > 10000: return direction_list[6] elif x_axis > 10000 and y_axis > 10000: return direction_list[7] else : return direction_list[8] zero get_zero(times 50, sleep 0.01) print(zero) while True: x_axis x_axis_pin.value zero[0] y_axis y_axis_pin.value zero[1] print((x_axis,y_axis)) print(get_direction(zero zero)) time.sleep(0.1) ``` 6. The following program can set the coordinate accuracy level, calculate the span of each level, eliminate the jitter as required, and enhance the practicality of the data. ```python import board,analogio,time x_axis_pin analogio.AnalogIn(board.A0) y_axis_pin analogio.AnalogIn(board.A1) def get_zero(times 500, sleep 0.01): x_total 0 y_total 0 for i in range (times): x_axis x_axis_pin.value y_axis y_axis_pin.value x_total + x_axis y_total + y_axis time.sleep(sleep) x_zero x_total // times y_zero y_total // times return (x_zero,y_zero) def get_extremum(times 500, sleep 0.01): x_list [] y_list [] for i in range (times): x_axis x_axis_pin.value y_axis y_axis_pin.value x_list.append(x_axis) y_list.append(y_axis) time.sleep(sleep) x_extremum (min(x_list),max(x_list)) y_extremum (min(y_list),max(y_list)) return (x_extremum,y_extremum) def get_spacing(level 16 , zero (32767,32767) ,x_extremum (0,65535),y_extremum (0,65535)): x_temp_1 (zero[0] x_extremum[0]) // level x_temp_2 (x_extremum[1] zero[0] ) // level y_temp_1 (zero[1] y_extremum[0]) // level y_temp_2 (y_extremum[1] zero[1] ) // level x_spacing (x_temp_1,x_temp_2) y_spacing (y_temp_1,y_temp_2) return (x_spacing,y_spacing) def get_coordinates(zero (32767,32767), x_spacing (2048,2048),y_spacing (2048,2048)): x_value x_axis_pin.value zero[0] y_value y_axis_pin.value zero[1] if x_value > 0: x_axis x_value // x_spacing[1] else: x_axis (( x_value) // x_spacing[0]) if y_value > 0: y_axis y_value // y_spacing[1] else: y_axis (( y_value) // y_spacing[0]) return (x_axis,y_axis) zero get_zero(times 500, sleep 0.01) print(zero) (x_extremum,y_extremum) get_extremum(times 500, sleep 0.01) print((x_extremum, y_extremum)) (x_spacing,y_spacing) get_spacing(level 128 , zero zero, x_extremum x_extremum,y_extremum y_extremum) print((x_spacing, y_spacing)) while True: coordinates get_coordinates(zero zero, x_spacing x_spacing, y_spacing y_spacing) print(coordinates) time.sleep(0.1) ``` ## Using incremental rotary encoders ![](../assets/images/rotary_incremental_encoder_pic.png) ![](../assets/images/rotary_incremental_encoder_pic_1.jpg) **Wiring reference** **Incremental rotary encoder****BPI PicoW S3** GNDGND +VBUS SW DTGP0 CLKGP1 1. The appearance of the incremental rotary encoder is similar to some common rotary potentiometers, but there are three key differences. 1. The microcontroller uses the ADC peripheral to read the analog signal (voltage value) output by the rotary potentiometer to determine the current angular position of the shaft. The microcontroller receives the digital signal output by the incremental rotary encoder through GPIO, and can judge the movement of the rotating shaft corresponding to the signal through the software program. 2. Within a certain range of accuracy, the microcontroller can determine the current angular position of the rotary potentiometer shaft, but due to the continuity of the analog signal and poor anti interference ability, it cannot accurately determine whether it has an action. The incremental rotary encoder sends a digital signal to the microcontroller only when the rotating shaft moves to a contact point, if an incremental rotary encoder has 20 contacts in one revolution, it will trigger 20 action signals for one revolution, and the microcontroller can accurately determine whether it moves, in which direction it turns, and how many times the signal is triggered. 3. Rotary potentiometers usually cannot rotate infinitely in any direction, and will stop at the maximum or minimum limit points. But incremental rotary encoders can rotate infinitely in any direction. 2. Incremental rotary encoders use quadrature encoders to generate their A and B output signals. The pulses emitted from the A and B outputs are encoded in quadrature, which means that when the incremental encoder is moving at a constant velocity, the A and B waveforms are square waves with a 90 degree phase difference between A and B. Eventually the A and B signals will be delivered to the microcontroller from two pins. ![](../assets/images/rotary_incremental_encoder_pic_2.gif) 3. Theoretically, at any given time, for a rotary encoder, there is a phase difference of +90° for clockwise rotation and −90° for counterclockwise rotation between the A and B signals, it depends on the design of the quadrature encoder inside the device. 4. The pulse frequency on the A or B output is proportional to the speed (rate of change of position) of the shaft. A higher frequency means a faster speed, while a lower frequency means a slower speed. When the shaft is stationary, the static, constant signal output is on A and B, so there are many speed measurement schemes using incremental rotary encoders. > See [Wikipedia:Incremental encoders](https://en.wikipedia.org/wiki/Incremental_encoder#Quadrature_decoder) . 5. Use CircuitPython to design a program to read the signals on the GP0 and GP1 pins, and when one of them changes, output the values of the two pins at the same time, connect the development board and the incremental rotary encoder and run the program. ```python import board import digitalio dt digitalio.DigitalInOut(board.GP0) clk digitalio.DigitalInOut(board.GP1) dt.switch_to_input() clk.switch_to_input() dt_last_value 0 clk_last_value 0 while True: if dt.value ! dt_last_value or clk.value ! clk_last_value: dt_last_value int(dt.value) clk_last_value int(clk.value) print((dt_last_value,clk_last_value)) ``` 6. Turn the rotating shaft step by step to observe the output signal. If there is a logic analyzer or oscilloscope, it can also be connected to observe. 1. When the shaft rotates counterclockwise, the REPL output: ``` (1, 1) (1, 0) (0, 0) (0, 1) (1, 1) (1, 0) (0, 0) (0, 1) (1, 1) ``` 2. When the shaft rotates counterclockwise, the waveform observed by the logic analyzer: ![](../assets/images/rotary_incremental_encoder_0.png) 3. When the shaft rotates clockwise, the REPL output: ``` (1, 1) (0, 1) (0, 0) (1, 0) (1, 1) (0, 1) (0, 0) (1, 0) (1, 1) ``` 4. When the shaft rotates clockwise, the waveform observed by the logic analyzer: ![](../assets/images/rotary_incremental_encoder_1.png) 7. The first thing that can be observed is that the signals on the two pins are both 1 after the shaft completes the first level of motion. Based on this, the program can be designed to output a count value when both the values of the two pins become 1, and this count value can be used as the basis for judging that the encoder has completed an action. ```python import board import digitalio dt digitalio.DigitalInOut(board.GP0) clk digitalio.DigitalInOut(board.GP1) dt.switch_to_input() clk.switch_to_input() dt_last_value 0 clk_last_value 0 count 0 while True: if dt.value ! dt_last_value or clk.value ! clk_last_value: dt_last_value int(dt.value) clk_last_value int(clk.value) print((dt_last_value,clk_last_value)) if (dt_last_value,clk_last_value) (1,1): print(' ',count_1,' ') count + 1 ``` 8. Then determine the law and difference of the signal output on the two pins when the encoder rotates clockwise and counterclockwise. 1. The law of counterclockwise rotation is (1, 1)>(1, 0)>(0, 0)>(0, 1)>(1, 1) . 2. The law of clockwise rotation is (1, 1)>(0, 1)>(0, 0)>(1, 0)>(1, 1) . From this, we can design a program that rotates clockwise to make the count +1, and rotates counterclockwise to make the count 1, and add the function of debounce and error correction. ```python import board import digitalio import time dt digitalio.DigitalInOut(board.GP0) clk digitalio.DigitalInOut(board.GP1) dt.switch_to_input() clk.switch_to_input() dt_last_value 0 clk_last_value 0 count 0 start_sign 0 clockwise_sign 0 while True: if dt.value ! dt_last_value or clk.value ! clk_last_value: dt_last_value int(dt.value) clk_last_value int(clk.value) print((dt_last_value,clk_last_value)) if start_sign 0 and (dt_last_value,clk_last_value) (0,0): start_sign 1 elif start_sign 1: if (dt_last_value,clk_last_value) (1, 0): clockwise_sign 1 elif (dt_last_value,clk_last_value) (0, 1): clockwise_sign 1 elif (dt_last_value,clk_last_value) (1, 1): count count + clockwise_sign clockwise_sign 0 start_sign 0 print(' ',count,' ') ``` 9. The implementation of the debounce and error elimination function in this program is not to gradually judge whether the verification conforms to the signal law. There may be more ways to achieve debounce and error elimination. Welcome to discuss. 10. In addition, the `rotaryio` module of CircuitPython can directly realize the function of counting the forward and reverse. There are some differences in the internal procedures, but the final functions are basically the same. ```python import rotaryio import board encoder rotaryio.IncrementalEncoder(board.GP0,board.GP1) last_position 0 while True: position encoder.position if position ! last_position: print(position) last_position position ``` ## Download and install the CircuitPython library to drive the ssd1306 oled display module ![](../assets/images/adafruit_ssd1306_4.jpg) [CircuitPython library official website](https://circuitpython.org/libraries) [Adafruit CircuitPython Library Documentation Page](https://docs.circuitpython.org/projects/bundle/en/latest/index.html) [Adafruit SSD1306 Library Documentation Page](https://docs.circuitpython.org/projects/ssd1306/en/latest/index.html) [Adafruit framebuf Library Documentation Page](https://docs.circuitpython.org/projects/framebuf/en/latest/) This section takes ssd1306 driver library and framebuf library as examples to guide how to download and install CircuitPython library. 1. Open the [Adafruit CircuitPython Library Documentation Page](https://docs.circuitpython.org/projects/bundle/en/latest/index.html) in a new page. 2. Find and open the **SSD1306 OLED (framebuf)** item on the page, then click the **Download from GitHub** item on the left to jump to its GitHub releases page, click the **adafruit circuitpython ssd1306 8.x mpy 2.12.12.zip** item to download it locally. ![](../assets/images/adafruit_ssd1306_1.jpg) ![](../assets/images/adafruit_ssd1306_2.jpg) ![](../assets/images/adafruit_ssd1306_3.jpg) 3. Go back to the Adafruit CircuitPython library documentation page, find and open the Framebuf Module item on the page, then click the Download from GitHub item on the left to jump to its GitHub releases page, click the adafruit circuitpython framebuf 8.x mpy 1.4.14.zip item to download it locally. > Just download the latest version. 4. Unzip the downloaded two compressed packages, the internal folder structure is as follows: ``` ├─examples │ ├─xxx.py │ ├─xxx.py │ └─...... ├─lib │ ├─a.mpy │ ├─b.mpy │ └─...... └─requirements ├─a │ └─requirements.txt ├─b │ └─requirements.txt └─...... ``` 5. In the examples folder are some library usage routines, in the lib folder the file with the extension `.mpy` is the library file, the requirements.txt file in the requirements folder records the names of other necessary library files that each library file depends on, some of which are already included in the CircuitPython firmware, and those that are not included need to be downloaded and installed separately. Such as, the methods of drawing graphics and text in the adafruit_ssd1306 library all depend on the adafruit_framebuf library, so we also download it to the local in step 3. 7. The adafruit_framebuf library also needs to copy the **font5x8.bin** file in its examples folder to the root of the **CIRCUITPY** disk, where the code.py file is located. This is a font file, and it is needed to display text. 8. Connect an i2c protocol ssd1306 oled display module to the development board. **Wiring Reference** ssd1306 BPI PicoW S3 : : : : GND GND VCC 3V3 SCL GP0 SDA GP1 9. Edit the code.py file and enter the following codes to drive the display module to output graphics and characters. Modify the value of the variable `bgColor` in the code to 1 to make the display background white and the display graphics black. You can find the API reference in the documentation of the two libraries, and you can quickly understand it with the routines, and get started with the ssd1306 display module. ```python import board import busio import adafruit_ssd1306 import time i2c busio.I2C(board.GP0, board.GP1) display adafruit_ssd1306.SSD1306_I2C(128, 64, i2c, addr 0x3C) bgColor 0 display.fill(bgColor) for i in range(0,display.height,4): for j in range(0,display.width,4): display.pixel(j, i, not bgColor) display.show() display.fill(bgColor) for i in range(0,display.height,4): display.hline(0, i,display.width, not bgColor) display.show() display.fill(bgColor) for i in range(0,display.width,8): display.vline(i, 0,display.height, not bgColor) display.show() display.fill(bgColor) for i in range(0,display.height,4): display.line(0, 0, display.width, i, not bgColor) display.line(display.width, display.height, 0, display.height i, not bgColor) display.show() display.fill(bgColor) for i in range(0,display.width//2,4): display.circle(display.width//2, display.height//2, i, not bgColor) display.show() display.fill(bgColor) for i in range(0,display.height,16): for j in range(0,display.width,16): display.rect(j, i, 12, 12, not bgColor) display.show() for i in range(0,display.height,16): for j in range(0,display.width,16): display.fill_rect(j+2, i+2, 8, 8, not bgColor) display.show() display.fill(bgColor) display.text(\"Hello\", 0, 24, not bgColor, font_name 'font5x8.bin', size 2) display.show() time.sleep(0.25) display.text(\"World!\", 0, 40, not bgColor, font_name 'font5x8.bin', size 3) display.show() time.sleep(0.25) display.text(\">>>\", 60, 0, not bgColor, font_name 'font5x8.bin', size 4) display.show() time.sleep(1) display.fill(bgColor) char_width 6 char_height 8 chars_per_line display.width // 6 for i in range(255): x char_width * (i % chars_per_line) y char_height * (i // chars_per_line) display.text(chr(i), x, y, not bgColor, font_name 'font5x8.bin', size 1) display.show() ``` # Multi function application ## OLED real time animation display of dual axis joystick position Based on the previous chapters : [ADC input, use a dual axis joystick](#adc input use a dual axis joystick) [Download and install the CircuitPython library to drive the ssd1306 oled display module](#download and install the circuitpython library to drive the ssd1306 oled display module) A program can be designed to make the OLED real time animation display the position of the dual axis joystick. **Wiring Reference** ssd1306 BPI PicoW S3 : : : : GND GND VCC 3V3 SCL GP0 SDA GP1 Joystick BPI PicoW S3 : : : : GND GND +5V 3V3 VRx GP27_A1 VRY GP26_A0 ```python import time import board import busio import analogio import adafruit_ssd1306 def get_zero(times 500, sleep 0.01): x_total 0 y_total 0 for i in range (times): x_axis x_axis_pin.value y_axis y_axis_pin.value x_total + x_axis y_total + y_axis time.sleep(sleep) x_zero x_total // times y_zero y_total // times return (x_zero,y_zero) def get_extremum(times 500, sleep 0.01): x_list [] y_list [] for i in range (times): x_axis x_axis_pin.value y_axis y_axis_pin.value x_list.append(x_axis) y_list.append(y_axis) time.sleep(sleep) x_extremum (min(x_list),max(x_list)) y_extremum (min(y_list),max(y_list)) return (x_extremum,y_extremum) def get_spacing(level 16 , zero (32767,32767) ,x_extremum (0,65535),y_extremum (0,65535)): x_temp_1 (zero[0] x_extremum[0]) // level x_temp_2 (x_extremum[1] zero[0] ) // level y_temp_1 (zero[1] y_extremum[0]) // level y_temp_2 (y_extremum[1] zero[1] ) // level x_spacing (x_temp_1,x_temp_2) y_spacing (y_temp_1,y_temp_2) return (x_spacing,y_spacing) def get_coordinates(zero (32767,32767), x_spacing (2048,2048),y_spacing (2048,2048)): x_value x_axis_pin.value zero[0] y_value y_axis_pin.value zero[1] if x_value > 0: x_axis x_value // x_spacing[1] else: x_axis (( x_value) // x_spacing[0]) if y_value > 0: y_axis y_value // y_spacing[1] else: y_axis (( y_value) // y_spacing[0]) return (x_axis,y_axis) # i2c init i2c busio.I2C(board.GP0, board.GP1) display adafruit_ssd1306.SSD1306_I2C(128, 64, i2c, addr 0x3C) # Uniformly set the color and background color of displayed characters or graphics. # Monochrome OLEDs only need to set one and then negate the other. display_color 0 bg_color not display_color # Fill background color. display.fill(bg_color) display.show() # Set 2 axis rocker pin. x_axis_pin analogio.AnalogIn(board.A0) y_axis_pin analogio.AnalogIn(board.A1) # Calibrate the zero point. # Take the xy axis reading when the dual axis joystick is at rest and set it to zero point. display.text('Zero adjustment', 0, 20, display_color, font_name 'font5x8.bin', size 1) display.text('Do not touch', 0, 28, display_color, font_name 'font5x8.bin', size 1) display.show() zero get_zero(times 200, sleep 0.01) display.text('Do not touch', 0, 28, bg_color, font_name 'font5x8.bin', size 1) str_zero \"x {},y {}\".format(zero[0],zero[1]) display.text(str_zero, 0, 28, display_color, font_name 'font5x8.bin', size 1) display.show() print(str_zero) time.sleep(2) # Different hardware measures different extreme values. display.fill(bg_color) display.text('Extremum adjustment', 0, 20, display_color, font_name 'font5x8.bin', size 1) display.text('Rotary rocker', 0, 28, display_color, font_name 'font5x8.bin', size 1) display.show() (x_extremum,y_extremum) get_extremum(times 400, sleep 0.01) display.text('Extremum adjustment', 0, 20, bg_color, font_name 'font5x8.bin', size 1) display.text('Rotary rocker', 0, 28, bg_color, font_name 'font5x8.bin', size 1) str_x_extremum \"x_min {},x_max {}\".format(x_extremum[0],x_extremum[1]) str_y_extremum \"y_min {},y_max {}\".format(y_extremum[0],y_extremum[1]) display.text(str_x_extremum, 0, 20, display_color, font_name 'font5x8.bin', size 1) display.text(str_y_extremum, 0, 28, display_color, font_name 'font5x8.bin', size 1) print((str_x_extremum, str_y_extremum)) display.show() time.sleep(2) # Setting the scale spacing can eliminate unnecessary jitter. (x_spacing,y_spacing) get_spacing(level 32 , zero zero, x_extremum x_extremum,y_extremum y_extremum) print((x_spacing, y_spacing)) display.fill(bg_color) display.text('x ', 70, 16, display_color, font_name 'font5x8.bin', size 2) display.text('y ', 70, 32, display_color, font_name 'font5x8.bin', size 2) (x_axis,y_axis) (0,0) (x_axis_1,y_axis_1) (1,1) (x_axis_2,y_axis_2) (0,0) display.show() while True: # Get the coordinate value in a loop. (x_axis,y_axis) get_coordinates(zero zero, x_spacing x_spacing, y_spacing y_spacing) # Only refresh the display when the coordinates change. if (x_axis,y_axis) (x_axis_1,y_axis_1): pass else: # Using background color inversion for identical pixels, # pixels can be refreshed with minimal performance cost. display.fill_rect(x_axis_2 3, y_axis_2 3, 6, 6, bg_color) display.text(str(x_axis_1), 90, 16, bg_color, font_name 'font5x8.bin', size 2) display.text(str(y_axis_1), 90, 32, bg_color, font_name 'font5x8.bin', size 2) (x_axis_1,y_axis_1) (x_axis,y_axis) (x_axis_2,y_axis_2) (x_axis+32, y_axis+32) display.fill_rect(x_axis_2 3, y_axis_2 3, 6, 6, display_color) display.text(str(x_axis_1), 90, 16, display_color, font_name 'font5x8.bin', size 2) display.text(str(y_axis_1), 90, 32, display_color, font_name 'font5x8.bin', size 2) display.show() ```"},"/PicoW_S3_doc/en/CircuitPython/supported_by_circuitpython.html":{"title":"Supported by CircuitPython","content":"# Supported by CircuitPython 1. Supported by the adafruit/circuitpython GitHub repository. https://github.com/adafruit/circuitpython/pull/7031 branch has been merged. 2. Supported by the adafruit/tinyuf2 GitHub repository. https://github.com/adafruit/tinyuf2/pull/250 branch has been merged. 3. Supported by the adafruit/circuitpython org GitHub repository. https://github.com/adafruit/circuitpython org/pull/1070 branch has been merged. https://github.com/adafruit/circuitpython org/pull/1077 branch has been merged. 4. The circuitpython.org website can download circuitpython firmware and tinyuf2 firmware. https://circuitpython.org/board/bpi_picow_s3/"},"/PicoW_S3_doc/en/CircuitPython/update_circuitpython.html":{"title":"How to update CircuitPython firmware","content":"# How to update CircuitPython firmware > TinyUF2 + CircuitPython firmware has been installed before leaving the factory. To upgrade circuitython, you only need to double click the reset button to enter UF2 bootloader mode without erasing the flash. > This method is applicable to development boards that already have tinyUF2 firmware. If the flash of the development board is erased or fails to enter UF2 mode, please refer to [How to burn tinyUF2 firmware](flash_tinyuf2.html). 1. Enter the [BPI PicoW S3 CircuitPython Download](https://circuitpython.org/board/bpi_picow_s3/) page. ![](../assets/images/picow_s3_circuitpython_download.jpg) 2. Click the DOWNLOAD UF2 NOW button to download the latest released `.uf2` firmware. 3. Connect the development board to the computer via USB, and a disk named `CIRCUITPY` will appear on the computer file management page. This is a disk in CircuitPython mode. Double click the `Reset` button on the development board to make it To change to a disk in UF2 mode, the following are the specific steps. 1. Quickly press the `Reset` button once. ![](../assets/images/picow_s3_circuitpython_download_2.jpg) 2. Quickly press the `Reset` button again when the purple light is on. ![](../assets/images/picow_s3_circuitpython_download_3.jpg) 3. The sign of a successful trigger is that the colored light turns red after a while and turns green. If you do not get this result, you can try the first two steps again. ![](../assets/images/picow_s3_circuitpython_download_4.jpg) 4. The name of the disk in UF2 mode is `UF2BOOT`, copy the `.uf2` firmware downloaded in step 1 to this disk, the colored light will flash orange during the process, please do not disconnect or modify the development board for any operation. 5. After the CircuitPython firmware update is completed, it will automatically reset, and a `CIRCUITPY` disk will reappear on the computer file management page, and the specific firmware version can be viewed through the REPL."},"/PicoW_S3_doc/en/CircuitPython/config_mu-editor.html":{"title":"Configure usage environment (Mu editor)","content":"# Configure usage environment (Mu editor) ## Download and install Mu editor 1. Enter [**Mu Editing Organ Network**](https://codewith.mu/), click the **Download** button to enter the new page. ![](../assets/images/Download_mu_1.png) 2. Select the operating system currently used by your computer, and click the **Download** button corresponding to the operating system to start downloading the installation package. ![](../assets/images/Download_mu_2.png) 3. Click the **Instuctions** button corresponding to the operating system to view the detailed installation steps, and install according to the guidelines. ## Establish the connection between the Mu editor and the development board > BPI PicoW S3 has been installed with tinyUF2 and CircuitPython firmware. 1. Start the Mu editor and change the mode to CircuitPython. If you have connected the CircuitPython development board correctly, you will be prompted whether to switch to this mode directly. ![](../assets/images/Download_mu_3.png) ![](../assets/images/Download_mu_4.png) 2. Click the **Serial** button, then press any key to enter the CircuitPython REPL. ![](../assets/images/Download_mu_5.png)"},"/PicoW_S3_doc/en/Unboxing/Introduction.html":{"title":"【Introduction to development board】","content":"# 【Introduction to development board】 The BPI PicoW S3 has an onboard ESP32 S3 chip that supports 2.4 GHz Wi Fi and Bluetooth® LE dual mode wireless communication. The board supports two power supply modes: USB and IO power supply, which can realize the function of automatic power switching under dual power supply. Small size, convenient interface, easy to use, and can be directly applied to low power IoT projects. The BPI PicoW S3 development board supports ESP IDF, Arduino, MicroPython and other methods for programming and development in terms of software. All IO pins corresponding to the chip are marked on the BPI PicoW S3 development board, and the shape is consistent with the Raspberry Pico W development board. Developers can add peripheral devices supported by the Raspberry Pico W to the BPI PicoW On the S3, the development board can also be plugged into the breadboard. ## key features ESP32 S3, Xtensa® 32 bit LX7 On chip peripherals PSRAM, off chip FLASH Ultra low power 10uA 2.4G WIFI, Bluetooth 5, Bluetooth mesh GPIO , ADC , TOUCH , PWM , I2C , SPI , RMT , I2S , UART , LCD, CAMERA , USB , JTAG 1*MicroUSB 1 * Full Color LED ## hardware ### Interface diagram ![](../assets/images/PicoW S3_board.png) ### Hardware Specifications <table> <tr> <td>BPI PicoW S3 Spec Sheet</td> </tr> <tr> <td>SoC main control chip</td> <td>ESP32 S3, Xtensa® 32 bit LX7 Dual Core Processor</td> </tr> <tr> <td>Frequency</td> <td>240MHz MAX</td> </tr> <tr> <td>Operating Temperature</td> <td> 40℃~+85℃</td> </tr> <tr> <td>On Chip ROM</td> <td>384KB</td> </tr> <tr> <td>On chip SRAM</td> <td>320KB</td> </tr> <tr> <td>Off chip FLASH ROM</td> <td>8MB</td> </tr> <tr> <td>On Chip Peripherals PSRAM</td> <td>2MB</td> </tr> <tr> <td>WIFI</td> <td>IEEE 802.11 b/g/n, 2.4Ghz band, 150Mbps</td> </tr> <tr> <td>Bluetooth</td> <td>Bluetooth 5, Bluetooth mesh</td> </tr> <tr> <td>GPIO</td> <td>BPI PicoW S3 has brought out 27 available GPIOs</td> </tr> <tr> <td>ADC</td> <td>2 × 12 bit SAR ADC supporting 20 analog channel inputs</td> </tr> <tr> <td>TOUCH Capacitive Touch Sensor</td> <td>14</td> </tr> <tr> <td>SPI</td> <td>4</td> </tr> <tr> <td>I2C</td> <td>2, supports master or slave mode</td> </tr> <tr> <td>I2S</td> <td>2, serial stereo data input and output</td> </tr> <tr> <td>LCD</td> <td>1, supports 8 bit ~16 bit parallel RGB, I8080, MOTO6800 interface</td> </tr> <tr> <td>CAMERA</td> <td>1, supports 8 bit ~16 bit DVP image sensor interface</td> </tr> <tr> <td>UART</td> <td>3, supports asynchronous communication (RS232 and RS485) and IrDA</td> </tr> <tr> <td>PWM</td> <td>8 independent channels, 14 bit precision</td> </tr> <tr> <td>MCPWM</td> <td>2</td> </tr> <tr> <td>USB</td> <td>1 × Full Speed ​​USB 2.0 OTG, MicroUSB Female</td> </tr> <tr> <td>USB Serial/JTAG Controller</td> <td>1, USB Full Speed ​​Standard, CDC ACM, JTAG</td> </tr> <tr> <td>Temperature Sensor</td> <td>1, measuring from –20 °C to 110 °C, for monitoring chip internal temperature</td> </tr> <tr> <td>SD/MMC</td> <td>1 × SDIO host interface with 2 card slots, supports SD card 3.0 and 3.01, SDIO 3.0, CE ATA 1.1, MMC 4.41, eMMC 4.5 and 4.51</td> </tr> <tr> <td>TWAI® Controller</td> <td>1, compatible with ISO11898 1 (CAN Specification 2.0)</td> </tr> <tr> <td>Generic DMA Controller</td> <td>5 receive channels and 5 transmit channels</td> </tr> <tr> <td>RMT</td> <td>4 channels transmit, 4 channels receive, shared 384 x 32 bit RAM</td> </tr> <tr> <td>Pulse Counter</td> <td>4 pulse count controllers (units), each with 2 independent channels</td> </tr> <tr> <td>Timer</td> <td>4 × 54 bit general purpose timers, 16 bit clock prescaler, 1 × 52 bit system timer, 3 × watchdog timers</td> </tr> <tr> <td>External Crystal</td> <td>40Mhz</td> </tr> <tr> <td>RTC and Low Power Management</td> <td>Power Management Unit (PMU) + Ultra Low Power Coprocessor (ULP)</td> </tr> <tr> <td>Low Power Current</td> <td>10uA</td> </tr> <tr> <td>Operating Voltage</td> <td>3.3V</td> </tr> <tr> <td>Input Voltage</td> <td>3.3V~5.5V</td> </tr> <tr> <td>Maximum Discharge Current</td> <td>2A@3.3V DC/DC</td> </tr> <tr> <td>Controllable full color LED</td> <td>1</td> </tr> </table> ### Hardware Dimensions ![](../assets/images/PicoW S3_board_dimension.png) <table> <tr> <td>BPI PicoW S3 Size Chart</td> </tr> <tr> <td>Pin spacing</td> <td>2.54mm</td> </tr> <tr> <td>Mounting Hole Spacing</td> <td>11.4mm/ 47mm</td> </tr> <tr> <td>Mounting Hole Dimensions</td> <td>Inner Diameter 2.1mm/Outer Diameter 3.4mm</td> </tr> <tr> <td>Motherboard Dimensions</td> <td>21 × 51.88(mm)/0.83 x 2.04(inches)</td> </tr> <tr> <td>plate thickness</td> <td>1.2mm</td> </tr> <tr> <td></td> </tr> </table> The pin spacing is compatible with universal boards (hole boards, dot matrix boards), breadboards, and can be directly attached to other PCBs for easy debugging applications. ## Information and resources [GitHub: BPI PicoW S3 development board schematic PDF](https://github.com/BPI STEAM/BPI PicoW Doc/blob/main/sch/BPI PicoW V0.4.pdf) [ESP32 S3 Datasheet](https://www.espressif.com/sites/default/files/documentation/esp32 s3_datasheet_en.pdf) [ESP32 S3 Technical Reference Manual](https://www.espressif.com/sites/default/files/documentation/esp32 s3_technical_reference_manual_en.pdf)"},"/PicoW_S3_doc/en/Arduino/Basic.html":{"title":"Use of onboard resources","content":"# Use of onboard resources This chapter mainly describes the basic usage of the peripherals of the PicoW S3 main control board through some sample projects. Through the following projects, you can modify and complete your own projects. The PicoW S3 peripherals mainly include: UART, I2C, SPI, ADC, PWM, DAC, etc. ## Preparation before starting The MicorUSB on the BPI PicoW S3 development board uses the native USB interface of the ESP32 S3 instead of the traditional USB to TLL chip. In order for your development board to download programs correctly, you need to set the BPI PicoW S3 to download mode, there are two methods: Connect to the computer via USB, use tweezers to short the BOOT, then press the Reset button and release it, and finally disconnect the BOOT short. In the state of disconnecting all power supplies, short circuit BOOT, then plug the development board into the computer, and finally disconnect the BOOT short circuit. ![](../assets/images/PicoW BOOT.png) At this time, you can see more than one COM port in the device manager ![](../assets/images/Device_manager.jpg) Select this port in the IDE ![](../assets/images/Device_manager_1.jpg) ## Project 1 Serial port experiment In the very first chapter, we uploaded a Blink program to test the LED status lights on the board. Now, we use the UART serial port and print the timing data every second. ### Required components PicoW S3 Motherboard X 1 ![](../assets/images/PicoW S3.png) ### Hardware connection No other sensors are required for this project, so just connect the PicoW S3 to a computer via USB. ### Enter code Open the Arduino IDE. Although it is possible to copy the code directly, we recommend that you enter the code manually to familiarize yourself with it. code show as below: <details> <summary>Expand to view</summary> <pre><code> void setup() { Serial.begin(115200); //Set serial communication baud rate } void loop() { static unsigned long i 0; //define variable i Serial.println(i++); //output i after adding one delay(1000); // delay 1 second } </code></pre> </details> After the input is complete, click \"Compile\" to check the code for errors. After making sure there are no errors, you can start uploading. After clicking \"Upload\", the IDE will send the code to the PicoW S3 motherboard. After the upload is complete, you need to press the reset button so that the code can run normally ### Experimental phenomena After completing the upload in the previous steps, open the serial monitor that comes with the Arduino IDE, and you can see the following print information: ![](../assets/images/Lesson1 1.png) ## Project 2 PWM (breathing light) Breathing light, that is, let the PicoW S3 drive the LED light through PWM to realize the brightness gradient of the LED, which looks like it is breathing. For an explanation of PWM, please read the Knowledge Extension section. ### Required components PicoW S3 Motherboard X 1 ![](../assets/images/PicoW S3.png) LED X 1 (recommended to connect a resistor in series to limit current) ![](../assets/images/led.png) ### Hardware connection Just connect the LED to GPIO13 of PicoW S3, the long one is connected to GPIO13, and the short one is connected to GND ### Enter code Open the Arduino IDE. Although it is possible to copy the code directly, we recommend that you enter the code manually to familiarize yourself with it. code show as below: <details> <summary>Expand to view</summary> <pre><code> #define LED_CHANNEL_0 0 //Set channel 0 #define LED_TIMER_13_BIT 13 //Set 13 bit timer #define LED_BASE_FREQ 5000 //Set the timer frequency bit to 5000Hz #define LED_PIN 13 //Set LED light int brightness 0; // LED brightness int fadeAmount 1; // number of LEDs //Set the brightness of the led light void ledcAnalogWrite(uint32_t value, uint32_t valueMax 255) { //calculate duty cycle uint32_t duty (LED_BASE_FREQ / valueMax) * min(value, valueMax); //set duty cycle ledcWrite(LED_CHANNEL_0, duty); } void setup() { ledcSetup(LED_CHANNEL_0, LED_BASE_FREQ, LED_TIMER_13_BIT); ledcAttachPin(LED_PIN, LED_CHANNEL_0); } void loop() { ledcAnalogWrite(brightness); brightness + fadeAmount; if (brightness < 0 brightness > 255) { fadeAmount fadeAmount; } delay(30); } </code></pre> </details> After typing, click the \"Compile\" button to check the code for errors. After confirming that there are no errors, you can start uploading, click the \"Upload\" button . The IDE will send the code to the PicoW S3 board. After the upload is complete, you can see the LED light next to the Type C start to \"breathe\"! Now let's review the code and hardware to see how it works. ### Knowledge learning What is a PWM control signal? PWM (pulse width modulation) pulse width modulation, the MCU (microcontroller) controls the on off of the switching device, so that the output terminal gets a series of pulses of equal amplitude, and these pulses are used to replace the sine wave or the required waveform. As shown below: ![](../assets/images/Lesson2 1.jpg) Among them, tON is the high level duration, tPWM is the period of the PWM wave, tPWM tON is the low level duration, and the duty cycle refers to the proportion of the high level duration to the entire cycle, namely D ton/tPWM. ### Code Analysis The PWM of the PicoW S3 is much more advanced than the ordinary Arduino UNO. The analogWrite function cannot be simply used to drive the PWM, but the timer function and related frequency parameters need to be set to work. ```` #define LEDC_CHANNEL_0 0 ```` Defines the channels used by the timer. PicoW S3 has a total of 16 channels, and channel 0 is used here. ```` #define LEDC_TIMER_13_BIT 13 ```` The timer is defined as a 13 bit timer, that is, the maximum count of the timer is 2 to the 13th power. ```` #define LEDC_BASE_FREQ 5000 ```` This is the frequency at which the timer is set, in Hz. The next brightness and fadeAmount parameters represent the duty cycle of the PWM and the value for each change, respectively. ```` void ledcAnalogWrite(uint32_t value, uint32_t valueMax 255) ```` This function calculates the PWM duty cycle and sets the PWM duty cycle, similar to Arduino's analogWrite function. As you can see, the maximum value of the passed parameter is 255, which is for compatibility with analogWrite. ```` ledcSetup(LEDC_CHANNEL_0, LEDC_BASE_FREQ, LEDC_TIMER_13_BIT); ledcAttachPin(LED_PIN, LEDC_CHANNEL_0); ```` These two functions are PicoW S3 timer setting functions. The function prototype and principle are not described here. If you are interested, you can look at the underlying source code (source address: C:\\Users\\“your PC”\\AppData\\Local\\Arduino15 \\packages\\esp32\\ hardware\\ adafruit_metro_esp32s2 \\0.0.3\\libraries\\ESP32\\), you only need to know how to use these functions to set the relevant timer. About what is a PWM signal, it has been explained before, and it will not be explained here. >Note: Any pin of PicoW S3 can be configured as PWM output, you can try to modify the code to complete your project. ## Project 3 ADC ADC (analog to digital converter or A/D converter) refers to converting an analog signal into a digital signal. The ADC of PicoW S3 is 13 bit, the maximum output value is 8191, while the Arduino UNO is 10 bit, and the maximum output value is 1023. Therefore, the accuracy is higher than that of Arduino UNO, and the conversion rate is faster, and in use Compatible with Arduino analogRead function, you can read it directly. ### Required components Analog angle sensor X 1 ![](../assets/images/Lesson3 1.png) Breadboard X 1 ![](../assets/images/Lesson3 2.png) PicoW S3 Motherboard X 1 ![](../assets/images/PicoW S3.png) ### Hardware connection Plug the potentiometer to the PicoW S3 motherboard, and then plug the analog angle sensor to IO2 (IO2 is used in the experiment). After the components are connected, use the USB cable to connect the PicoW S3 and the computer. ### Enter code Open the Arduino IDE. Although it is possible to copy the code directly, we recommend that you enter the code manually to familiarize yourself with it. code show as below: <details> <summary>Expand to view</summary> <pre><code> void setup() { // put your setup code here, to run once: Serial.begin(115200); } void loop() { // put your main code here, to run repeatedly: Serial.println(analogRead(2)); delay(100); } </code></pre> </details> After the input is complete, click \"Compile\" to check the code for errors. After making sure there are no errors, you can start uploading. After clicking \"Upload\", the IDE will send the code to the PicoW S3 motherboard. After the upload is complete, open the serial monitor of the Arduino IDE, rotate the analog angle sensor, and you can see the value changes in the serial monitor, as shown in the following figure: ![](../assets/images/Lesson3 3.png) ### Code Analysis Since the ADC of PicoW S3 is fully compatible with Arduino, the analogRead function will not be explained too much here. Note: If you are not particularly familiar with the basic functions of Arduino, you can [click the link](https://www.arduino.cc/en/Tutorial/BuiltInExamples) to learn. ## Project 4 I2C The I2C of PicoW S3 can be configured to any I/O port, and you can configure it by passing relevant parameters. For the convenience of use, we have configured I2C by default, which is fully compatible with Arduino, the default configuration pins can be seen in Chapter 1 Introduction. This project is based on I2C default configuration to drive OLED display. required components I2C OLED 12864 Display X 1 ![](../assets/images/Lesson4 1.png) Breadboard X 1 ![](../assets/images/Lesson3 2.png) PicoW S3 Motherboard X 1 ![](../assets/images/PicoW S3.png) ### Hardware connection Plug the PicoW S3 motherboard into the breadboard, then plug the OLED display into the I2C port. (SDA is 33, SCL is 34) After the components are connected, use the USB cable to connect the PicoW S3 and the computer. ### Enter code Open the Arduino IDE. Although it is possible to copy the code directly, we recommend that you enter the code manually to familiarize yourself with it. code show as below: <details> <summary>Expand to view</summary> <pre><code> #include <Wire.h> int UG2864Address 0x3C;//OLED UG2864 device 7 bit address prog_char F8X16[][16] PROGMEM { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,// 0 0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00,//!1 0x00,0x10,0x0C,0x06,0x10,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//\"2 0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00,//#3 0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00,//$4 0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00,//%5 0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10,//&6 0x10,0x16,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//'7 0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00,//(8 0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00,//)9 0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00,//*10 0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00,//+11 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00,0x00,0x00,//,12 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,// 13 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00,//.14 0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00,///15 0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00,//016 0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//117 0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00,//218 0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00,//319 0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00,//420 0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00,//521 0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00,//622 0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00,//723 0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00,//824 0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00,//925 0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,//:26 0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x60,0x00,0x00,0x00,0x00,//;27 0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00,//<28 0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,// 29 0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00,//>30 0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00,//?31 0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00,//@32 0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20,//A33 0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00,//B34 0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00,//C35 0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00,//D36 0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00,//E37 0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00,//F38 0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00,//G39 0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20,//H40 0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//I41 0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00,//J42 0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00,//K43 0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00,//L44 0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00,//M45 0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00,//N46 0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00,//O47 0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00,//P48 0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00,//Q49 0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20,//R50 0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00,//S51 0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//T52 0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//U53 0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00,//V54 0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00,//W55 0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20,//X56 0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//Y57 0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00,//Z58 0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00,//[59 0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00,//\\60 0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00,//]61 0x00,0x00,0x04,0x02,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//^62 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,//_63 0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//`64 0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20,//a65 0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00,//b66 0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00,//c67 0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20,//d68 0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00,//e69 0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//f70 0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00,//g71 0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//h72 0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//i73 0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,//j74 0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00,//k75 0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//l76 0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F,//m77 0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//n78 0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//o79 0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00,//p80 0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80,//q81 0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00,//r82 0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00,//s83 0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00,//t84 0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20,//u85 0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00,//v86 0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00,//w87 0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00,//x88 0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00,//y89 0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00,//z90 0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40,//{91 0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,//92 0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00,//}93 0x00,0x06,0x01,0x01,0x02,0x02,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//~94 }; char ch_buf[17] {0}; int RES 6;//Gadgeteer PIN6 int DC 7;//Gadgeteer PIN3 void Writec(unsigned char COM) { Wire.beginTransmission(UG2864Address); Wire.write(0x00); Wire.write(COM); Wire.endTransmission(); } void Writed(unsigned char DATA) { Wire.beginTransmission(UG2864Address); Wire.write(0x40); Wire.write(DATA); Wire.endTransmission(); } void SSD1306() { Writec(0XAE);//display off Writec(0X00);//set lower column address Writec(0X10);//set higher column address Writec(0X40);//set display start line Writec(0XB0);//set page address Writec(0X81);//set contract control Writec(0XCF);// VCC Generated by Internal DC/DC Circuit Writec(0XA0);//set segment remap column address 127 is mapped to SEG0 Writec(0XA6);//normal / reverse normal display Writec(0XA8);//multiplex ratio Writec(0X3F);//1/64 Writec(0XC0);//Com scan direction remapped mode. Scan from COM[N 1] to COM0 Writec(0XD3);//set display offset Writec(0X00); Writec(0XD5);//set osc division Writec(0X80); Writec(0XD9);//set pre charge period Writec(0X11); Writec(0XDa);//set COM pins Writec(0X12); Writec(0X8d);/*set charge pump enable*/ Writec(0X14); Writec(0Xdb);//Set VcomH Writec(0X20); Writec(0XAF);//display ON } void fill(unsigned char dat) { unsigned char i,j; Writec(0x00);//set lower column address Writec(0x10);//set higher column address Writec(0xB0);//set page address for(j 0;j<8;j++) { Writec(0xB0+j);//set page address Writec(0x00);//set lower column address Writec(0x10);//set higher column address for(i 0;i<128;i++) { Writed(dat); } } } void show_string(unsigned char x,unsigned char y,char *s) { unsigned char i,j,lower,higher; char *t; t s; lower y%16; higher y/16; if((x>3) (y>120)) return; Writec(0xB0+x*2);//set page address Writec(lower);//set lower column address Writec(0x10+higher);//set higher column address for(j 0;*s! '\\0';j++) { for(i 0;i<8;i++){ ch_buf[i] pgm_read_word(&F8X16[*s 32][i]); } for(i 0;i<8;i++) Writed(ch_buf[i]); s++; } Writec(0xB0+x*2+1);//set page address Writec(lower);//set lower column address Writec(0x10+higher);//set higher column address s t; for(j 0;*s! '\\0';j++) { for(i 0;i<8;i++){ ch_buf[i] pgm_read_word(&F8X16[*s 32][i+8]); } for(i 0;i<8;i++) Writed(ch_buf[i]); s++; } } void oled_init(void) { pinMode(RES,OUTPUT);//RES pinMode(DC,OUTPUT);//D/C# digitalWrite(DC,LOW); Wire.begin(); digitalWrite(RES,HIGH); delay(100); digitalWrite(RES,LOW); delay(100); digitalWrite(RES,HIGH); delay(100); SSD1306(); fill(0x00); } void setup() { oled_init(); } void loop() { fill(0x00); show_string(0,12,\"BananaPi\"); show_string(2,12,\"banana pi.org\"); while(1); } </code></pre> </details> 输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后 IDE \t会把代码发送给 PicoW S3 主板。上传完成后，OLED 显示屏会显示“BananaPi banana pi.org”字样。 ### 代码分析 本项目的代码相对于前面的项目较多，主要是基于 I2C 通信对 OLED 显示屏底层寄存器的直接驱动。 ``` void Writec(unsigned char COM) ``` 设置寄存器函数，通过 I2C 对 OLED 显示屏设置，I2C 使用方法完全兼容 Arduino。 ``` void Writed(unsigned char DATA) ``` 写数据函数，I2C 使用方法完全兼容 Arduino。 >注意：PicoW S3 的 I2C 与 Arduino 完全兼容，主要是调用 Wire 库文件使用。 ## 项目五 SPI 在很多传感器中，都使用 SPI 通信，因为 SPI 通信速率相对于 I2C 更快，没有地址冲突的弊端。SPI，是 一种高速的、全双工、同步的通信总线，而 PicoW S3 的 SPI 可以配置到所有 I/O，您可以阅览底层 代码进行使用（初学者不建议使用）。为了更好的使用体验，PicoW S3 默认情况下配置了IO35、IO36、IO37 为 SPI 口，在使用上则完全兼容 Arduino。 本项目使用 PicoW S3，通过 SPI 读取 BME280 温湿度传感器的数据，示例中使用的是BME280 库文件，关于 SPI 驱动您可以阅览 BEM280 库文件，[点击链接](https://github.com/DFRobot/DFRobot_BME280)下载 BME280 库文件。 ### 所需元件 BME280 温湿度传感器 X 1 ![](../assets/images/Lesson5 1.png) >注意：BME280 传感器本身支持 I2C 和 SPI 通信，这里我们采用 SPI 通信。 面包板 X 1 ![](../assets/images/Lesson3 2.png) PicoW S3 主板 X 1 ![](../assets/images/PicoW S3.png) ### 输入代码 打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。 （这个程序需要DFRobot_BME280库，需要在[GitHub](https://github.com/DFRobot/DFRobot_BME280)下载，解压到Arduino\\ Library 文件夹下 ）代码如下： <details> <summary>展开查看</summary> <pre><code> /*! * read_data_spi.ino * * Download this demo to test read data from bme280, connect sensor through spi interface * Connect cs pin to io 2 * Data will print on your serial monitor * * Copyright [DFRobot](http://www.dfrobot.com), 2016 * Copyright GNU Lesser General Public License * * version V1.0 * date 12/03/2019 */ #include \"DFRobot_BME280.h\" #include \"Wire.h\" typedef DFRobot_BME280_SPI BME; // ******** use abbreviations instead of full names ******** # define PIN_CS 2 BME bme(&SPI, PIN_CS); // select TwoWire peripheral and set cs pin id #define SEA_LEVEL_PRESSURE 1015.0f // show last sensor operate status void printLastOperateStatus(BME::eStatus_t eStatus) { switch(eStatus) { case BME::eStatusOK: Serial.println(\"everything ok\"); break; case BME::eStatusErr: Serial.println(\"unknow error\"); break; case BME::eStatusErrDeviceNotDetected: Serial.println(\"device not detected\"); break; case BME::eStatusErrParameter: Serial.println(\"parameter error\"); break; default: Serial.println(\"unknow status\"); break; } } void setup() { Serial.begin(115200); bme.reset(); Serial.println(\"bme read data test\"); while(bme.begin() ! BME::eStatusOK) { Serial.println(\"bme begin faild\"); printLastOperateStatus(bme.lastOperateStatus); delay(2000); } Serial.println(\"bme begin success\"); delay(100); } void loop() { float temp bme.getTemperature(); uint32_t press bme.getPressure(); float alti bme.calAltitude(SEA_LEVEL_PRESSURE, press); float humi bme.getHumidity(); Serial.println(); Serial.println(\" start print \"); Serial.print(\"temperature (unit Celsius): \"); Serial.println(temp); Serial.print(\"pressure (unit pa): \"); Serial.println(press); Serial.print(\"altitude (unit meter): \"); Serial.println(alti); Serial.print(\"humidity (unit percent): \"); Serial.println(humi); Serial.println(\" end print \"); delay(1000); } </code></pre> </details> After the input is complete, click \"Compile\" to check the code for errors. After making sure there are no errors, you can start uploading. After clicking \"Upload\", the IDE will send the code to the PicoW S3 motherboard. Open the Arduino serial monitor, you can see the print information as follows: ![](../assets/images/Lesson5 2.png) ### Code Analysis This project uses the BME280 library file, and the SPI bottom layer is not operated in the Item 5.ino file. However, the SPI of PicoW ESP32 S3 is fully compatible with Arduino. ## Item Six WS2812 PicoW S3 integrates an RGB color light with model number WS2812. This project is an experiment to light up the RGB lights of PicoW S3. ### Required components LPicoW S3 Motherboard X 1 ![](../assets/images/PicoW S3.png) > Note: No other sensors need to be connected for this project. ### Enter code Open the Arduino IDE. Although it is possible to copy the code directly, we recommend that you enter the code manually to familiarize yourself with it. (This program requires the Adafruit_NeoPixel library, which needs to be downloaded from [GitHub](https://github.com/adafruit/Adafruit_NeoPixel) and unzipped to the Arduino\\ Library folder) The code is as follows: <details> <summary>Expand to view</summary> <pre><code> // NeoPixel Ring simple sketch (c) 2013 Shae Erisson // Released under the GPLv3 license to match the rest of the // Adafruit NeoPixel library #include <Adafruit_NeoPixel.h> #ifdef __AVR__ #include <avr/power.h> // Required for 16 MHz Adafruit Trinket #endif // Which pin on the Arduino is connected to the NeoPixels? #define PIN 18 // On Trinket or Gemma, suggest changing this to 1 // How many NeoPixels are attached to the Arduino? #define NUMPIXELS 1 // Popular NeoPixel ring size // When setting up the NeoPixel library, we tell it how many pixels, // and which pin to use to send signals. Note that for older NeoPixel // strips you might need to change the third parameter see the // strandtest example for more information on possible values. Adafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800); #define DELAYVAL 500 // Time (in milliseconds) to pause between pixels void setup() { // These lines are specifically to support the Adafruit Trinket 5V 16 MHz. // Any other board, you can remove this part (but no harm leaving it): #if defined(__AVR_ATtiny85__) && (F_CPU 16000000) clock_prescale_set(clock_div_1); #endif // END of Trinket specific code. pixels.begin(); // INITIALIZE NeoPixel strip object (REQUIRED) } void loop() { pixels.clear(); // Set all pixel colors to 'off' // The first NeoPixel in a strand is #0, second is 1, all the way up // to the count of pixels minus one. for(int i 0; i < NUMPIXELS; i++) { // For each pixel... // pixels.Color() takes RGB values, from 0,0,0 up to 255,255,255 // Here we're using a moderately bright green color: pixels.setPixelColor(i, pixels.Color(0, 150, 0)); pixels.show(); // Send the updated pixel colors to the hardware. delay(DELAYVAL); // Pause before next pass through loop } } </code></pre> </details> After the input is complete, click \"Compile\" to check the code for errors. After making sure there are no errors, you can start uploading. After clicking \"Upload\", the IDE will send the code to the PicoW S3 motherboard. After reset, the WS2812 light will start to light up green, > Note: If you need other colors, you can modify the RGB values ​​in the code. ### Code Analysis This project uses the WS2812 light integrated in PicoW S3, and the default GPIO is 48. ```` #define PIN 48 ```` Set GPIO pin number ```` #define NUMPIXELS 1 ```` Set the number of lights, if you want to connect more WS2812, you can change an IO and modify the number of lights. ## Item 7 Touch Sensor The PicoW S3 provides up to 14 capacitive sensor GPIOs capable of detecting differences in capacitance caused by direct contact or proximity of fingers or other objects. This low noise feature and high sensitivity design of the circuit are suitable for smaller touchpads and can be used directly for touch switches. This project explains how to get the touch sensor status of PicoW S3 through Arduino code and print the status. ### Required components PicoW S3 Motherboard X 1 ![](../assets/images/PicoW S3.png) > Note: No other sensors need to be connected for this project. ### Enter code Open the Arduino IDE. Although it is possible to copy the code directly, we recommend that you enter the code manually to familiarize yourself with it. code show as below: <details> <summary>Expand to view</summary> <pre><code> void setup() { Serial.begin(115200); delay(1000); // give me time to bring up serial monitor Serial.println(\"PicoW S3 Touch Test\"); } void loop(){ Serial.println(touchRead(T2)); // get value using T0 >D9 delay(100); } </code></pre> </details> After the input is complete, click \"Compile\" to check the code for errors. After making sure there are no errors, you can start uploading. After clicking \"Upload\", the IDE will send the code to the PicoW S3 motherboard. Open the Arduino IDE serial monitor, and touch GPIO2 (T2 corresponds to GPIO2), you can see that the data that will be printed suddenly becomes smaller, as shown in the following figure: ![](../assets/images/Lesson8 1.png) ### Code Analysis To get the GPIO status of the touch sensor, just call the touchRead function. The function prototype is as follows: ```` uint16_t touchRead(uint8_t pin) ```` Returns \"0\" for no touch and \"1\" for touch. The pins are T0~T9, and the pins corresponding to PicoW are shown in the following table: <table> <tr> <td></td> </tr> <tr> <td>Touch Sensor Serial Number </td> <td>The corresponding ESP32 hardware </td> <td>PicoW S3</td> <td> </td> </tr> <tr> <td>T1</td> <td>GPIO1</td> <td>IO1</td> </tr> <tr> <td>T2 </td> <td>GPIO2</td> <td>IO2</td> </tr> <tr> <td>T3 </td> <td>GPIO3</td> <td>IO3</td> </tr> <tr> <td>T4 </td> <td>GPIO4</td> <td>IO4</td> </tr> <tr> <td>T5 </td> <td>GPIO5</td> <td>IO5</td> </tr> <tr> <td>T6 </td> <td>GPIO6</td> <td>IO6</td> </tr> <tr> <td>T7 </td> <td>GPIO7</td> <td>IO7</td> </tr> <tr> <td>T8 </td> <td>GPIO8</td> <td>IO8</td> </tr> <tr> <td>T9 </td> <td>GPIO9</td> <td>IO9</td> </tr> <tr> <td>T10</td> <td>GPIO10</td> <td>IO10</td> </tr> <tr> <td>T11</td> <td>GPIO11</td> <td>IO11</td> </tr> <tr> <td>T12</td> <td>GPIO12</td> <td>IO12</td> </tr> <tr> <td>T13</td> <td>GPIO13</td> <td>IO13</td> </tr> <tr> <td>T14</td> <td>GPIO14</td> <td>IO14</td> </tr> <tr> <td></td> </tr"},"/PicoW_S3_doc/en/Arduino/Environment.html":{"title":"Environment build","content":"# Environment build Due to the board size, the Arduino usage of PicoW S3 will be more complicated, we do not recommend you to use PicoW S3 to learn Arduino. This article will guide you through installing Arduino support for the PicoW S3. ![](../assets/images/logo_arduino.png) > Refer to [arduino esp32 DOC Getting Started » Installing](https://docs.espressif.com/projects/arduino esp32/en/latest/installing.html) ## Install support using Arduino IDE Here's how to install the Arduino ESP32 directly from the Arduino IDE. > Starting with Arduino IDE version 1.6.4, Arduino allows the use of the Boards Manager to install third party platform packages. There are packages for Windows, macOS and Linux. Arduino IDE download address: https://www.arduino.cc/en/software > The UI of Arduino IDE 2.0 is slightly different from that of Arduino IDE 1.8.x. This article is based on version 1.8.13, but it does not affect the reference of users who use version 2.0. To install the esp32 platform package using Boards Managaer, follow these steps: Install the current upstream Arduino IDE 1.8 or higher. Start Arduino and open the File > Preferences window and find Additional Board Manager URLs. ![](../assets/images/install_guide_preferences.png) Stable version link: ```` https://raw.githubusercontent.com/espressif/arduino esp32/gh pages/package_esp32_index.json ```` Development version link: ```` https://raw.githubusercontent.com/espressif/arduino esp32/gh pages/package_esp32_dev_index.json ```` Enter one of the above publish links after Additional Board Manager URLs. You can add multiple URLs, one per line. ![](../assets/images/install_guide_boards_manager_url.png) Open Tools > Board > Board Manager from the menu to search for and install the esp32 platform. ![](../assets/images/install_guide_boards_manager_esp32.png) After restarting the arduino IDE, you can see that there are more ESP32 Arduino options in the development board options. Select the model `ESP32S3 Dev Module`, and then configure it according to the content shown in the figure below. Improper configuration cannot be used. Please be sure to configure it according to the content shown in the figure below! ![](../assets/images/Board_chose.jpg)"},"/PicoW_S3_doc/en/index.html":{"title":"【 BPI-PicoW-S3 Development Board 】","content":"# 【 BPI PicoW S3 Development Board 】 ## Introduction ![](assets/images/BPI PicoW S3.jpg) The Banana Pi BPI PicoW is equipped with a low power microcontroller, a development board designed for IoT development and Maker DIY projects. The size is same as the Raspberry Pi Pico board, supports 2.4 GHz Wi Fi and Bluetooth® LE dual mode wireless communication, peripherals are compatible with its low power hardware design, and consumes only 10uA in deep sleep mode. In terms of programming, PicoW S3 supports ESP IDF, Arduino, micropython, CircuitPython and other mainstream platforms. ## Programming with CircuitPython > BPI PicoW S3 is pre installed with tinyUF2 and CircuitPython firmware out of box. It is recommended to use CircuitPython to quickly get started with the BPI PicoW S3 development board as it is considered to be the most beginners friendly platform. ![](assets/images/CircuitPython_Repo_header_logo.jpg) CircuitPython is a programming language designed to simplify programming experiments and learning on microcontroller development boards. CircuitPython programming with the Mu editor is the least difficult way to get started. Install the software and connect the board to PC for the very first project. ## Programming with MicroPython ![](assets/images/Mircopython.png) Regardless of the programmer is a beginner or not, MicroPython is considered to be less difficult to develop than other MCU programming languages. Its code is easy to understand compared to other programming languages, and it has various resources accumulated over the years by the open source community. Just like Python, it has strong community and application value. By uploading the MicroPython firmware, you can use the Python programming language to program on the development board. ## Programming with Arduino Provides software tools and best examples to get started with Arduino, lowering the barriers to entry into professional ESP32 embedded development. ![](assets/images/Arduino_logo_1200x350.png) >Arduino does not provide much of the beginners' content, basic knowledge of C/C++ programming is required in order to operate. ## Information and resources [Official WIKI](https://wiki.banana pi.org/BPI PicoW S3_%E5%BC%80%E5%8F%91%E6%9D%BF) [GitHub: BPI PicoW S3 development board schematic PDF](https://github.com/BPI STEAM/BPI PicoW Doc/blob/main/sch/BPI PicoW V0.4.pdf) [ESP32 S3 Datasheet](https://www.espressif.com/sites/default/files/documentation/esp32 s3_datasheet_cn.pdf) [ESP32 S3 Technical Reference Manual](https://www.espressif.com/sites/default/files/documentation/esp32 s3_technical_reference_manual_cn.pdf) ## Sample purchase [Official AliExpress](https://www.aliexpress.com/item/1005004775634442.html?spm 5261.ProductManageOnline.0.0.15744edfAyCaNk) [Official Taobao](https://item.taobao.com/item.htm?spm a2126o.success.0.0.25b04831CHV1Nc&id 684134360199) OEM&OEM customized service: sales@banana pi.com"}}